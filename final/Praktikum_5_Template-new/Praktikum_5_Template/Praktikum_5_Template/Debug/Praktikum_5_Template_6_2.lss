
Praktikum_5_Template_6_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004096  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000056  00802000  00004096  0000412a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000364  00802056  00802056  00004180  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004180  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000041dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000720  00000000  00000000  00004220  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000169ce  00000000  00000000  00004940  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000062b5  00000000  00000000  0001b30e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c06e  00000000  00000000  000215c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000176c  00000000  00000000  0002d634  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00038cbb  00000000  00000000  0002eda0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000af5e  00000000  00000000  00067a5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008b8  00000000  00000000  000729c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000cec1  00000000  00000000  00073278  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 99 0d 	jmp	0x1b32	; 0x1b32 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 75 08 	jmp	0x10ea	; 0x10ea <__vector_39>
      a0:	0c 94 a7 08 	jmp	0x114e	; 0x114e <__vector_40>
      a4:	0c 94 d9 08 	jmp	0x11b2	; 0x11b2 <__vector_41>
      a8:	0c 94 0b 09 	jmp	0x1216	; 0x1216 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	1e c7       	rjmp	.+3644   	; 0xf5a <__vector_71>
     11e:	00 00       	nop
     120:	4e c7       	rjmp	.+3740   	; 0xfbe <__vector_72>
     122:	00 00       	nop
     124:	7e c7       	rjmp	.+3836   	; 0x1022 <__vector_73>
     126:	00 00       	nop
     128:	ae c7       	rjmp	.+3932   	; 0x1086 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	9c 16       	cp	r9, r28
     1fe:	9c 16       	cp	r9, r28
     200:	9c 16       	cp	r9, r28
     202:	d2 16       	cp	r13, r18
     204:	c2 16       	cp	r12, r18
     206:	cf 16       	cp	r12, r31
     208:	9c 16       	cp	r9, r28
     20a:	9c 16       	cp	r9, r28
     20c:	d2 16       	cp	r13, r18
     20e:	c2 16       	cp	r12, r18

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1ce6>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x64ce>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x64a6>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x54ce>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1ca6>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 e9       	ldi	r30, 0x96	; 150
     4ba:	f0 e4       	ldi	r31, 0x40	; 64
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a6 35       	cpi	r26, 0x56	; 86
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a6 e5       	ldi	r26, 0x56	; 86
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	aa 3b       	cpi	r26, 0xBA	; 186
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 24 19 	call	0x3248	; 0x3248 <main>
     4e0:	0c 94 49 20 	jmp	0x4092	; 0x4092 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <ntc_data_is_ready>:
 * \retval the raw ADC value from the current ntc_sensor_sample
 */
int16_t ntc_get_raw_value(void)
{
	return ntc_sensor_sample;
}
     4e6:	9f b7       	in	r25, 0x3f	; 63
     4e8:	f8 94       	cli
     4ea:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <ntc_sensor_data_ready>
     4ee:	88 23       	and	r24, r24
     4f0:	21 f0       	breq	.+8      	; 0x4fa <ntc_data_is_ready+0x14>
     4f2:	10 92 5b 20 	sts	0x205B, r1	; 0x80205b <ntc_sensor_data_ready>
     4f6:	9f bf       	out	0x3f, r25	; 63
     4f8:	08 95       	ret
     4fa:	9f bf       	out	0x3f, r25	; 63
     4fc:	08 95       	ret

000004fe <lightsensor_data_is_ready>:
     4fe:	9f b7       	in	r25, 0x3f	; 63
     500:	f8 94       	cli
     502:	80 91 5a 20 	lds	r24, 0x205A	; 0x80205a <light_sensor_data_ready>
     506:	88 23       	and	r24, r24
     508:	21 f0       	breq	.+8      	; 0x512 <lightsensor_data_is_ready+0x14>
     50a:	10 92 5a 20 	sts	0x205A, r1	; 0x80205a <light_sensor_data_ready>
     50e:	9f bf       	out	0x3f, r25	; 63
     510:	08 95       	ret
     512:	9f bf       	out	0x3f, r25	; 63
     514:	08 95       	ret

00000516 <ntc_get_temperature>:
 * \note The result is inaccurate for temperatures outside 5-45 degrees.
 *
 * \retval the temperature in Celsius
 */
int8_t ntc_get_temperature(void)
{
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
	int8_t retval = 0;
	float ntc_sample = ntc_sensor_sample;
     51a:	c0 91 58 20 	lds	r28, 0x2058	; 0x802058 <ntc_sensor_sample>
     51e:	d0 91 59 20 	lds	r29, 0x2059	; 0x802059 <ntc_sensor_sample+0x1>
     522:	be 01       	movw	r22, r28
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 27 1b 	call	0x364e	; 0x364e <__floatunsisf>
	if (ntc_sensor_sample > 697) {
		retval = (int8_t)((-0.0295 * ntc_sample) + 40.5);
	} if (ntc_sensor_sample > 420) {
     52c:	c5 3a       	cpi	r28, 0xA5	; 165
     52e:	d1 40       	sbci	r29, 0x01	; 1
     530:	80 f0       	brcs	.+32     	; 0x552 <ntc_get_temperature+0x3c>
		retval = (int8_t)((-0.0474 * ntc_sample) + 53.3);
     532:	21 e8       	ldi	r18, 0x81	; 129
     534:	36 e2       	ldi	r19, 0x26	; 38
     536:	42 e4       	ldi	r20, 0x42	; 66
     538:	5d eb       	ldi	r21, 0xBD	; 189
     53a:	0e 94 b5 1b 	call	0x376a	; 0x376a <__mulsf3>
     53e:	23 e3       	ldi	r18, 0x33	; 51
     540:	33 e3       	ldi	r19, 0x33	; 51
     542:	45 e5       	ldi	r20, 0x55	; 85
     544:	52 e4       	ldi	r21, 0x42	; 66
     546:	0e 94 2a 1a 	call	0x3454	; 0x3454 <__addsf3>
     54a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <__fixsfsi>
     54e:	86 2f       	mov	r24, r22
     550:	0f c0       	rjmp	.+30     	; 0x570 <ntc_get_temperature+0x5a>
	} else {
		retval = (int8_t)((-0.0777 * ntc_sample) + 65.1);
     552:	2d e2       	ldi	r18, 0x2D	; 45
     554:	31 e2       	ldi	r19, 0x21	; 33
     556:	4f e9       	ldi	r20, 0x9F	; 159
     558:	5d eb       	ldi	r21, 0xBD	; 189
     55a:	0e 94 b5 1b 	call	0x376a	; 0x376a <__mulsf3>
     55e:	23 e3       	ldi	r18, 0x33	; 51
     560:	33 e3       	ldi	r19, 0x33	; 51
     562:	42 e8       	ldi	r20, 0x82	; 130
     564:	52 e4       	ldi	r21, 0x42	; 66
     566:	0e 94 2a 1a 	call	0x3454	; 0x3454 <__addsf3>
     56a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <__fixsfsi>
     56e:	86 2f       	mov	r24, r22
	}
	return retval;
}
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <lightsensor_get_raw_value>:
 * \retval the raw ADC value from the current ntc_sensor_sample
 */
int16_t lightsensor_get_raw_value(void)
{
	return light_sensor_sample;
}
     576:	80 91 56 20 	lds	r24, 0x2056	; 0x802056 <__data_end>
     57a:	90 91 57 20 	lds	r25, 0x2057	; 0x802057 <__data_end+0x1>
     57e:	08 95       	ret

00000580 <__portable_avr_delay_cycles>:
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
     580:	61 50       	subi	r22, 0x01	; 1
     582:	71 09       	sbc	r23, r1
     584:	81 09       	sbc	r24, r1
     586:	91 09       	sbc	r25, r1
     588:	d9 f7       	brne	.-10     	; 0x580 <__portable_avr_delay_cycles>
}
     58a:	08 95       	ret

0000058c <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	1f 92       	push	r1
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     5a4:	00 e0       	ldi	r16, 0x00	; 0
     5a6:	16 e0       	ldi	r17, 0x06	; 6
     5a8:	68 94       	set
     5aa:	ff 24       	eor	r15, r15
     5ac:	f3 f8       	bld	r15, 3
     5ae:	f8 01       	movw	r30, r16
     5b0:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     5b2:	63 e0       	ldi	r22, 0x03	; 3
     5b4:	70 e0       	ldi	r23, 0x00	; 0
     5b6:	80 e0       	ldi	r24, 0x00	; 0
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	e2 df       	rcall	.-60     	; 0x580 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     5bc:	f8 01       	movw	r30, r16
     5be:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     5c0:	63 e0       	ldi	r22, 0x03	; 3
     5c2:	70 e0       	ldi	r23, 0x00	; 0
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	db df       	rcall	.-74     	; 0x580 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     5ca:	0f 2e       	mov	r0, r31
     5cc:	fb e2       	ldi	r31, 0x2B	; 43
     5ce:	bf 2e       	mov	r11, r31
     5d0:	f0 2d       	mov	r31, r0
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     5d2:	b9 82       	std	Y+1, r11	; 0x01
     5d4:	80 ea       	ldi	r24, 0xA0	; 160
     5d6:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     5d8:	f8 d3       	rcall	.+2032   	; 0xdca <usart_spi_init>
     5da:	c1 2c       	mov	r12, r1
     5dc:	d1 2c       	mov	r13, r1
     5de:	76 01       	movw	r14, r12
     5e0:	00 e4       	ldi	r16, 0x40	; 64
     5e2:	12 e4       	ldi	r17, 0x42	; 66
     5e4:	2f e0       	ldi	r18, 0x0F	; 15
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	43 e0       	ldi	r20, 0x03	; 3
     5ea:	be 01       	movw	r22, r28
     5ec:	6f 5f       	subi	r22, 0xFF	; 255
     5ee:	7f 4f       	sbci	r23, 0xFF	; 255
     5f0:	80 ea       	ldi	r24, 0xA0	; 160
     5f2:	99 e0       	ldi	r25, 0x09	; 9
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     5f4:	19 d4       	rcall	.+2098   	; 0xe28 <usart_spi_setup_device>
     5f6:	00 e6       	ldi	r16, 0x60	; 96
     5f8:	16 e0       	ldi	r17, 0x06	; 6
     5fa:	ff 24       	eor	r15, r15
     5fc:	f3 94       	inc	r15
     5fe:	f8 01       	movw	r30, r16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     600:	f6 82       	std	Z+6, r15	; 0x06
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     602:	b9 82       	std	Y+1, r11	; 0x01
     604:	be 01       	movw	r22, r28
     606:	6f 5f       	subi	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	80 ea       	ldi	r24, 0xA0	; 160
     60c:	99 e0       	ldi	r25, 0x09	; 9
     60e:	26 d4       	rcall	.+2124   	; 0xe5c <usart_spi_select_device>
     610:	f8 01       	movw	r30, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     612:	f6 82       	std	Z+6, r15	; 0x06
     614:	e0 ea       	ldi	r30, 0xA0	; 160
     616:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     618:	81 81       	ldd	r24, Z+1	; 0x01
     61a:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     61c:	fd cf       	rjmp	.-6      	; 0x618 <st7565r_init+0x8c>
     61e:	80 ea       	ldi	r24, 0xA0	; 160
     620:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     628:	81 81       	ldd	r24, Z+1	; 0x01
     62a:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     62c:	fd cf       	rjmp	.-6      	; 0x628 <st7565r_init+0x9c>
     62e:	e0 ea       	ldi	r30, 0xA0	; 160
     630:	f9 e0       	ldi	r31, 0x09	; 9
     632:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     634:	81 83       	std	Z+1, r24	; 0x01
     636:	80 81       	ld	r24, Z
     638:	be 01       	movw	r22, r28
     63a:	6f 5f       	subi	r22, 0xFF	; 255
     63c:	7f 4f       	sbci	r23, 0xFF	; 255
     63e:	80 ea       	ldi	r24, 0xA0	; 160
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     640:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     642:	22 d4       	rcall	.+2116   	; 0xe88 <usart_spi_deselect_device>
     644:	8b e2       	ldi	r24, 0x2B	; 43
     646:	89 83       	std	Y+1, r24	; 0x01
     648:	be 01       	movw	r22, r28
     64a:	6f 5f       	subi	r22, 0xFF	; 255
     64c:	7f 4f       	sbci	r23, 0xFF	; 255
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	99 e0       	ldi	r25, 0x09	; 9
     652:	04 d4       	rcall	.+2056   	; 0xe5c <usart_spi_select_device>
     654:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     656:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     65a:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     65c:	f9 e0       	ldi	r31, 0x09	; 9
     65e:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     660:	85 ff       	sbrs	r24, 5
     662:	fd cf       	rjmp	.-6      	; 0x65e <st7565r_init+0xd2>
     664:	86 ea       	ldi	r24, 0xA6	; 166
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     666:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     66a:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     66c:	f9 e0       	ldi	r31, 0x09	; 9
     66e:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     670:	86 ff       	sbrs	r24, 6
     672:	fd cf       	rjmp	.-6      	; 0x66e <st7565r_init+0xe2>
     674:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     676:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     678:	80 e4       	ldi	r24, 0x40	; 64
     67a:	81 83       	std	Z+1, r24	; 0x01
     67c:	80 81       	ld	r24, Z
     67e:	be 01       	movw	r22, r28
     680:	6f 5f       	subi	r22, 0xFF	; 255
     682:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     684:	80 ea       	ldi	r24, 0xA0	; 160
     686:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     688:	ff d3       	rcall	.+2046   	; 0xe88 <usart_spi_deselect_device>
     68a:	8b e2       	ldi	r24, 0x2B	; 43
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	be 01       	movw	r22, r28
     690:	6f 5f       	subi	r22, 0xFF	; 255
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	80 ea       	ldi	r24, 0xA0	; 160
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	e1 d3       	rcall	.+1986   	; 0xe5c <usart_spi_select_device>
     69a:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     69c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     6a0:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6a2:	f9 e0       	ldi	r31, 0x09	; 9
     6a4:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6a6:	85 ff       	sbrs	r24, 5
     6a8:	fd cf       	rjmp	.-6      	; 0x6a4 <st7565r_init+0x118>
     6aa:	88 ec       	ldi	r24, 0xC8	; 200
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ac:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6b6:	86 ff       	sbrs	r24, 6
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <st7565r_init+0x128>
     6ba:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6bc:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6be:	80 e4       	ldi	r24, 0x40	; 64
     6c0:	81 83       	std	Z+1, r24	; 0x01
     6c2:	80 81       	ld	r24, Z
     6c4:	be 01       	movw	r22, r28
     6c6:	6f 5f       	subi	r22, 0xFF	; 255
     6c8:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ca:	80 ea       	ldi	r24, 0xA0	; 160
     6cc:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6ce:	dc d3       	rcall	.+1976   	; 0xe88 <usart_spi_deselect_device>
     6d0:	8b e2       	ldi	r24, 0x2B	; 43
     6d2:	89 83       	std	Y+1, r24	; 0x01
     6d4:	be 01       	movw	r22, r28
     6d6:	6f 5f       	subi	r22, 0xFF	; 255
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	80 ea       	ldi	r24, 0xA0	; 160
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	be d3       	rcall	.+1916   	; 0xe5c <usart_spi_select_device>
     6e0:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6e2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     6e6:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6e8:	f9 e0       	ldi	r31, 0x09	; 9
     6ea:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ec:	85 ff       	sbrs	r24, 5
     6ee:	fd cf       	rjmp	.-6      	; 0x6ea <st7565r_init+0x15e>
     6f0:	82 ea       	ldi	r24, 0xA2	; 162
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6f2:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     6f6:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6f8:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6fa:	81 81       	ldd	r24, Z+1	; 0x01
     6fc:	86 ff       	sbrs	r24, 6
     6fe:	fd cf       	rjmp	.-6      	; 0x6fa <st7565r_init+0x16e>
     700:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     702:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     704:	80 e4       	ldi	r24, 0x40	; 64
     706:	81 83       	std	Z+1, r24	; 0x01
     708:	80 81       	ld	r24, Z
     70a:	be 01       	movw	r22, r28
     70c:	6f 5f       	subi	r22, 0xFF	; 255
     70e:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     710:	80 ea       	ldi	r24, 0xA0	; 160
     712:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     714:	b9 d3       	rcall	.+1906   	; 0xe88 <usart_spi_deselect_device>
     716:	8b e2       	ldi	r24, 0x2B	; 43
     718:	89 83       	std	Y+1, r24	; 0x01
     71a:	be 01       	movw	r22, r28
     71c:	6f 5f       	subi	r22, 0xFF	; 255
     71e:	7f 4f       	sbci	r23, 0xFF	; 255
     720:	80 ea       	ldi	r24, 0xA0	; 160
     722:	99 e0       	ldi	r25, 0x09	; 9
     724:	9b d3       	rcall	.+1846   	; 0xe5c <usart_spi_select_device>
     726:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     728:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     72c:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     72e:	f9 e0       	ldi	r31, 0x09	; 9
     730:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     732:	85 ff       	sbrs	r24, 5
     734:	fd cf       	rjmp	.-6      	; 0x730 <st7565r_init+0x1a4>
     736:	8f e2       	ldi	r24, 0x2F	; 47
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     738:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     73c:	e0 ea       	ldi	r30, 0xA0	; 160
     73e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     740:	81 81       	ldd	r24, Z+1	; 0x01
     742:	86 ff       	sbrs	r24, 6
     744:	fd cf       	rjmp	.-6      	; 0x740 <st7565r_init+0x1b4>
     746:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     748:	f9 e0       	ldi	r31, 0x09	; 9
     74a:	80 e4       	ldi	r24, 0x40	; 64
     74c:	81 83       	std	Z+1, r24	; 0x01
     74e:	80 81       	ld	r24, Z
     750:	be 01       	movw	r22, r28
     752:	6f 5f       	subi	r22, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	80 ea       	ldi	r24, 0xA0	; 160
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     758:	99 e0       	ldi	r25, 0x09	; 9
     75a:	96 d3       	rcall	.+1836   	; 0xe88 <usart_spi_deselect_device>
     75c:	8b e2       	ldi	r24, 0x2B	; 43
     75e:	89 83       	std	Y+1, r24	; 0x01
     760:	be 01       	movw	r22, r28
     762:	6f 5f       	subi	r22, 0xFF	; 255
     764:	7f 4f       	sbci	r23, 0xFF	; 255
     766:	80 ea       	ldi	r24, 0xA0	; 160
     768:	99 e0       	ldi	r25, 0x09	; 9
     76a:	78 d3       	rcall	.+1776   	; 0xe5c <usart_spi_select_device>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     772:	e0 ea       	ldi	r30, 0xA0	; 160
     774:	f9 e0       	ldi	r31, 0x09	; 9
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     776:	81 81       	ldd	r24, Z+1	; 0x01
     778:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     77a:	fd cf       	rjmp	.-6      	; 0x776 <st7565r_init+0x1ea>
     77c:	88 ef       	ldi	r24, 0xF8	; 248
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     77e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     782:	e0 ea       	ldi	r30, 0xA0	; 160
     784:	f9 e0       	ldi	r31, 0x09	; 9
     786:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     788:	86 ff       	sbrs	r24, 6
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     78a:	fd cf       	rjmp	.-6      	; 0x786 <st7565r_init+0x1fa>
     78c:	e0 ea       	ldi	r30, 0xA0	; 160
     78e:	f9 e0       	ldi	r31, 0x09	; 9
     790:	80 e4       	ldi	r24, 0x40	; 64
     792:	81 83       	std	Z+1, r24	; 0x01
     794:	80 81       	ld	r24, Z
     796:	be 01       	movw	r22, r28
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     798:	6f 5f       	subi	r22, 0xFF	; 255
     79a:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     79c:	80 ea       	ldi	r24, 0xA0	; 160
     79e:	99 e0       	ldi	r25, 0x09	; 9
     7a0:	73 d3       	rcall	.+1766   	; 0xe88 <usart_spi_deselect_device>
     7a2:	8b e2       	ldi	r24, 0x2B	; 43
     7a4:	89 83       	std	Y+1, r24	; 0x01
     7a6:	be 01       	movw	r22, r28
     7a8:	6f 5f       	subi	r22, 0xFF	; 255
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	80 ea       	ldi	r24, 0xA0	; 160
     7ae:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7b0:	55 d3       	rcall	.+1706   	; 0xe5c <usart_spi_select_device>
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7b8:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7ba:	f9 e0       	ldi	r31, 0x09	; 9
     7bc:	81 81       	ldd	r24, Z+1	; 0x01
     7be:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7c0:	fd cf       	rjmp	.-6      	; 0x7bc <st7565r_init+0x230>
     7c2:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7c6:	e0 ea       	ldi	r30, 0xA0	; 160
     7c8:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7ca:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7cc:	86 ff       	sbrs	r24, 6
     7ce:	fd cf       	rjmp	.-6      	; 0x7ca <st7565r_init+0x23e>
     7d0:	e0 ea       	ldi	r30, 0xA0	; 160
     7d2:	f9 e0       	ldi	r31, 0x09	; 9
     7d4:	80 e4       	ldi	r24, 0x40	; 64
     7d6:	81 83       	std	Z+1, r24	; 0x01
     7d8:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7da:	be 01       	movw	r22, r28
     7dc:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7de:	7f 4f       	sbci	r23, 0xFF	; 255
     7e0:	80 ea       	ldi	r24, 0xA0	; 160
     7e2:	99 e0       	ldi	r25, 0x09	; 9
     7e4:	51 d3       	rcall	.+1698   	; 0xe88 <usart_spi_deselect_device>
     7e6:	8b e2       	ldi	r24, 0x2B	; 43
     7e8:	89 83       	std	Y+1, r24	; 0x01
     7ea:	be 01       	movw	r22, r28
     7ec:	6f 5f       	subi	r22, 0xFF	; 255
     7ee:	7f 4f       	sbci	r23, 0xFF	; 255
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	33 d3       	rcall	.+1638   	; 0xe5c <usart_spi_select_device>
     7f6:	81 e0       	ldi	r24, 0x01	; 1
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7fc:	e0 ea       	ldi	r30, 0xA0	; 160
     7fe:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     800:	81 81       	ldd	r24, Z+1	; 0x01
     802:	85 ff       	sbrs	r24, 5
     804:	fd cf       	rjmp	.-6      	; 0x800 <st7565r_init+0x274>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     806:	81 e2       	ldi	r24, 0x21	; 33
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     808:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     80c:	e0 ea       	ldi	r30, 0xA0	; 160
     80e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     810:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     812:	86 ff       	sbrs	r24, 6
     814:	fd cf       	rjmp	.-6      	; 0x810 <st7565r_init+0x284>
     816:	e0 ea       	ldi	r30, 0xA0	; 160
     818:	f9 e0       	ldi	r31, 0x09	; 9
     81a:	80 e4       	ldi	r24, 0x40	; 64
     81c:	81 83       	std	Z+1, r24	; 0x01
     81e:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     820:	be 01       	movw	r22, r28
     822:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     824:	7f 4f       	sbci	r23, 0xFF	; 255
     826:	80 ea       	ldi	r24, 0xA0	; 160
     828:	99 e0       	ldi	r25, 0x09	; 9
     82a:	2e d3       	rcall	.+1628   	; 0xe88 <usart_spi_deselect_device>
     82c:	8b e2       	ldi	r24, 0x2B	; 43
     82e:	89 83       	std	Y+1, r24	; 0x01
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     838:	99 e0       	ldi	r25, 0x09	; 9
     83a:	10 d3       	rcall	.+1568   	; 0xe5c <usart_spi_select_device>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     842:	e0 ea       	ldi	r30, 0xA0	; 160
     844:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     846:	81 81       	ldd	r24, Z+1	; 0x01
     848:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     84a:	fd cf       	rjmp	.-6      	; 0x846 <st7565r_init+0x2ba>
     84c:	81 e8       	ldi	r24, 0x81	; 129
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     84e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     852:	e0 ea       	ldi	r30, 0xA0	; 160
     854:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     856:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     858:	86 ff       	sbrs	r24, 6
     85a:	fd cf       	rjmp	.-6      	; 0x856 <st7565r_init+0x2ca>
     85c:	e0 ea       	ldi	r30, 0xA0	; 160
     85e:	f9 e0       	ldi	r31, 0x09	; 9
     860:	80 e4       	ldi	r24, 0x40	; 64
     862:	81 83       	std	Z+1, r24	; 0x01
     864:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     866:	be 01       	movw	r22, r28
     868:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     86a:	7f 4f       	sbci	r23, 0xFF	; 255
     86c:	80 ea       	ldi	r24, 0xA0	; 160
     86e:	99 e0       	ldi	r25, 0x09	; 9
     870:	0b d3       	rcall	.+1558   	; 0xe88 <usart_spi_deselect_device>
     872:	8b e2       	ldi	r24, 0x2B	; 43
     874:	89 83       	std	Y+1, r24	; 0x01
     876:	be 01       	movw	r22, r28
     878:	6f 5f       	subi	r22, 0xFF	; 255
     87a:	7f 4f       	sbci	r23, 0xFF	; 255
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     87c:	80 ea       	ldi	r24, 0xA0	; 160
     87e:	99 e0       	ldi	r25, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     880:	ed d2       	rcall	.+1498   	; 0xe5c <usart_spi_select_device>
     882:	81 e0       	ldi	r24, 0x01	; 1
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     884:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     888:	e0 ea       	ldi	r30, 0xA0	; 160
     88a:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     88c:	81 81       	ldd	r24, Z+1	; 0x01
     88e:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     890:	fd cf       	rjmp	.-6      	; 0x88c <st7565r_init+0x300>
     892:	81 e2       	ldi	r24, 0x21	; 33
     894:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     898:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     89a:	f9 e0       	ldi	r31, 0x09	; 9
     89c:	81 81       	ldd	r24, Z+1	; 0x01
     89e:	86 ff       	sbrs	r24, 6
     8a0:	fd cf       	rjmp	.-6      	; 0x89c <st7565r_init+0x310>
     8a2:	e0 ea       	ldi	r30, 0xA0	; 160
     8a4:	f9 e0       	ldi	r31, 0x09	; 9
     8a6:	80 e4       	ldi	r24, 0x40	; 64
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8a8:	81 83       	std	Z+1, r24	; 0x01
     8aa:	80 81       	ld	r24, Z
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8ac:	be 01       	movw	r22, r28
     8ae:	6f 5f       	subi	r22, 0xFF	; 255
     8b0:	7f 4f       	sbci	r23, 0xFF	; 255
     8b2:	80 ea       	ldi	r24, 0xA0	; 160
     8b4:	99 e0       	ldi	r25, 0x09	; 9
     8b6:	e8 d2       	rcall	.+1488   	; 0xe88 <usart_spi_deselect_device>
     8b8:	8b e2       	ldi	r24, 0x2B	; 43
     8ba:	89 83       	std	Y+1, r24	; 0x01
     8bc:	be 01       	movw	r22, r28
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8be:	6f 5f       	subi	r22, 0xFF	; 255
     8c0:	7f 4f       	sbci	r23, 0xFF	; 255
     8c2:	80 ea       	ldi	r24, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8c4:	99 e0       	ldi	r25, 0x09	; 9
     8c6:	ca d2       	rcall	.+1428   	; 0xe5c <usart_spi_select_device>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8ce:	e0 ea       	ldi	r30, 0xA0	; 160
     8d0:	f9 e0       	ldi	r31, 0x09	; 9
     8d2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8d4:	85 ff       	sbrs	r24, 5
     8d6:	fd cf       	rjmp	.-6      	; 0x8d2 <st7565r_init+0x346>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8d8:	8f ea       	ldi	r24, 0xAF	; 175
     8da:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     8de:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8e0:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8e2:	81 81       	ldd	r24, Z+1	; 0x01
     8e4:	86 ff       	sbrs	r24, 6
     8e6:	fd cf       	rjmp	.-6      	; 0x8e2 <st7565r_init+0x356>
     8e8:	e0 ea       	ldi	r30, 0xA0	; 160
     8ea:	f9 e0       	ldi	r31, 0x09	; 9
     8ec:	80 e4       	ldi	r24, 0x40	; 64
     8ee:	81 83       	std	Z+1, r24	; 0x01
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     8f0:	80 81       	ld	r24, Z
     8f2:	be 01       	movw	r22, r28
     8f4:	6f 5f       	subi	r22, 0xFF	; 255
     8f6:	7f 4f       	sbci	r23, 0xFF	; 255
     8f8:	80 ea       	ldi	r24, 0xA0	; 160
     8fa:	99 e0       	ldi	r25, 0x09	; 9
     8fc:	c5 d2       	rcall	.+1418   	; 0xe88 <usart_spi_deselect_device>
     8fe:	0f 90       	pop	r0
     900:	df 91       	pop	r29
     902:	cf 91       	pop	r28
     904:	1f 91       	pop	r17
     906:	0f 91       	pop	r16
     908:	ff 90       	pop	r15
     90a:	ef 90       	pop	r14
     90c:	df 90       	pop	r13
     90e:	cf 90       	pop	r12
     910:	bf 90       	pop	r11
     912:	08 95       	ret

00000914 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     914:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     916:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     918:	e8 2f       	mov	r30, r24
     91a:	f0 e0       	ldi	r31, 0x00	; 0
     91c:	e0 59       	subi	r30, 0x90	; 144
     91e:	ff 4f       	sbci	r31, 0xFF	; 255
     920:	60 95       	com	r22
     922:	80 81       	ld	r24, Z
     924:	68 23       	and	r22, r24
     926:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     928:	9f bf       	out	0x3f, r25	; 63
     92a:	08 95       	ret

0000092c <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     92c:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     92e:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     930:	e8 2f       	mov	r30, r24
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	e0 59       	subi	r30, 0x90	; 144
     936:	ff 4f       	sbci	r31, 0xFF	; 255
     938:	80 81       	ld	r24, Z
     93a:	68 2b       	or	r22, r24
     93c:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     93e:	9f bf       	out	0x3f, r25	; 63
     940:	08 95       	ret

00000942 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     942:	ff 92       	push	r15
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	1f 92       	push	r1
     94e:	cd b7       	in	r28, 0x3d	; 61
     950:	de b7       	in	r29, 0x3e	; 62
     952:	08 2f       	mov	r16, r24
     954:	f6 2e       	mov	r15, r22
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     956:	14 2f       	mov	r17, r20
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     958:	1a d1       	rcall	.+564    	; 0xb8e <gfx_mono_framebuffer_put_byte>
     95a:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     95c:	00 6b       	ori	r16, 0xB0	; 176
     95e:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     960:	89 83       	std	Y+1, r24	; 0x01
     962:	be 01       	movw	r22, r28
     964:	6f 5f       	subi	r22, 0xFF	; 255
     966:	7f 4f       	sbci	r23, 0xFF	; 255
     968:	80 ea       	ldi	r24, 0xA0	; 160
     96a:	99 e0       	ldi	r25, 0x09	; 9
     96c:	77 d2       	rcall	.+1262   	; 0xe5c <usart_spi_select_device>
     96e:	81 e0       	ldi	r24, 0x01	; 1
     970:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     974:	e0 ea       	ldi	r30, 0xA0	; 160
     976:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     978:	91 81       	ldd	r25, Z+1	; 0x01
     97a:	95 ff       	sbrs	r25, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     97c:	fd cf       	rjmp	.-6      	; 0x978 <gfx_mono_st7565r_put_byte+0x36>
     97e:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     982:	e0 ea       	ldi	r30, 0xA0	; 160
     984:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     986:	81 81       	ldd	r24, Z+1	; 0x01
     988:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     98a:	fd cf       	rjmp	.-6      	; 0x986 <gfx_mono_st7565r_put_byte+0x44>
     98c:	e0 ea       	ldi	r30, 0xA0	; 160
     98e:	f9 e0       	ldi	r31, 0x09	; 9
     990:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     992:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     994:	80 81       	ld	r24, Z
     996:	be 01       	movw	r22, r28
     998:	6f 5f       	subi	r22, 0xFF	; 255
     99a:	7f 4f       	sbci	r23, 0xFF	; 255
     99c:	80 ea       	ldi	r24, 0xA0	; 160
     99e:	99 e0       	ldi	r25, 0x09	; 9
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     9a0:	73 d2       	rcall	.+1254   	; 0xe88 <usart_spi_deselect_device>
     9a2:	0f 2d       	mov	r16, r15
     9a4:	0f 77       	andi	r16, 0x7F	; 127
     9a6:	02 95       	swap	r16
     9a8:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9aa:	00 61       	ori	r16, 0x10	; 16
     9ac:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9ae:	89 83       	std	Y+1, r24	; 0x01
     9b0:	be 01       	movw	r22, r28
     9b2:	6f 5f       	subi	r22, 0xFF	; 255
     9b4:	7f 4f       	sbci	r23, 0xFF	; 255
     9b6:	80 ea       	ldi	r24, 0xA0	; 160
     9b8:	99 e0       	ldi	r25, 0x09	; 9
     9ba:	50 d2       	rcall	.+1184   	; 0xe5c <usart_spi_select_device>
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9c2:	e0 ea       	ldi	r30, 0xA0	; 160
     9c4:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9c6:	81 81       	ldd	r24, Z+1	; 0x01
     9c8:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9ca:	fd cf       	rjmp	.-6      	; 0x9c6 <gfx_mono_st7565r_put_byte+0x84>
     9cc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
     9d6:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0x92>
     9da:	e0 ea       	ldi	r30, 0xA0	; 160
     9dc:	f9 e0       	ldi	r31, 0x09	; 9
     9de:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9e0:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9e2:	80 81       	ld	r24, Z
     9e4:	be 01       	movw	r22, r28
     9e6:	6f 5f       	subi	r22, 0xFF	; 255
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	80 ea       	ldi	r24, 0xA0	; 160
     9ec:	99 e0       	ldi	r25, 0x09	; 9
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     9ee:	4c d2       	rcall	.+1176   	; 0xe88 <usart_spi_deselect_device>
     9f0:	0f 2d       	mov	r16, r15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9f2:	0f 70       	andi	r16, 0x0F	; 15
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9f4:	8b e2       	ldi	r24, 0x2B	; 43
     9f6:	89 83       	std	Y+1, r24	; 0x01
     9f8:	be 01       	movw	r22, r28
     9fa:	6f 5f       	subi	r22, 0xFF	; 255
     9fc:	7f 4f       	sbci	r23, 0xFF	; 255
     9fe:	80 ea       	ldi	r24, 0xA0	; 160
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	2c d2       	rcall	.+1112   	; 0xe5c <usart_spi_select_device>
     a04:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a06:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     a0a:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a0c:	f9 e0       	ldi	r31, 0x09	; 9
     a0e:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a10:	85 ff       	sbrs	r24, 5
     a12:	fd cf       	rjmp	.-6      	; 0xa0e <gfx_mono_st7565r_put_byte+0xcc>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a14:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     a18:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a1a:	f9 e0       	ldi	r31, 0x09	; 9
     a1c:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a1e:	86 ff       	sbrs	r24, 6
     a20:	fd cf       	rjmp	.-6      	; 0xa1c <gfx_mono_st7565r_put_byte+0xda>
     a22:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a24:	f9 e0       	ldi	r31, 0x09	; 9
     a26:	80 e4       	ldi	r24, 0x40	; 64
     a28:	81 83       	std	Z+1, r24	; 0x01
     a2a:	80 81       	ld	r24, Z
     a2c:	be 01       	movw	r22, r28
     a2e:	6f 5f       	subi	r22, 0xFF	; 255
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a30:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a32:	80 ea       	ldi	r24, 0xA0	; 160
     a34:	99 e0       	ldi	r25, 0x09	; 9
     a36:	28 d2       	rcall	.+1104   	; 0xe88 <usart_spi_deselect_device>
     a38:	8b e2       	ldi	r24, 0x2B	; 43
     a3a:	89 83       	std	Y+1, r24	; 0x01
     a3c:	be 01       	movw	r22, r28
     a3e:	6f 5f       	subi	r22, 0xFF	; 255
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     a40:	7f 4f       	sbci	r23, 0xFF	; 255
     a42:	80 ea       	ldi	r24, 0xA0	; 160
     a44:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a46:	0a d2       	rcall	.+1044   	; 0xe5c <usart_spi_select_device>
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a4e:	e0 ea       	ldi	r30, 0xA0	; 160
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a50:	f9 e0       	ldi	r31, 0x09	; 9
     a52:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a54:	85 ff       	sbrs	r24, 5
     a56:	fd cf       	rjmp	.-6      	; 0xa52 <gfx_mono_st7565r_put_byte+0x110>
     a58:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a5c:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5e:	f9 e0       	ldi	r31, 0x09	; 9
     a60:	81 81       	ldd	r24, Z+1	; 0x01
     a62:	86 ff       	sbrs	r24, 6
     a64:	fd cf       	rjmp	.-6      	; 0xa60 <gfx_mono_st7565r_put_byte+0x11e>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     a66:	e0 ea       	ldi	r30, 0xA0	; 160
     a68:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a6a:	80 e4       	ldi	r24, 0x40	; 64
     a6c:	81 83       	std	Z+1, r24	; 0x01
     a6e:	80 81       	ld	r24, Z
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     a76:	be 01       	movw	r22, r28

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a78:	6f 5f       	subi	r22, 0xFF	; 255
     a7a:	7f 4f       	sbci	r23, 0xFF	; 255
     a7c:	80 ea       	ldi	r24, 0xA0	; 160
     a7e:	99 e0       	ldi	r25, 0x09	; 9
     a80:	03 d2       	rcall	.+1030   	; 0xe88 <usart_spi_deselect_device>
     a82:	0f 90       	pop	r0
     a84:	df 91       	pop	r29
     a86:	cf 91       	pop	r28
     a88:	1f 91       	pop	r17
     a8a:	0f 91       	pop	r16
     a8c:	ff 90       	pop	r15
     a8e:	08 95       	ret

00000a90 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	1f 92       	push	r1
     a9a:	cd b7       	in	r28, 0x3d	; 61
     a9c:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a9e:	8c e5       	ldi	r24, 0x5C	; 92
     aa0:	90 e2       	ldi	r25, 0x20	; 32
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     aa2:	70 d0       	rcall	.+224    	; 0xb84 <gfx_mono_set_framebuffer>
     aa4:	73 dd       	rcall	.-1306   	; 0x58c <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     aa6:	8b e2       	ldi	r24, 0x2B	; 43
     aa8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     aaa:	be 01       	movw	r22, r28
     aac:	6f 5f       	subi	r22, 0xFF	; 255
     aae:	7f 4f       	sbci	r23, 0xFF	; 255
     ab0:	80 ea       	ldi	r24, 0xA0	; 160
     ab2:	99 e0       	ldi	r25, 0x09	; 9
     ab4:	d3 d1       	rcall	.+934    	; 0xe5c <usart_spi_select_device>
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     abc:	e0 ea       	ldi	r30, 0xA0	; 160
     abe:	f9 e0       	ldi	r31, 0x09	; 9
     ac0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     ac2:	85 ff       	sbrs	r24, 5
     ac4:	fd cf       	rjmp	.-6      	; 0xac0 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     ac6:	80 e4       	ldi	r24, 0x40	; 64
     ac8:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     acc:	e0 ea       	ldi	r30, 0xA0	; 160
     ace:	f9 e0       	ldi	r31, 0x09	; 9
     ad0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     ad2:	86 ff       	sbrs	r24, 6
     ad4:	fd cf       	rjmp	.-6      	; 0xad0 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     ad6:	e0 ea       	ldi	r30, 0xA0	; 160
     ad8:	f9 e0       	ldi	r31, 0x09	; 9
     ada:	80 e4       	ldi	r24, 0x40	; 64
     adc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     ade:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     ae0:	be 01       	movw	r22, r28
     ae2:	6f 5f       	subi	r22, 0xFF	; 255
     ae4:	7f 4f       	sbci	r23, 0xFF	; 255
     ae6:	80 ea       	ldi	r24, 0xA0	; 160
     ae8:	99 e0       	ldi	r25, 0x09	; 9
     aea:	ce d1       	rcall	.+924    	; 0xe88 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     aec:	00 e0       	ldi	r16, 0x00	; 0
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     aee:	0a c0       	rjmp	.+20     	; 0xb04 <gfx_mono_st7565r_init+0x74>
     af0:	40 e0       	ldi	r20, 0x00	; 0
     af2:	61 2f       	mov	r22, r17
     af4:	80 2f       	mov	r24, r16
     af6:	25 df       	rcall	.-438    	; 0x942 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     af8:	1f 5f       	subi	r17, 0xFF	; 255
     afa:	10 38       	cpi	r17, 0x80	; 128
     afc:	c9 f7       	brne	.-14     	; 0xaf0 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     afe:	0f 5f       	subi	r16, 0xFF	; 255
     b00:	04 30       	cpi	r16, 0x04	; 4
     b02:	11 f0       	breq	.+4      	; 0xb08 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     b04:	10 e0       	ldi	r17, 0x00	; 0
     b06:	f4 cf       	rjmp	.-24     	; 0xaf0 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     b08:	0f 90       	pop	r0
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	1f 91       	pop	r17
     b10:	0f 91       	pop	r16
     b12:	08 95       	ret

00000b14 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     b1e:	88 23       	and	r24, r24
     b20:	4c f1       	brlt	.+82     	; 0xb74 <gfx_mono_st7565r_draw_pixel+0x60>
     b22:	60 32       	cpi	r22, 0x20	; 32
     b24:	38 f5       	brcc	.+78     	; 0xb74 <gfx_mono_st7565r_draw_pixel+0x60>
     b26:	d4 2f       	mov	r29, r20
     b28:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     b2a:	f6 2e       	mov	r15, r22
     b2c:	f6 94       	lsr	r15
     b2e:	f6 94       	lsr	r15
     b30:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	88 e0       	ldi	r24, 0x08	; 8
     b36:	f8 9e       	mul	r15, r24
     b38:	60 19       	sub	r22, r0
     b3a:	71 09       	sbc	r23, r1
     b3c:	11 24       	eor	r1, r1
     b3e:	81 e0       	ldi	r24, 0x01	; 1
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	8c 01       	movw	r16, r24
     b44:	02 c0       	rjmp	.+4      	; 0xb4a <gfx_mono_st7565r_draw_pixel+0x36>
     b46:	00 0f       	add	r16, r16
     b48:	11 1f       	adc	r17, r17
     b4a:	6a 95       	dec	r22
     b4c:	e2 f7       	brpl	.-8      	; 0xb46 <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b4e:	6c 2f       	mov	r22, r28
     b50:	8f 2d       	mov	r24, r15
     b52:	2b d0       	rcall	.+86     	; 0xbaa <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     b54:	d1 30       	cpi	r29, 0x01	; 1
     b56:	21 f0       	breq	.+8      	; 0xb60 <gfx_mono_st7565r_draw_pixel+0x4c>
     b58:	28 f0       	brcs	.+10     	; 0xb64 <gfx_mono_st7565r_draw_pixel+0x50>
     b5a:	d2 30       	cpi	r29, 0x02	; 2
     b5c:	31 f0       	breq	.+12     	; 0xb6a <gfx_mono_st7565r_draw_pixel+0x56>
     b5e:	06 c0       	rjmp	.+12     	; 0xb6c <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     b60:	80 2b       	or	r24, r16
		break;
     b62:	04 c0       	rjmp	.+8      	; 0xb6c <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     b64:	00 95       	com	r16
     b66:	80 23       	and	r24, r16
		break;
     b68:	01 c0       	rjmp	.+2      	; 0xb6c <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     b6a:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     b6c:	48 2f       	mov	r20, r24
     b6e:	6c 2f       	mov	r22, r28
     b70:	8f 2d       	mov	r24, r15
     b72:	e7 de       	rcall	.-562    	; 0x942 <gfx_mono_st7565r_put_byte>
}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	08 95       	ret

00000b80 <gfx_mono_st7565r_get_byte>:
 * \code
	data = gfx_mono_st7565r_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
     b80:	14 c0       	rjmp	.+40     	; 0xbaa <gfx_mono_framebuffer_get_byte>
     b82:	08 95       	ret

00000b84 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     b84:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <fbpointer>
     b88:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <fbpointer+0x1>
     b8c:	08 95       	ret

00000b8e <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     b8e:	20 91 5c 22 	lds	r18, 0x225C	; 0x80225c <fbpointer>
     b92:	30 91 5d 22 	lds	r19, 0x225D	; 0x80225d <fbpointer+0x1>
     b96:	90 e8       	ldi	r25, 0x80	; 128
     b98:	89 9f       	mul	r24, r25
     b9a:	20 0d       	add	r18, r0
     b9c:	31 1d       	adc	r19, r1
     b9e:	11 24       	eor	r1, r1
     ba0:	f9 01       	movw	r30, r18
     ba2:	e6 0f       	add	r30, r22
     ba4:	f1 1d       	adc	r31, r1
     ba6:	40 83       	st	Z, r20
     ba8:	08 95       	ret

00000baa <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     baa:	20 91 5c 22 	lds	r18, 0x225C	; 0x80225c <fbpointer>
     bae:	30 91 5d 22 	lds	r19, 0x225D	; 0x80225d <fbpointer+0x1>
     bb2:	90 e8       	ldi	r25, 0x80	; 128
     bb4:	89 9f       	mul	r24, r25
     bb6:	20 0d       	add	r18, r0
     bb8:	31 1d       	adc	r19, r1
     bba:	11 24       	eor	r1, r1
     bbc:	f9 01       	movw	r30, r18
     bbe:	e6 0f       	add	r30, r22
     bc0:	f1 1d       	adc	r31, r1
}
     bc2:	80 81       	ld	r24, Z
     bc4:	08 95       	ret

00000bc6 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	e4 2f       	mov	r30, r20
     bd2:	f0 e0       	ldi	r31, 0x00	; 0
     bd4:	e8 0f       	add	r30, r24
     bd6:	f1 1d       	adc	r31, r1
     bd8:	e1 38       	cpi	r30, 0x81	; 129
     bda:	f1 05       	cpc	r31, r1
     bdc:	1c f0       	brlt	.+6      	; 0xbe4 <gfx_mono_generic_draw_horizontal_line+0x1e>
     bde:	c0 e8       	ldi	r28, 0x80	; 128
     be0:	4c 2f       	mov	r20, r28
     be2:	48 1b       	sub	r20, r24
     be4:	44 23       	and	r20, r20
     be6:	09 f4       	brne	.+2      	; 0xbea <gfx_mono_generic_draw_horizontal_line+0x24>
     be8:	4a c0       	rjmp	.+148    	; 0xc7e <gfx_mono_generic_draw_horizontal_line+0xb8>
     bea:	d6 2f       	mov	r29, r22
     bec:	d6 95       	lsr	r29
     bee:	d6 95       	lsr	r29
     bf0:	d6 95       	lsr	r29
     bf2:	70 e0       	ldi	r23, 0x00	; 0
     bf4:	98 e0       	ldi	r25, 0x08	; 8
     bf6:	d9 9f       	mul	r29, r25
     bf8:	60 19       	sub	r22, r0
     bfa:	71 09       	sbc	r23, r1
     bfc:	11 24       	eor	r1, r1
     bfe:	e1 e0       	ldi	r30, 0x01	; 1
     c00:	f0 e0       	ldi	r31, 0x00	; 0
     c02:	df 01       	movw	r26, r30
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <gfx_mono_generic_draw_horizontal_line+0x44>
     c06:	aa 0f       	add	r26, r26
     c08:	bb 1f       	adc	r27, r27
     c0a:	6a 95       	dec	r22
     c0c:	e2 f7       	brpl	.-8      	; 0xc06 <gfx_mono_generic_draw_horizontal_line+0x40>
     c0e:	fa 2e       	mov	r15, r26
     c10:	21 30       	cpi	r18, 0x01	; 1
     c12:	21 f0       	breq	.+8      	; 0xc1c <gfx_mono_generic_draw_horizontal_line+0x56>
     c14:	98 f0       	brcs	.+38     	; 0xc3c <gfx_mono_generic_draw_horizontal_line+0x76>
     c16:	22 30       	cpi	r18, 0x02	; 2
     c18:	19 f1       	breq	.+70     	; 0xc60 <gfx_mono_generic_draw_horizontal_line+0x9a>
     c1a:	31 c0       	rjmp	.+98     	; 0xc7e <gfx_mono_generic_draw_horizontal_line+0xb8>
     c1c:	c4 2f       	mov	r28, r20
     c1e:	1f ef       	ldi	r17, 0xFF	; 255
     c20:	18 0f       	add	r17, r24
     c22:	01 2f       	mov	r16, r17
     c24:	0c 0f       	add	r16, r28
     c26:	60 2f       	mov	r22, r16
     c28:	8d 2f       	mov	r24, r29
     c2a:	aa df       	rcall	.-172    	; 0xb80 <gfx_mono_st7565r_get_byte>
     c2c:	4f 2d       	mov	r20, r15
     c2e:	48 2b       	or	r20, r24
     c30:	60 2f       	mov	r22, r16
     c32:	8d 2f       	mov	r24, r29
     c34:	86 de       	rcall	.-756    	; 0x942 <gfx_mono_st7565r_put_byte>
     c36:	c1 50       	subi	r28, 0x01	; 1
     c38:	a1 f7       	brne	.-24     	; 0xc22 <gfx_mono_generic_draw_horizontal_line+0x5c>
     c3a:	21 c0       	rjmp	.+66     	; 0xc7e <gfx_mono_generic_draw_horizontal_line+0xb8>
     c3c:	c4 2f       	mov	r28, r20
     c3e:	1f ef       	ldi	r17, 0xFF	; 255
     c40:	18 0f       	add	r17, r24
     c42:	fa 2e       	mov	r15, r26
     c44:	f0 94       	com	r15
     c46:	01 2f       	mov	r16, r17
     c48:	0c 0f       	add	r16, r28
     c4a:	60 2f       	mov	r22, r16
     c4c:	8d 2f       	mov	r24, r29
     c4e:	98 df       	rcall	.-208    	; 0xb80 <gfx_mono_st7565r_get_byte>
     c50:	4f 2d       	mov	r20, r15
     c52:	48 23       	and	r20, r24
     c54:	60 2f       	mov	r22, r16
     c56:	8d 2f       	mov	r24, r29
     c58:	74 de       	rcall	.-792    	; 0x942 <gfx_mono_st7565r_put_byte>
     c5a:	c1 50       	subi	r28, 0x01	; 1
     c5c:	a1 f7       	brne	.-24     	; 0xc46 <gfx_mono_generic_draw_horizontal_line+0x80>
     c5e:	0f c0       	rjmp	.+30     	; 0xc7e <gfx_mono_generic_draw_horizontal_line+0xb8>
     c60:	c4 2f       	mov	r28, r20
     c62:	1f ef       	ldi	r17, 0xFF	; 255
     c64:	18 0f       	add	r17, r24
     c66:	01 2f       	mov	r16, r17
     c68:	0c 0f       	add	r16, r28
     c6a:	60 2f       	mov	r22, r16
     c6c:	8d 2f       	mov	r24, r29
     c6e:	88 df       	rcall	.-240    	; 0xb80 <gfx_mono_st7565r_get_byte>
     c70:	4f 2d       	mov	r20, r15
     c72:	48 27       	eor	r20, r24
     c74:	60 2f       	mov	r22, r16
     c76:	8d 2f       	mov	r24, r29
     c78:	64 de       	rcall	.-824    	; 0x942 <gfx_mono_st7565r_put_byte>
     c7a:	c1 50       	subi	r28, 0x01	; 1
     c7c:	a1 f7       	brne	.-24     	; 0xc66 <gfx_mono_generic_draw_horizontal_line+0xa0>
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	1f 91       	pop	r17
     c84:	0f 91       	pop	r16
     c86:	ff 90       	pop	r15
     c88:	08 95       	ret

00000c8a <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
	if (height == 0) {
     c94:	22 23       	and	r18, r18
     c96:	69 f0       	breq	.+26     	; 0xcb2 <gfx_mono_generic_draw_filled_rect+0x28>
     c98:	f4 2e       	mov	r15, r20
     c9a:	18 2f       	mov	r17, r24
     c9c:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c9e:	df ef       	ldi	r29, 0xFF	; 255
     ca0:	d6 0f       	add	r29, r22
     ca2:	6d 2f       	mov	r22, r29
     ca4:	6c 0f       	add	r22, r28
     ca6:	20 2f       	mov	r18, r16
     ca8:	4f 2d       	mov	r20, r15
     caa:	81 2f       	mov	r24, r17
     cac:	8c df       	rcall	.-232    	; 0xbc6 <gfx_mono_generic_draw_horizontal_line>
     cae:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     cb0:	c1 f7       	brne	.-16     	; 0xca2 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     cb2:	df 91       	pop	r29
     cb4:	cf 91       	pop	r28
     cb6:	1f 91       	pop	r17
     cb8:	0f 91       	pop	r16
     cba:	ff 90       	pop	r15
     cbc:	08 95       	ret

00000cbe <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     cbe:	af 92       	push	r10
     cc0:	bf 92       	push	r11
     cc2:	cf 92       	push	r12
     cc4:	df 92       	push	r13
     cc6:	ef 92       	push	r14
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	c8 2f       	mov	r28, r24
     cd4:	e6 2e       	mov	r14, r22
     cd6:	b4 2e       	mov	r11, r20
     cd8:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     cda:	00 e0       	ldi	r16, 0x00	; 0
     cdc:	f9 01       	movw	r30, r18
     cde:	24 81       	ldd	r18, Z+4	; 0x04
     ce0:	43 81       	ldd	r20, Z+3	; 0x03
     ce2:	6b 2d       	mov	r22, r11
     ce4:	8e 2d       	mov	r24, r14
     ce6:	d1 df       	rcall	.-94     	; 0xc8a <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     ce8:	f6 01       	movw	r30, r12
     cea:	80 81       	ld	r24, Z
     cec:	81 11       	cpse	r24, r1
     cee:	39 c0       	rjmp	.+114    	; 0xd62 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     cf0:	83 81       	ldd	r24, Z+3	; 0x03
     cf2:	28 2f       	mov	r18, r24
     cf4:	26 95       	lsr	r18
     cf6:	26 95       	lsr	r18
     cf8:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     cfa:	87 70       	andi	r24, 0x07	; 7
     cfc:	09 f0       	breq	.+2      	; 0xd00 <gfx_mono_draw_char+0x42>
		char_row_size++;
     cfe:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     d00:	f6 01       	movw	r30, r12
     d02:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     d04:	8c 2f       	mov	r24, r28
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	35 81       	ldd	r19, Z+5	; 0x05
     d0a:	83 1b       	sub	r24, r19
     d0c:	91 09       	sbc	r25, r1
     d0e:	2a 9d       	mul	r18, r10
     d10:	90 01       	movw	r18, r0
     d12:	11 24       	eor	r1, r1
     d14:	82 9f       	mul	r24, r18
     d16:	a0 01       	movw	r20, r0
     d18:	83 9f       	mul	r24, r19
     d1a:	50 0d       	add	r21, r0
     d1c:	92 9f       	mul	r25, r18
     d1e:	50 0d       	add	r21, r0
     d20:	11 24       	eor	r1, r1
     d22:	01 81       	ldd	r16, Z+1	; 0x01
     d24:	12 81       	ldd	r17, Z+2	; 0x02
     d26:	04 0f       	add	r16, r20
     d28:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     d2a:	f6 01       	movw	r30, r12
     d2c:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     d2e:	ff 20       	and	r15, r15
     d30:	a1 f0       	breq	.+40     	; 0xd5a <gfx_mono_draw_char+0x9c>
     d32:	d0 e0       	ldi	r29, 0x00	; 0
     d34:	c0 e0       	ldi	r28, 0x00	; 0
     d36:	8e 2d       	mov	r24, r14
     d38:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     d3a:	9c 2f       	mov	r25, r28
     d3c:	97 70       	andi	r25, 0x07	; 7
     d3e:	21 f4       	brne	.+8      	; 0xd48 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     d40:	f8 01       	movw	r30, r16
     d42:	d4 91       	lpm	r29, Z
				glyph_data++;
     d44:	0f 5f       	subi	r16, 0xFF	; 255
     d46:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     d48:	dd 23       	and	r29, r29
     d4a:	1c f4       	brge	.+6      	; 0xd52 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     d4c:	41 e0       	ldi	r20, 0x01	; 1
     d4e:	6b 2d       	mov	r22, r11
     d50:	e1 de       	rcall	.-574    	; 0xb14 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     d52:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     d54:	cf 5f       	subi	r28, 0xFF	; 255
     d56:	fc 12       	cpse	r15, r28
     d58:	ee cf       	rjmp	.-36     	; 0xd36 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     d5a:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     d5c:	aa 94       	dec	r10
	} while (rows_left > 0);
     d5e:	a1 10       	cpse	r10, r1
     d60:	e4 cf       	rjmp	.-56     	; 0xd2a <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	1f 91       	pop	r17
     d68:	0f 91       	pop	r16
     d6a:	ff 90       	pop	r15
     d6c:	ef 90       	pop	r14
     d6e:	df 90       	pop	r13
     d70:	cf 90       	pop	r12
     d72:	bf 90       	pop	r11
     d74:	af 90       	pop	r10
     d76:	08 95       	ret

00000d78 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     d78:	df 92       	push	r13
     d7a:	ef 92       	push	r14
     d7c:	ff 92       	push	r15
     d7e:	0f 93       	push	r16
     d80:	1f 93       	push	r17
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	d6 2e       	mov	r13, r22
     d88:	04 2f       	mov	r16, r20
     d8a:	79 01       	movw	r14, r18
     d8c:	ec 01       	movw	r28, r24
     d8e:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d90:	89 91       	ld	r24, Y+
     d92:	8a 30       	cpi	r24, 0x0A	; 10
     d94:	31 f4       	brne	.+12     	; 0xda2 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d96:	f7 01       	movw	r30, r14
     d98:	84 81       	ldd	r24, Z+4	; 0x04
     d9a:	8f 5f       	subi	r24, 0xFF	; 255
     d9c:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d9e:	1d 2d       	mov	r17, r13
     da0:	09 c0       	rjmp	.+18     	; 0xdb4 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     da2:	8d 30       	cpi	r24, 0x0D	; 13
     da4:	39 f0       	breq	.+14     	; 0xdb4 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     da6:	97 01       	movw	r18, r14
     da8:	40 2f       	mov	r20, r16
     daa:	61 2f       	mov	r22, r17
     dac:	88 df       	rcall	.-240    	; 0xcbe <gfx_mono_draw_char>
			x += font->width;
     dae:	f7 01       	movw	r30, r14
     db0:	83 81       	ldd	r24, Z+3	; 0x03
     db2:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     db4:	88 81       	ld	r24, Y
     db6:	81 11       	cpse	r24, r1
     db8:	eb cf       	rjmp	.-42     	; 0xd90 <gfx_mono_draw_string+0x18>
}
     dba:	df 91       	pop	r29
     dbc:	cf 91       	pop	r28
     dbe:	1f 91       	pop	r17
     dc0:	0f 91       	pop	r16
     dc2:	ff 90       	pop	r15
     dc4:	ef 90       	pop	r14
     dc6:	df 90       	pop	r13
     dc8:	08 95       	ret

00000dca <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     dca:	80 3a       	cpi	r24, 0xA0	; 160
     dcc:	28 e0       	ldi	r18, 0x08	; 8
     dce:	92 07       	cpc	r25, r18
     dd0:	21 f4       	brne	.+8      	; 0xdda <usart_spi_init+0x10>
     dd2:	60 e1       	ldi	r22, 0x10	; 16
     dd4:	83 e0       	ldi	r24, 0x03	; 3
     dd6:	9e cd       	rjmp	.-1220   	; 0x914 <sysclk_enable_module>
     dd8:	08 95       	ret
     dda:	80 3b       	cpi	r24, 0xB0	; 176
     ddc:	28 e0       	ldi	r18, 0x08	; 8
     dde:	92 07       	cpc	r25, r18
     de0:	21 f4       	brne	.+8      	; 0xdea <usart_spi_init+0x20>
     de2:	60 e2       	ldi	r22, 0x20	; 32
     de4:	83 e0       	ldi	r24, 0x03	; 3
     de6:	96 cd       	rjmp	.-1236   	; 0x914 <sysclk_enable_module>
     de8:	08 95       	ret
     dea:	80 3a       	cpi	r24, 0xA0	; 160
     dec:	29 e0       	ldi	r18, 0x09	; 9
     dee:	92 07       	cpc	r25, r18
     df0:	21 f4       	brne	.+8      	; 0xdfa <usart_spi_init+0x30>
     df2:	60 e1       	ldi	r22, 0x10	; 16
     df4:	84 e0       	ldi	r24, 0x04	; 4
     df6:	8e cd       	rjmp	.-1252   	; 0x914 <sysclk_enable_module>
     df8:	08 95       	ret
     dfa:	80 3b       	cpi	r24, 0xB0	; 176
     dfc:	29 e0       	ldi	r18, 0x09	; 9
     dfe:	92 07       	cpc	r25, r18
     e00:	21 f4       	brne	.+8      	; 0xe0a <usart_spi_init+0x40>
     e02:	60 e2       	ldi	r22, 0x20	; 32
     e04:	84 e0       	ldi	r24, 0x04	; 4
     e06:	86 cd       	rjmp	.-1268   	; 0x914 <sysclk_enable_module>
     e08:	08 95       	ret
     e0a:	80 3a       	cpi	r24, 0xA0	; 160
     e0c:	2a e0       	ldi	r18, 0x0A	; 10
     e0e:	92 07       	cpc	r25, r18
     e10:	21 f4       	brne	.+8      	; 0xe1a <usart_spi_init+0x50>
     e12:	60 e1       	ldi	r22, 0x10	; 16
     e14:	85 e0       	ldi	r24, 0x05	; 5
     e16:	7e cd       	rjmp	.-1284   	; 0x914 <sysclk_enable_module>
     e18:	08 95       	ret
     e1a:	80 3a       	cpi	r24, 0xA0	; 160
     e1c:	9b 40       	sbci	r25, 0x0B	; 11
     e1e:	19 f4       	brne	.+6      	; 0xe26 <usart_spi_init+0x5c>
     e20:	60 e1       	ldi	r22, 0x10	; 16
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	77 cd       	rjmp	.-1298   	; 0x914 <sysclk_enable_module>
     e26:	08 95       	ret

00000e28 <usart_spi_setup_device>:
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	00 d0       	rcall	.+0      	; 0xe32 <usart_spi_setup_device+0xa>
     e32:	00 d0       	rcall	.+0      	; 0xe34 <usart_spi_setup_device+0xc>
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	09 83       	std	Y+1, r16	; 0x01
     e3a:	1a 83       	std	Y+2, r17	; 0x02
     e3c:	2b 83       	std	Y+3, r18	; 0x03
     e3e:	3c 83       	std	Y+4, r19	; 0x04
     e40:	4d 83       	std	Y+5, r20	; 0x05
     e42:	1e 82       	std	Y+6, r1	; 0x06
     e44:	be 01       	movw	r22, r28
     e46:	6f 5f       	subi	r22, 0xFF	; 255
     e48:	7f 4f       	sbci	r23, 0xFF	; 255
     e4a:	38 d3       	rcall	.+1648   	; 0x14bc <usart_init_spi>
     e4c:	26 96       	adiw	r28, 0x06	; 6
     e4e:	cd bf       	out	0x3d, r28	; 61
     e50:	de bf       	out	0x3e, r29	; 62
     e52:	df 91       	pop	r29
     e54:	cf 91       	pop	r28
     e56:	1f 91       	pop	r17
     e58:	0f 91       	pop	r16
     e5a:	08 95       	ret

00000e5c <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     e5c:	fb 01       	movw	r30, r22
     e5e:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e60:	e8 2f       	mov	r30, r24
     e62:	e6 95       	lsr	r30
     e64:	e6 95       	lsr	r30
     e66:	e6 95       	lsr	r30
     e68:	40 e2       	ldi	r20, 0x20	; 32
     e6a:	e4 9f       	mul	r30, r20
     e6c:	f0 01       	movw	r30, r0
     e6e:	11 24       	eor	r1, r1
     e70:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e72:	87 70       	andi	r24, 0x07	; 7
     e74:	21 e0       	ldi	r18, 0x01	; 1
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	a9 01       	movw	r20, r18
     e7a:	02 c0       	rjmp	.+4      	; 0xe80 <usart_spi_select_device+0x24>
     e7c:	44 0f       	add	r20, r20
     e7e:	55 1f       	adc	r21, r21
     e80:	8a 95       	dec	r24
     e82:	e2 f7       	brpl	.-8      	; 0xe7c <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e84:	46 83       	std	Z+6, r20	; 0x06
     e86:	08 95       	ret

00000e88 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e88:	fb 01       	movw	r30, r22
     e8a:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e8c:	e8 2f       	mov	r30, r24
     e8e:	e6 95       	lsr	r30
     e90:	e6 95       	lsr	r30
     e92:	e6 95       	lsr	r30
     e94:	40 e2       	ldi	r20, 0x20	; 32
     e96:	e4 9f       	mul	r30, r20
     e98:	f0 01       	movw	r30, r0
     e9a:	11 24       	eor	r1, r1
     e9c:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e9e:	87 70       	andi	r24, 0x07	; 7
     ea0:	21 e0       	ldi	r18, 0x01	; 1
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	a9 01       	movw	r20, r18
     ea6:	02 c0       	rjmp	.+4      	; 0xeac <usart_spi_deselect_device+0x24>
     ea8:	44 0f       	add	r20, r20
     eaa:	55 1f       	adc	r21, r21
     eac:	8a 95       	dec	r24
     eae:	e2 f7       	brpl	.-8      	; 0xea8 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     eb0:	45 83       	std	Z+5, r20	; 0x05
     eb2:	08 95       	ret

00000eb4 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     eb4:	81 15       	cp	r24, r1
     eb6:	22 e0       	ldi	r18, 0x02	; 2
     eb8:	92 07       	cpc	r25, r18
     eba:	61 f4       	brne	.+24     	; 0xed4 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     ebc:	80 91 5f 22 	lds	r24, 0x225F	; 0x80225f <adca_enable_count>
     ec0:	91 e0       	ldi	r25, 0x01	; 1
     ec2:	98 0f       	add	r25, r24
     ec4:	90 93 5f 22 	sts	0x225F, r25	; 0x80225f <adca_enable_count>
     ec8:	81 11       	cpse	r24, r1
     eca:	12 c0       	rjmp	.+36     	; 0xef0 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     ecc:	62 e0       	ldi	r22, 0x02	; 2
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	21 cd       	rjmp	.-1470   	; 0x914 <sysclk_enable_module>
     ed2:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     ed4:	80 34       	cpi	r24, 0x40	; 64
     ed6:	92 40       	sbci	r25, 0x02	; 2
     ed8:	59 f4       	brne	.+22     	; 0xef0 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     eda:	80 91 5e 22 	lds	r24, 0x225E	; 0x80225e <adcb_enable_count>
     ede:	91 e0       	ldi	r25, 0x01	; 1
     ee0:	98 0f       	add	r25, r24
     ee2:	90 93 5e 22 	sts	0x225E, r25	; 0x80225e <adcb_enable_count>
     ee6:	81 11       	cpse	r24, r1
     ee8:	03 c0       	rjmp	.+6      	; 0xef0 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     eea:	62 e0       	ldi	r22, 0x02	; 2
     eec:	82 e0       	ldi	r24, 0x02	; 2
     eee:	12 cd       	rjmp	.-1500   	; 0x914 <sysclk_enable_module>
     ef0:	08 95       	ret

00000ef2 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     ef2:	81 15       	cp	r24, r1
     ef4:	22 e0       	ldi	r18, 0x02	; 2
     ef6:	92 07       	cpc	r25, r18
     ef8:	59 f4       	brne	.+22     	; 0xf10 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     efa:	80 91 5f 22 	lds	r24, 0x225F	; 0x80225f <adca_enable_count>
     efe:	81 50       	subi	r24, 0x01	; 1
     f00:	80 93 5f 22 	sts	0x225F, r24	; 0x80225f <adca_enable_count>
     f04:	81 11       	cpse	r24, r1
     f06:	11 c0       	rjmp	.+34     	; 0xf2a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     f08:	62 e0       	ldi	r22, 0x02	; 2
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	0f cd       	rjmp	.-1506   	; 0x92c <sysclk_disable_module>
     f0e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     f10:	80 34       	cpi	r24, 0x40	; 64
     f12:	92 40       	sbci	r25, 0x02	; 2
     f14:	51 f4       	brne	.+20     	; 0xf2a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     f16:	80 91 5e 22 	lds	r24, 0x225E	; 0x80225e <adcb_enable_count>
     f1a:	81 50       	subi	r24, 0x01	; 1
     f1c:	80 93 5e 22 	sts	0x225E, r24	; 0x80225e <adcb_enable_count>
     f20:	81 11       	cpse	r24, r1
     f22:	03 c0       	rjmp	.+6      	; 0xf2a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     f24:	62 e0       	ldi	r22, 0x02	; 2
     f26:	82 e0       	ldi	r24, 0x02	; 2
     f28:	01 cd       	rjmp	.-1534   	; 0x92c <sysclk_disable_module>
     f2a:	08 95       	ret

00000f2c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     f2c:	1f 93       	push	r17
     f2e:	cf 93       	push	r28
     f30:	df 93       	push	r29
     f32:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     f34:	1f b7       	in	r17, 0x3f	; 63
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     f36:	f8 94       	cli
	adc->CTRLA |= ADC_ENABLE_bm;
     f38:	bd df       	rcall	.-134    	; 0xeb4 <adc_enable_clock>
     f3a:	88 81       	ld	r24, Y
     f3c:	81 60       	ori	r24, 0x01	; 1
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     f3e:	88 83       	st	Y, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     f40:	1f bf       	out	0x3f, r17	; 63
	cpu_irq_disable();
     f42:	9f b7       	in	r25, 0x3f	; 63
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     f44:	f8 94       	cli
     f46:	ec ea       	ldi	r30, 0xAC	; 172
     f48:	f3 e2       	ldi	r31, 0x23	; 35
     f4a:	81 81       	ldd	r24, Z+1	; 0x01
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     f4e:	81 83       	std	Z+1, r24	; 0x01
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     f50:	9f bf       	out	0x3f, r25	; 63
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	1f 91       	pop	r17
     f58:	08 95       	ret

00000f5a <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     f5a:	1f 92       	push	r1
     f5c:	0f 92       	push	r0
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	0f 92       	push	r0
     f62:	11 24       	eor	r1, r1
     f64:	0b b6       	in	r0, 0x3b	; 59
     f66:	0f 92       	push	r0
     f68:	2f 93       	push	r18
     f6a:	3f 93       	push	r19
     f6c:	4f 93       	push	r20
     f6e:	5f 93       	push	r21
     f70:	6f 93       	push	r22
     f72:	7f 93       	push	r23
     f74:	8f 93       	push	r24
     f76:	9f 93       	push	r25
     f78:	af 93       	push	r26
     f7a:	bf 93       	push	r27
     f7c:	ef 93       	push	r30
     f7e:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     f80:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     f84:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     f88:	e0 91 b4 23 	lds	r30, 0x23B4	; 0x8023b4 <adca_callback>
     f8c:	f0 91 b5 23 	lds	r31, 0x23B5	; 0x8023b5 <adca_callback+0x1>
     f90:	61 e0       	ldi	r22, 0x01	; 1
     f92:	80 e0       	ldi	r24, 0x00	; 0
     f94:	92 e0       	ldi	r25, 0x02	; 2
     f96:	19 95       	eicall
}
     f98:	ff 91       	pop	r31
     f9a:	ef 91       	pop	r30
     f9c:	bf 91       	pop	r27
     f9e:	af 91       	pop	r26
     fa0:	9f 91       	pop	r25
     fa2:	8f 91       	pop	r24
     fa4:	7f 91       	pop	r23
     fa6:	6f 91       	pop	r22
     fa8:	5f 91       	pop	r21
     faa:	4f 91       	pop	r20
     fac:	3f 91       	pop	r19
     fae:	2f 91       	pop	r18
     fb0:	0f 90       	pop	r0
     fb2:	0b be       	out	0x3b, r0	; 59
     fb4:	0f 90       	pop	r0
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	0f 90       	pop	r0
     fba:	1f 90       	pop	r1
     fbc:	18 95       	reti

00000fbe <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     fbe:	1f 92       	push	r1
     fc0:	0f 92       	push	r0
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	0f 92       	push	r0
     fc6:	11 24       	eor	r1, r1
     fc8:	0b b6       	in	r0, 0x3b	; 59
     fca:	0f 92       	push	r0
     fcc:	2f 93       	push	r18
     fce:	3f 93       	push	r19
     fd0:	4f 93       	push	r20
     fd2:	5f 93       	push	r21
     fd4:	6f 93       	push	r22
     fd6:	7f 93       	push	r23
     fd8:	8f 93       	push	r24
     fda:	9f 93       	push	r25
     fdc:	af 93       	push	r26
     fde:	bf 93       	push	r27
     fe0:	ef 93       	push	r30
     fe2:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     fe4:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     fe8:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     fec:	e0 91 b4 23 	lds	r30, 0x23B4	; 0x8023b4 <adca_callback>
     ff0:	f0 91 b5 23 	lds	r31, 0x23B5	; 0x8023b5 <adca_callback+0x1>
     ff4:	62 e0       	ldi	r22, 0x02	; 2
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	92 e0       	ldi	r25, 0x02	; 2
     ffa:	19 95       	eicall
}
     ffc:	ff 91       	pop	r31
     ffe:	ef 91       	pop	r30
    1000:	bf 91       	pop	r27
    1002:	af 91       	pop	r26
    1004:	9f 91       	pop	r25
    1006:	8f 91       	pop	r24
    1008:	7f 91       	pop	r23
    100a:	6f 91       	pop	r22
    100c:	5f 91       	pop	r21
    100e:	4f 91       	pop	r20
    1010:	3f 91       	pop	r19
    1012:	2f 91       	pop	r18
    1014:	0f 90       	pop	r0
    1016:	0b be       	out	0x3b, r0	; 59
    1018:	0f 90       	pop	r0
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	0f 90       	pop	r0
    101e:	1f 90       	pop	r1
    1020:	18 95       	reti

00001022 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    1022:	1f 92       	push	r1
    1024:	0f 92       	push	r0
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	0f 92       	push	r0
    102a:	11 24       	eor	r1, r1
    102c:	0b b6       	in	r0, 0x3b	; 59
    102e:	0f 92       	push	r0
    1030:	2f 93       	push	r18
    1032:	3f 93       	push	r19
    1034:	4f 93       	push	r20
    1036:	5f 93       	push	r21
    1038:	6f 93       	push	r22
    103a:	7f 93       	push	r23
    103c:	8f 93       	push	r24
    103e:	9f 93       	push	r25
    1040:	af 93       	push	r26
    1042:	bf 93       	push	r27
    1044:	ef 93       	push	r30
    1046:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1048:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
    104c:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
    1050:	e0 91 b4 23 	lds	r30, 0x23B4	; 0x8023b4 <adca_callback>
    1054:	f0 91 b5 23 	lds	r31, 0x23B5	; 0x8023b5 <adca_callback+0x1>
    1058:	64 e0       	ldi	r22, 0x04	; 4
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	92 e0       	ldi	r25, 0x02	; 2
    105e:	19 95       	eicall
}
    1060:	ff 91       	pop	r31
    1062:	ef 91       	pop	r30
    1064:	bf 91       	pop	r27
    1066:	af 91       	pop	r26
    1068:	9f 91       	pop	r25
    106a:	8f 91       	pop	r24
    106c:	7f 91       	pop	r23
    106e:	6f 91       	pop	r22
    1070:	5f 91       	pop	r21
    1072:	4f 91       	pop	r20
    1074:	3f 91       	pop	r19
    1076:	2f 91       	pop	r18
    1078:	0f 90       	pop	r0
    107a:	0b be       	out	0x3b, r0	; 59
    107c:	0f 90       	pop	r0
    107e:	0f be       	out	0x3f, r0	; 63
    1080:	0f 90       	pop	r0
    1082:	1f 90       	pop	r1
    1084:	18 95       	reti

00001086 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1086:	1f 92       	push	r1
    1088:	0f 92       	push	r0
    108a:	0f b6       	in	r0, 0x3f	; 63
    108c:	0f 92       	push	r0
    108e:	11 24       	eor	r1, r1
    1090:	0b b6       	in	r0, 0x3b	; 59
    1092:	0f 92       	push	r0
    1094:	2f 93       	push	r18
    1096:	3f 93       	push	r19
    1098:	4f 93       	push	r20
    109a:	5f 93       	push	r21
    109c:	6f 93       	push	r22
    109e:	7f 93       	push	r23
    10a0:	8f 93       	push	r24
    10a2:	9f 93       	push	r25
    10a4:	af 93       	push	r26
    10a6:	bf 93       	push	r27
    10a8:	ef 93       	push	r30
    10aa:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    10ac:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    10b0:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    10b4:	e0 91 b4 23 	lds	r30, 0x23B4	; 0x8023b4 <adca_callback>
    10b8:	f0 91 b5 23 	lds	r31, 0x23B5	; 0x8023b5 <adca_callback+0x1>
    10bc:	68 e0       	ldi	r22, 0x08	; 8
    10be:	80 e0       	ldi	r24, 0x00	; 0
    10c0:	92 e0       	ldi	r25, 0x02	; 2
    10c2:	19 95       	eicall
}
    10c4:	ff 91       	pop	r31
    10c6:	ef 91       	pop	r30
    10c8:	bf 91       	pop	r27
    10ca:	af 91       	pop	r26
    10cc:	9f 91       	pop	r25
    10ce:	8f 91       	pop	r24
    10d0:	7f 91       	pop	r23
    10d2:	6f 91       	pop	r22
    10d4:	5f 91       	pop	r21
    10d6:	4f 91       	pop	r20
    10d8:	3f 91       	pop	r19
    10da:	2f 91       	pop	r18
    10dc:	0f 90       	pop	r0
    10de:	0b be       	out	0x3b, r0	; 59
    10e0:	0f 90       	pop	r0
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	0f 90       	pop	r0
    10e6:	1f 90       	pop	r1
    10e8:	18 95       	reti

000010ea <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    10ea:	1f 92       	push	r1
    10ec:	0f 92       	push	r0
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	0f 92       	push	r0
    10f2:	11 24       	eor	r1, r1
    10f4:	0b b6       	in	r0, 0x3b	; 59
    10f6:	0f 92       	push	r0
    10f8:	2f 93       	push	r18
    10fa:	3f 93       	push	r19
    10fc:	4f 93       	push	r20
    10fe:	5f 93       	push	r21
    1100:	6f 93       	push	r22
    1102:	7f 93       	push	r23
    1104:	8f 93       	push	r24
    1106:	9f 93       	push	r25
    1108:	af 93       	push	r26
    110a:	bf 93       	push	r27
    110c:	ef 93       	push	r30
    110e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1110:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    1114:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1118:	e0 91 b2 23 	lds	r30, 0x23B2	; 0x8023b2 <adcb_callback>
    111c:	f0 91 b3 23 	lds	r31, 0x23B3	; 0x8023b3 <adcb_callback+0x1>
    1120:	61 e0       	ldi	r22, 0x01	; 1
    1122:	80 e4       	ldi	r24, 0x40	; 64
    1124:	92 e0       	ldi	r25, 0x02	; 2
    1126:	19 95       	eicall
}
    1128:	ff 91       	pop	r31
    112a:	ef 91       	pop	r30
    112c:	bf 91       	pop	r27
    112e:	af 91       	pop	r26
    1130:	9f 91       	pop	r25
    1132:	8f 91       	pop	r24
    1134:	7f 91       	pop	r23
    1136:	6f 91       	pop	r22
    1138:	5f 91       	pop	r21
    113a:	4f 91       	pop	r20
    113c:	3f 91       	pop	r19
    113e:	2f 91       	pop	r18
    1140:	0f 90       	pop	r0
    1142:	0b be       	out	0x3b, r0	; 59
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	0f 90       	pop	r0
    114a:	1f 90       	pop	r1
    114c:	18 95       	reti

0000114e <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    114e:	1f 92       	push	r1
    1150:	0f 92       	push	r0
    1152:	0f b6       	in	r0, 0x3f	; 63
    1154:	0f 92       	push	r0
    1156:	11 24       	eor	r1, r1
    1158:	0b b6       	in	r0, 0x3b	; 59
    115a:	0f 92       	push	r0
    115c:	2f 93       	push	r18
    115e:	3f 93       	push	r19
    1160:	4f 93       	push	r20
    1162:	5f 93       	push	r21
    1164:	6f 93       	push	r22
    1166:	7f 93       	push	r23
    1168:	8f 93       	push	r24
    116a:	9f 93       	push	r25
    116c:	af 93       	push	r26
    116e:	bf 93       	push	r27
    1170:	ef 93       	push	r30
    1172:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1174:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    1178:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    117c:	e0 91 b2 23 	lds	r30, 0x23B2	; 0x8023b2 <adcb_callback>
    1180:	f0 91 b3 23 	lds	r31, 0x23B3	; 0x8023b3 <adcb_callback+0x1>
    1184:	62 e0       	ldi	r22, 0x02	; 2
    1186:	80 e4       	ldi	r24, 0x40	; 64
    1188:	92 e0       	ldi	r25, 0x02	; 2
    118a:	19 95       	eicall
}
    118c:	ff 91       	pop	r31
    118e:	ef 91       	pop	r30
    1190:	bf 91       	pop	r27
    1192:	af 91       	pop	r26
    1194:	9f 91       	pop	r25
    1196:	8f 91       	pop	r24
    1198:	7f 91       	pop	r23
    119a:	6f 91       	pop	r22
    119c:	5f 91       	pop	r21
    119e:	4f 91       	pop	r20
    11a0:	3f 91       	pop	r19
    11a2:	2f 91       	pop	r18
    11a4:	0f 90       	pop	r0
    11a6:	0b be       	out	0x3b, r0	; 59
    11a8:	0f 90       	pop	r0
    11aa:	0f be       	out	0x3f, r0	; 63
    11ac:	0f 90       	pop	r0
    11ae:	1f 90       	pop	r1
    11b0:	18 95       	reti

000011b2 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    11b2:	1f 92       	push	r1
    11b4:	0f 92       	push	r0
    11b6:	0f b6       	in	r0, 0x3f	; 63
    11b8:	0f 92       	push	r0
    11ba:	11 24       	eor	r1, r1
    11bc:	0b b6       	in	r0, 0x3b	; 59
    11be:	0f 92       	push	r0
    11c0:	2f 93       	push	r18
    11c2:	3f 93       	push	r19
    11c4:	4f 93       	push	r20
    11c6:	5f 93       	push	r21
    11c8:	6f 93       	push	r22
    11ca:	7f 93       	push	r23
    11cc:	8f 93       	push	r24
    11ce:	9f 93       	push	r25
    11d0:	af 93       	push	r26
    11d2:	bf 93       	push	r27
    11d4:	ef 93       	push	r30
    11d6:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    11d8:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    11dc:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    11e0:	e0 91 b2 23 	lds	r30, 0x23B2	; 0x8023b2 <adcb_callback>
    11e4:	f0 91 b3 23 	lds	r31, 0x23B3	; 0x8023b3 <adcb_callback+0x1>
    11e8:	64 e0       	ldi	r22, 0x04	; 4
    11ea:	80 e4       	ldi	r24, 0x40	; 64
    11ec:	92 e0       	ldi	r25, 0x02	; 2
    11ee:	19 95       	eicall
}
    11f0:	ff 91       	pop	r31
    11f2:	ef 91       	pop	r30
    11f4:	bf 91       	pop	r27
    11f6:	af 91       	pop	r26
    11f8:	9f 91       	pop	r25
    11fa:	8f 91       	pop	r24
    11fc:	7f 91       	pop	r23
    11fe:	6f 91       	pop	r22
    1200:	5f 91       	pop	r21
    1202:	4f 91       	pop	r20
    1204:	3f 91       	pop	r19
    1206:	2f 91       	pop	r18
    1208:	0f 90       	pop	r0
    120a:	0b be       	out	0x3b, r0	; 59
    120c:	0f 90       	pop	r0
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	0f 90       	pop	r0
    1212:	1f 90       	pop	r1
    1214:	18 95       	reti

00001216 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1216:	1f 92       	push	r1
    1218:	0f 92       	push	r0
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	0f 92       	push	r0
    121e:	11 24       	eor	r1, r1
    1220:	0b b6       	in	r0, 0x3b	; 59
    1222:	0f 92       	push	r0
    1224:	2f 93       	push	r18
    1226:	3f 93       	push	r19
    1228:	4f 93       	push	r20
    122a:	5f 93       	push	r21
    122c:	6f 93       	push	r22
    122e:	7f 93       	push	r23
    1230:	8f 93       	push	r24
    1232:	9f 93       	push	r25
    1234:	af 93       	push	r26
    1236:	bf 93       	push	r27
    1238:	ef 93       	push	r30
    123a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    123c:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    1240:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    1244:	e0 91 b2 23 	lds	r30, 0x23B2	; 0x8023b2 <adcb_callback>
    1248:	f0 91 b3 23 	lds	r31, 0x23B3	; 0x8023b3 <adcb_callback+0x1>
    124c:	68 e0       	ldi	r22, 0x08	; 8
    124e:	80 e4       	ldi	r24, 0x40	; 64
    1250:	92 e0       	ldi	r25, 0x02	; 2
    1252:	19 95       	eicall
}
    1254:	ff 91       	pop	r31
    1256:	ef 91       	pop	r30
    1258:	bf 91       	pop	r27
    125a:	af 91       	pop	r26
    125c:	9f 91       	pop	r25
    125e:	8f 91       	pop	r24
    1260:	7f 91       	pop	r23
    1262:	6f 91       	pop	r22
    1264:	5f 91       	pop	r21
    1266:	4f 91       	pop	r20
    1268:	3f 91       	pop	r19
    126a:	2f 91       	pop	r18
    126c:	0f 90       	pop	r0
    126e:	0b be       	out	0x3b, r0	; 59
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63
    1274:	0f 90       	pop	r0
    1276:	1f 90       	pop	r1
    1278:	18 95       	reti

0000127a <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    127a:	df 92       	push	r13
    127c:	ef 92       	push	r14
    127e:	ff 92       	push	r15
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ec 01       	movw	r28, r24
    128a:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    128c:	81 15       	cp	r24, r1
    128e:	22 e0       	ldi	r18, 0x02	; 2
    1290:	92 07       	cpc	r25, r18
    1292:	71 f4       	brne	.+28     	; 0x12b0 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1294:	61 e2       	ldi	r22, 0x21	; 33
    1296:	70 e0       	ldi	r23, 0x00	; 0
    1298:	82 e0       	ldi	r24, 0x02	; 2
    129a:	d4 d0       	rcall	.+424    	; 0x1444 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    129c:	e8 2e       	mov	r14, r24
    129e:	f1 2c       	mov	r15, r1
    12a0:	60 e2       	ldi	r22, 0x20	; 32
    12a2:	70 e0       	ldi	r23, 0x00	; 0
    12a4:	82 e0       	ldi	r24, 0x02	; 2
    12a6:	ce d0       	rcall	.+412    	; 0x1444 <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
    12a8:	fe 2c       	mov	r15, r14
    12aa:	ee 24       	eor	r14, r14
    12ac:	e8 2a       	or	r14, r24
    12ae:	10 c0       	rjmp	.+32     	; 0x12d0 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    12b0:	80 34       	cpi	r24, 0x40	; 64
    12b2:	92 40       	sbci	r25, 0x02	; 2
    12b4:	51 f5       	brne	.+84     	; 0x130a <adc_write_configuration+0x90>
    12b6:	65 e2       	ldi	r22, 0x25	; 37
    12b8:	70 e0       	ldi	r23, 0x00	; 0
    12ba:	82 e0       	ldi	r24, 0x02	; 2
    12bc:	c3 d0       	rcall	.+390    	; 0x1444 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    12be:	e8 2e       	mov	r14, r24
    12c0:	f1 2c       	mov	r15, r1
    12c2:	64 e2       	ldi	r22, 0x24	; 36
    12c4:	70 e0       	ldi	r23, 0x00	; 0
    12c6:	82 e0       	ldi	r24, 0x02	; 2
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
    12c8:	bd d0       	rcall	.+378    	; 0x1444 <nvm_read_byte>
    12ca:	fe 2c       	mov	r15, r14

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12cc:	ee 24       	eor	r14, r14
	cpu_irq_disable();
    12ce:	e8 2a       	or	r14, r24
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    12d0:	df b6       	in	r13, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	ce 01       	movw	r24, r28
	enable = adc->CTRLA & ADC_ENABLE_bm;
    12d6:	ee dd       	rcall	.-1060   	; 0xeb4 <adc_enable_clock>

	adc->CTRLA = ADC_FLUSH_bm;
    12d8:	88 81       	ld	r24, Y
    12da:	92 e0       	ldi	r25, 0x02	; 2
	adc->CAL = cal;
    12dc:	98 83       	st	Y, r25
    12de:	ec 86       	std	Y+12, r14	; 0x0c
	adc->CMP = conf->cmp;
    12e0:	fd 86       	std	Y+13, r15	; 0x0d
    12e2:	f8 01       	movw	r30, r16
    12e4:	25 81       	ldd	r18, Z+5	; 0x05
    12e6:	36 81       	ldd	r19, Z+6	; 0x06
    12e8:	28 8f       	std	Y+24, r18	; 0x18
	adc->REFCTRL = conf->refctrl;
    12ea:	39 8f       	std	Y+25, r19	; 0x19
    12ec:	92 81       	ldd	r25, Z+2	; 0x02
	adc->PRESCALER = conf->prescaler;
    12ee:	9a 83       	std	Y+2, r25	; 0x02
    12f0:	94 81       	ldd	r25, Z+4	; 0x04
	adc->EVCTRL = conf->evctrl;
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	93 81       	ldd	r25, Z+3	; 0x03
	adc->CTRLB = conf->ctrlb;
    12f6:	9b 83       	std	Y+3, r25	; 0x03

	adc->CTRLA = enable | conf->ctrla;
    12f8:	91 81       	ldd	r25, Z+1	; 0x01
    12fa:	99 83       	std	Y+1, r25	; 0x01
    12fc:	81 70       	andi	r24, 0x01	; 1

	adc_disable_clock(adc);
    12fe:	90 81       	ld	r25, Z
    1300:	89 2b       	or	r24, r25
    1302:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1304:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    1306:	f5 dd       	rcall	.-1046   	; 0xef2 <adc_disable_clock>
    1308:	df be       	out	0x3f, r13	; 63
    130a:	df 91       	pop	r29
    130c:	cf 91       	pop	r28
    130e:	1f 91       	pop	r17
    1310:	0f 91       	pop	r16
    1312:	ff 90       	pop	r15
    1314:	ef 90       	pop	r14
    1316:	df 90       	pop	r13
    1318:	08 95       	ret

0000131a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    131a:	ff 92       	push	r15
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    1324:	ec 01       	movw	r28, r24
    1326:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1328:	ff b6       	in	r15, 0x3f	; 63
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    132a:	f8 94       	cli

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    132c:	c3 dd       	rcall	.-1146   	; 0xeb4 <adc_enable_clock>
    132e:	88 81       	ld	r24, Y
    1330:	80 7c       	andi	r24, 0xC0	; 192
    1332:	f8 01       	movw	r30, r16

	conf->cmp = adc->CMP;
    1334:	80 83       	st	Z, r24
    1336:	88 8d       	ldd	r24, Y+24	; 0x18
    1338:	99 8d       	ldd	r25, Y+25	; 0x19
    133a:	85 83       	std	Z+5, r24	; 0x05
	conf->refctrl = adc->REFCTRL;
    133c:	96 83       	std	Z+6, r25	; 0x06
    133e:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->prescaler = adc->PRESCALER;
    1340:	82 83       	std	Z+2, r24	; 0x02
    1342:	8c 81       	ldd	r24, Y+4	; 0x04
	conf->evctrl = adc->EVCTRL;
    1344:	84 83       	std	Z+4, r24	; 0x04
    1346:	8b 81       	ldd	r24, Y+3	; 0x03
	conf->ctrlb = adc->CTRLB;
    1348:	83 83       	std	Z+3, r24	; 0x03

	adc_disable_clock(adc);
    134a:	89 81       	ldd	r24, Y+1	; 0x01
    134c:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    134e:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    1350:	d0 dd       	rcall	.-1120   	; 0xef2 <adc_disable_clock>
    1352:	ff be       	out	0x3f, r15	; 63
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	ff 90       	pop	r15
    135e:	08 95       	ret

00001360 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    1360:	cf 92       	push	r12
    1362:	df 92       	push	r13
    1364:	ef 92       	push	r14
    1366:	ff 92       	push	r15
    1368:	0f 93       	push	r16
    136a:	1f 93       	push	r17
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	7c 01       	movw	r14, r24
    1372:	d6 2e       	mov	r13, r22
    1374:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1376:	86 2f       	mov	r24, r22
    1378:	83 70       	andi	r24, 0x03	; 3
    137a:	29 f4       	brne	.+10     	; 0x1386 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    137c:	96 2f       	mov	r25, r22
    137e:	96 95       	lsr	r25
    1380:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1382:	82 e0       	ldi	r24, 0x02	; 2
    1384:	02 c0       	rjmp	.+4      	; 0x138a <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1386:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1388:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    138a:	90 ff       	sbrs	r25, 0
		index++;
    138c:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    138e:	e7 01       	movw	r28, r14
    1390:	a0 96       	adiw	r28, 0x20	; 32
    1392:	98 e0       	ldi	r25, 0x08	; 8
    1394:	89 9f       	mul	r24, r25
    1396:	c0 0d       	add	r28, r0
    1398:	d1 1d       	adc	r29, r1
    139a:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    139c:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    139e:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    13a0:	c7 01       	movw	r24, r14
    13a2:	88 dd       	rcall	.-1264   	; 0xeb4 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    13a4:	f8 01       	movw	r30, r16
    13a6:	80 81       	ld	r24, Z
    13a8:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    13aa:	82 81       	ldd	r24, Z+2	; 0x02
    13ac:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    13ae:	81 81       	ldd	r24, Z+1	; 0x01
    13b0:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    13b2:	d0 fe       	sbrs	r13, 0
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    13b6:	83 81       	ldd	r24, Z+3	; 0x03
	}
	adc_disable_clock(adc);
    13b8:	8e 83       	std	Y+6, r24	; 0x06
    13ba:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    13bc:	9a dd       	rcall	.-1228   	; 0xef2 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    13be:	cf be       	out	0x3f, r12	; 63
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	df 90       	pop	r13
    13ce:	cf 90       	pop	r12
    13d0:	08 95       	ret

000013d2 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    13d2:	cf 92       	push	r12
    13d4:	df 92       	push	r13
    13d6:	ef 92       	push	r14
    13d8:	ff 92       	push	r15
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	7c 01       	movw	r14, r24
    13e4:	d6 2e       	mov	r13, r22
    13e6:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    13e8:	86 2f       	mov	r24, r22
    13ea:	83 70       	andi	r24, 0x03	; 3
    13ec:	29 f4       	brne	.+10     	; 0x13f8 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    13ee:	96 2f       	mov	r25, r22
    13f0:	96 95       	lsr	r25
    13f2:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    13f4:	82 e0       	ldi	r24, 0x02	; 2
    13f6:	02 c0       	rjmp	.+4      	; 0x13fc <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    13f8:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    13fa:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    13fc:	90 ff       	sbrs	r25, 0
		index++;
    13fe:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1400:	e7 01       	movw	r28, r14
    1402:	a0 96       	adiw	r28, 0x20	; 32
    1404:	98 e0       	ldi	r25, 0x08	; 8
    1406:	89 9f       	mul	r24, r25
    1408:	c0 0d       	add	r28, r0
    140a:	d1 1d       	adc	r29, r1
    140c:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    140e:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1410:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1412:	c7 01       	movw	r24, r14
    1414:	4f dd       	rcall	.-1378   	; 0xeb4 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1416:	88 81       	ld	r24, Y
    1418:	f8 01       	movw	r30, r16
    141a:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1420:	89 81       	ldd	r24, Y+1	; 0x01
    1422:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1424:	d0 fe       	sbrs	r13, 0
    1426:	02 c0       	rjmp	.+4      	; 0x142c <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1428:	8e 81       	ldd	r24, Y+6	; 0x06
	}
	adc_disable_clock(adc);
    142a:	83 83       	std	Z+3, r24	; 0x03
    142c:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    142e:	61 dd       	rcall	.-1342   	; 0xef2 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    1430:	cf be       	out	0x3f, r12	; 63
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	ff 90       	pop	r15
    143c:	ef 90       	pop	r14
    143e:	df 90       	pop	r13
    1440:	cf 90       	pop	r12
    1442:	08 95       	ret

00001444 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    1444:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    1448:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    144a:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    144c:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    1450:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    1452:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    1456:	08 95       	ret

00001458 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1458:	cf 92       	push	r12
    145a:	df 92       	push	r13
    145c:	ef 92       	push	r14
    145e:	ff 92       	push	r15
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
    1468:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    146a:	d9 01       	movw	r26, r18
    146c:	c8 01       	movw	r24, r16
    146e:	b6 95       	lsr	r27
    1470:	a7 95       	ror	r26
    1472:	97 95       	ror	r25
    1474:	87 95       	ror	r24
    1476:	48 17       	cp	r20, r24
    1478:	59 07       	cpc	r21, r25
    147a:	6a 07       	cpc	r22, r26
    147c:	7b 07       	cpc	r23, r27
    147e:	78 f4       	brcc	.+30     	; 0x149e <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1480:	6a 01       	movw	r12, r20
    1482:	7b 01       	movw	r14, r22
    1484:	cc 0c       	add	r12, r12
    1486:	dd 1c       	adc	r13, r13
    1488:	ee 1c       	adc	r14, r14
    148a:	ff 1c       	adc	r15, r15
    148c:	c9 01       	movw	r24, r18
    148e:	b8 01       	movw	r22, r16
    1490:	a7 01       	movw	r20, r14
    1492:	96 01       	movw	r18, r12
    1494:	0e 94 18 1c 	call	0x3830	; 0x3830 <__udivmodsi4>
    1498:	21 50       	subi	r18, 0x01	; 1
    149a:	31 09       	sbc	r19, r1
    149c:	02 c0       	rjmp	.+4      	; 0x14a2 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    149e:	20 e0       	ldi	r18, 0x00	; 0
    14a0:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    14a2:	83 2f       	mov	r24, r19
    14a4:	8f 70       	andi	r24, 0x0F	; 15
    14a6:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    14a8:	2e 83       	std	Y+6, r18	; 0x06
}
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	1f 91       	pop	r17
    14b0:	0f 91       	pop	r16
    14b2:	ff 90       	pop	r15
    14b4:	ef 90       	pop	r14
    14b6:	df 90       	pop	r13
    14b8:	cf 90       	pop	r12
    14ba:	08 95       	ret

000014bc <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    14bc:	ef 92       	push	r14
    14be:	ff 92       	push	r15
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	ec 01       	movw	r28, r24
    14ca:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    14cc:	00 97       	sbiw	r24, 0x00	; 0
    14ce:	09 f4       	brne	.+2      	; 0x14d2 <usart_init_spi+0x16>
    14d0:	7b c1       	rjmp	.+758    	; 0x17c8 <usart_init_spi+0x30c>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    14d2:	80 3c       	cpi	r24, 0xC0	; 192
    14d4:	91 05       	cpc	r25, r1
    14d6:	21 f4       	brne	.+8      	; 0x14e0 <usart_init_spi+0x24>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    14d8:	60 e1       	ldi	r22, 0x10	; 16
    14da:	80 e0       	ldi	r24, 0x00	; 0
    14dc:	1b da       	rcall	.-3018   	; 0x914 <sysclk_enable_module>
    14de:	74 c1       	rjmp	.+744    	; 0x17c8 <usart_init_spi+0x30c>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    14e0:	80 38       	cpi	r24, 0x80	; 128
    14e2:	91 40       	sbci	r25, 0x01	; 1
    14e4:	21 f4       	brne	.+8      	; 0x14ee <usart_init_spi+0x32>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    14e6:	62 e0       	ldi	r22, 0x02	; 2
    14e8:	80 e0       	ldi	r24, 0x00	; 0
    14ea:	14 da       	rcall	.-3032   	; 0x914 <sysclk_enable_module>
    14ec:	6d c1       	rjmp	.+730    	; 0x17c8 <usart_init_spi+0x30c>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    14ee:	c1 15       	cp	r28, r1
    14f0:	81 e0       	ldi	r24, 0x01	; 1
    14f2:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    14f4:	21 f4       	brne	.+8      	; 0x14fe <usart_init_spi+0x42>
    14f6:	61 e0       	ldi	r22, 0x01	; 1
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	0c da       	rcall	.-3048   	; 0x914 <sysclk_enable_module>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    14fc:	65 c1       	rjmp	.+714    	; 0x17c8 <usart_init_spi+0x30c>
    14fe:	c0 38       	cpi	r28, 0x80	; 128
    1500:	e3 e0       	ldi	r30, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1502:	de 07       	cpc	r29, r30
    1504:	21 f4       	brne	.+8      	; 0x150e <usart_init_spi+0x52>
    1506:	61 e0       	ldi	r22, 0x01	; 1
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	04 da       	rcall	.-3064   	; 0x914 <sysclk_enable_module>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    150c:	5d c1       	rjmp	.+698    	; 0x17c8 <usart_init_spi+0x30c>
    150e:	c0 39       	cpi	r28, 0x90	; 144
    1510:	f3 e0       	ldi	r31, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1512:	df 07       	cpc	r29, r31
    1514:	21 f4       	brne	.+8      	; 0x151e <usart_init_spi+0x62>
    1516:	61 e0       	ldi	r22, 0x01	; 1
    1518:	82 e0       	ldi	r24, 0x02	; 2
    151a:	fc d9       	rcall	.-3080   	; 0x914 <sysclk_enable_module>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    151c:	55 c1       	rjmp	.+682    	; 0x17c8 <usart_init_spi+0x30c>
    151e:	c1 15       	cp	r28, r1
    1520:	32 e0       	ldi	r19, 0x02	; 2
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1522:	d3 07       	cpc	r29, r19
    1524:	21 f4       	brne	.+8      	; 0x152e <usart_init_spi+0x72>
    1526:	62 e0       	ldi	r22, 0x02	; 2
    1528:	81 e0       	ldi	r24, 0x01	; 1
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    152a:	f4 d9       	rcall	.-3096   	; 0x914 <sysclk_enable_module>
    152c:	4d c1       	rjmp	.+666    	; 0x17c8 <usart_init_spi+0x30c>
    152e:	c0 34       	cpi	r28, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1530:	82 e0       	ldi	r24, 0x02	; 2
    1532:	d8 07       	cpc	r29, r24
    1534:	21 f4       	brne	.+8      	; 0x153e <usart_init_spi+0x82>
    1536:	62 e0       	ldi	r22, 0x02	; 2
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1538:	82 e0       	ldi	r24, 0x02	; 2
    153a:	ec d9       	rcall	.-3112   	; 0x914 <sysclk_enable_module>
    153c:	45 c1       	rjmp	.+650    	; 0x17c8 <usart_init_spi+0x30c>
    153e:	c0 32       	cpi	r28, 0x20	; 32
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1540:	e3 e0       	ldi	r30, 0x03	; 3
    1542:	de 07       	cpc	r29, r30
    1544:	21 f4       	brne	.+8      	; 0x154e <usart_init_spi+0x92>
    1546:	64 e0       	ldi	r22, 0x04	; 4
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1548:	82 e0       	ldi	r24, 0x02	; 2
    154a:	e4 d9       	rcall	.-3128   	; 0x914 <sysclk_enable_module>
    154c:	3d c1       	rjmp	.+634    	; 0x17c8 <usart_init_spi+0x30c>
    154e:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1550:	f8 e0       	ldi	r31, 0x08	; 8
    1552:	df 07       	cpc	r29, r31
    1554:	21 f4       	brne	.+8      	; 0x155e <usart_init_spi+0xa2>
    1556:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1558:	83 e0       	ldi	r24, 0x03	; 3
    155a:	dc d9       	rcall	.-3144   	; 0x914 <sysclk_enable_module>
    155c:	35 c1       	rjmp	.+618    	; 0x17c8 <usart_init_spi+0x30c>
    155e:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1560:	39 e0       	ldi	r19, 0x09	; 9
    1562:	d3 07       	cpc	r29, r19
    1564:	21 f4       	brne	.+8      	; 0x156e <usart_init_spi+0xb2>
    1566:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1568:	84 e0       	ldi	r24, 0x04	; 4
    156a:	d4 d9       	rcall	.-3160   	; 0x914 <sysclk_enable_module>
    156c:	2d c1       	rjmp	.+602    	; 0x17c8 <usart_init_spi+0x30c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    156e:	c1 15       	cp	r28, r1
    1570:	8a e0       	ldi	r24, 0x0A	; 10
    1572:	d8 07       	cpc	r29, r24
    1574:	21 f4       	brne	.+8      	; 0x157e <usart_init_spi+0xc2>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	85 e0       	ldi	r24, 0x05	; 5
    157a:	cc d9       	rcall	.-3176   	; 0x914 <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    157c:	25 c1       	rjmp	.+586    	; 0x17c8 <usart_init_spi+0x30c>
    157e:	c1 15       	cp	r28, r1
    1580:	eb e0       	ldi	r30, 0x0B	; 11
    1582:	de 07       	cpc	r29, r30
    1584:	21 f4       	brne	.+8      	; 0x158e <usart_init_spi+0xd2>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1586:	61 e0       	ldi	r22, 0x01	; 1
    1588:	86 e0       	ldi	r24, 0x06	; 6
    158a:	c4 d9       	rcall	.-3192   	; 0x914 <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    158c:	1d c1       	rjmp	.+570    	; 0x17c8 <usart_init_spi+0x30c>
    158e:	c0 34       	cpi	r28, 0x40	; 64
    1590:	f8 e0       	ldi	r31, 0x08	; 8
    1592:	df 07       	cpc	r29, r31
    1594:	21 f4       	brne	.+8      	; 0x159e <usart_init_spi+0xe2>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1596:	62 e0       	ldi	r22, 0x02	; 2
    1598:	83 e0       	ldi	r24, 0x03	; 3
    159a:	bc d9       	rcall	.-3208   	; 0x914 <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    159c:	15 c1       	rjmp	.+554    	; 0x17c8 <usart_init_spi+0x30c>
    159e:	c0 34       	cpi	r28, 0x40	; 64
    15a0:	39 e0       	ldi	r19, 0x09	; 9
    15a2:	d3 07       	cpc	r29, r19
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    15a4:	21 f4       	brne	.+8      	; 0x15ae <usart_init_spi+0xf2>
    15a6:	62 e0       	ldi	r22, 0x02	; 2
    15a8:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    15aa:	b4 d9       	rcall	.-3224   	; 0x914 <sysclk_enable_module>
    15ac:	0d c1       	rjmp	.+538    	; 0x17c8 <usart_init_spi+0x30c>
    15ae:	c0 34       	cpi	r28, 0x40	; 64
    15b0:	8a e0       	ldi	r24, 0x0A	; 10
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    15b2:	d8 07       	cpc	r29, r24
    15b4:	21 f4       	brne	.+8      	; 0x15be <usart_init_spi+0x102>
    15b6:	62 e0       	ldi	r22, 0x02	; 2
    15b8:	85 e0       	ldi	r24, 0x05	; 5
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    15ba:	ac d9       	rcall	.-3240   	; 0x914 <sysclk_enable_module>
    15bc:	05 c1       	rjmp	.+522    	; 0x17c8 <usart_init_spi+0x30c>
    15be:	c0 39       	cpi	r28, 0x90	; 144
    15c0:	e8 e0       	ldi	r30, 0x08	; 8
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    15c2:	de 07       	cpc	r29, r30
    15c4:	21 f4       	brne	.+8      	; 0x15ce <usart_init_spi+0x112>
    15c6:	64 e0       	ldi	r22, 0x04	; 4
    15c8:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    15ca:	a4 d9       	rcall	.-3256   	; 0x914 <sysclk_enable_module>
    15cc:	fd c0       	rjmp	.+506    	; 0x17c8 <usart_init_spi+0x30c>
    15ce:	c0 39       	cpi	r28, 0x90	; 144
    15d0:	f9 e0       	ldi	r31, 0x09	; 9
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    15d2:	df 07       	cpc	r29, r31
    15d4:	21 f4       	brne	.+8      	; 0x15de <usart_init_spi+0x122>
    15d6:	64 e0       	ldi	r22, 0x04	; 4
    15d8:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    15da:	9c d9       	rcall	.-3272   	; 0x914 <sysclk_enable_module>
    15dc:	f5 c0       	rjmp	.+490    	; 0x17c8 <usart_init_spi+0x30c>
    15de:	c0 39       	cpi	r28, 0x90	; 144
    15e0:	3a e0       	ldi	r19, 0x0A	; 10
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    15e2:	d3 07       	cpc	r29, r19
    15e4:	21 f4       	brne	.+8      	; 0x15ee <usart_init_spi+0x132>
    15e6:	64 e0       	ldi	r22, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    15e8:	85 e0       	ldi	r24, 0x05	; 5
    15ea:	94 d9       	rcall	.-3288   	; 0x914 <sysclk_enable_module>
    15ec:	ed c0       	rjmp	.+474    	; 0x17c8 <usart_init_spi+0x30c>
    15ee:	c0 39       	cpi	r28, 0x90	; 144
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    15f0:	8b e0       	ldi	r24, 0x0B	; 11
    15f2:	d8 07       	cpc	r29, r24
    15f4:	21 f4       	brne	.+8      	; 0x15fe <usart_init_spi+0x142>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    15f6:	64 e0       	ldi	r22, 0x04	; 4
    15f8:	86 e0       	ldi	r24, 0x06	; 6
    15fa:	8c d9       	rcall	.-3304   	; 0x914 <sysclk_enable_module>
    15fc:	e5 c0       	rjmp	.+458    	; 0x17c8 <usart_init_spi+0x30c>
    15fe:	c0 3c       	cpi	r28, 0xC0	; 192
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1600:	e8 e0       	ldi	r30, 0x08	; 8
    1602:	de 07       	cpc	r29, r30
    1604:	21 f4       	brne	.+8      	; 0x160e <usart_init_spi+0x152>
    1606:	68 e0       	ldi	r22, 0x08	; 8
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1608:	83 e0       	ldi	r24, 0x03	; 3
    160a:	84 d9       	rcall	.-3320   	; 0x914 <sysclk_enable_module>
    160c:	dd c0       	rjmp	.+442    	; 0x17c8 <usart_init_spi+0x30c>
    160e:	c0 3c       	cpi	r28, 0xC0	; 192
    1610:	f9 e0       	ldi	r31, 0x09	; 9
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1612:	df 07       	cpc	r29, r31
    1614:	21 f4       	brne	.+8      	; 0x161e <usart_init_spi+0x162>
    1616:	68 e0       	ldi	r22, 0x08	; 8
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1618:	84 e0       	ldi	r24, 0x04	; 4
    161a:	7c d9       	rcall	.-3336   	; 0x914 <sysclk_enable_module>
    161c:	d5 c0       	rjmp	.+426    	; 0x17c8 <usart_init_spi+0x30c>
    161e:	c0 3a       	cpi	r28, 0xA0	; 160
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1620:	38 e0       	ldi	r19, 0x08	; 8
    1622:	d3 07       	cpc	r29, r19
    1624:	61 f4       	brne	.+24     	; 0x163e <usart_init_spi+0x182>
    1626:	60 e1       	ldi	r22, 0x10	; 16
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1628:	83 e0       	ldi	r24, 0x03	; 3
    162a:	74 d9       	rcall	.-3352   	; 0x914 <sysclk_enable_module>
    162c:	e0 ea       	ldi	r30, 0xA0	; 160
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    162e:	f8 e0       	ldi	r31, 0x08	; 8
    1630:	84 81       	ldd	r24, Z+4	; 0x04
    1632:	8f 7e       	andi	r24, 0xEF	; 239
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1634:	84 83       	std	Z+4, r24	; 0x04
    1636:	f7 01       	movw	r30, r14
    1638:	24 81       	ldd	r18, Z+4	; 0x04
    163a:	22 50       	subi	r18, 0x02	; 2
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    163c:	43 c0       	rjmp	.+134    	; 0x16c4 <usart_init_spi+0x208>
    163e:	c0 3a       	cpi	r28, 0xA0	; 160
    1640:	f9 e0       	ldi	r31, 0x09	; 9
    1642:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1644:	21 f4       	brne	.+8      	; 0x164e <usart_init_spi+0x192>
    1646:	60 e1       	ldi	r22, 0x10	; 16
    1648:	84 e0       	ldi	r24, 0x04	; 4
    164a:	64 d9       	rcall	.-3384   	; 0x914 <sysclk_enable_module>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    164c:	bd c0       	rjmp	.+378    	; 0x17c8 <usart_init_spi+0x30c>
    164e:	c0 3a       	cpi	r28, 0xA0	; 160
    1650:	3a e0       	ldi	r19, 0x0A	; 10
    1652:	d3 07       	cpc	r29, r19
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1654:	21 f4       	brne	.+8      	; 0x165e <usart_init_spi+0x1a2>
    1656:	60 e1       	ldi	r22, 0x10	; 16
    1658:	85 e0       	ldi	r24, 0x05	; 5
    165a:	5c d9       	rcall	.-3400   	; 0x914 <sysclk_enable_module>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    165c:	b5 c0       	rjmp	.+362    	; 0x17c8 <usart_init_spi+0x30c>
    165e:	c0 3a       	cpi	r28, 0xA0	; 160
    1660:	8b e0       	ldi	r24, 0x0B	; 11
    1662:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1664:	21 f4       	brne	.+8      	; 0x166e <usart_init_spi+0x1b2>
    1666:	60 e1       	ldi	r22, 0x10	; 16
    1668:	86 e0       	ldi	r24, 0x06	; 6
    166a:	54 d9       	rcall	.-3416   	; 0x914 <sysclk_enable_module>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    166c:	ad c0       	rjmp	.+346    	; 0x17c8 <usart_init_spi+0x30c>
    166e:	c0 3b       	cpi	r28, 0xB0	; 176
    1670:	e8 e0       	ldi	r30, 0x08	; 8
    1672:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1674:	21 f4       	brne	.+8      	; 0x167e <usart_init_spi+0x1c2>
    1676:	60 e2       	ldi	r22, 0x20	; 32
    1678:	83 e0       	ldi	r24, 0x03	; 3
    167a:	4c d9       	rcall	.-3432   	; 0x914 <sysclk_enable_module>
    167c:	a5 c0       	rjmp	.+330    	; 0x17c8 <usart_init_spi+0x30c>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    167e:	c0 3b       	cpi	r28, 0xB0	; 176
    1680:	f9 e0       	ldi	r31, 0x09	; 9
    1682:	df 07       	cpc	r29, r31
    1684:	21 f4       	brne	.+8      	; 0x168e <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1686:	60 e2       	ldi	r22, 0x20	; 32
    1688:	84 e0       	ldi	r24, 0x04	; 4
    168a:	44 d9       	rcall	.-3448   	; 0x914 <sysclk_enable_module>
    168c:	9d c0       	rjmp	.+314    	; 0x17c8 <usart_init_spi+0x30c>
    168e:	c0 38       	cpi	r28, 0x80	; 128
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1690:	34 e0       	ldi	r19, 0x04	; 4
    1692:	d3 07       	cpc	r29, r19
    1694:	21 f4       	brne	.+8      	; 0x169e <usart_init_spi+0x1e2>
    1696:	60 e4       	ldi	r22, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1698:	83 e0       	ldi	r24, 0x03	; 3
    169a:	3c d9       	rcall	.-3464   	; 0x914 <sysclk_enable_module>
    169c:	95 c0       	rjmp	.+298    	; 0x17c8 <usart_init_spi+0x30c>
    169e:	c0 3a       	cpi	r28, 0xA0	; 160
    16a0:	84 e0       	ldi	r24, 0x04	; 4
    16a2:	d8 07       	cpc	r29, r24
    16a4:	21 f4       	brne	.+8      	; 0x16ae <usart_init_spi+0x1f2>
    16a6:	60 e4       	ldi	r22, 0x40	; 64
    16a8:	85 e0       	ldi	r24, 0x05	; 5
    16aa:	34 d9       	rcall	.-3480   	; 0x914 <sysclk_enable_module>
    16ac:	8d c0       	rjmp	.+282    	; 0x17c8 <usart_init_spi+0x30c>
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    16ae:	8c 81       	ldd	r24, Y+4	; 0x04
    16b0:	8f 7e       	andi	r24, 0xEF	; 239
    16b2:	8c 83       	std	Y+4, r24	; 0x04
    16b4:	fb 01       	movw	r30, r22
    16b6:	24 81       	ldd	r18, Z+4	; 0x04
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    16b8:	22 50       	subi	r18, 0x02	; 2
    16ba:	ce 01       	movw	r24, r28
    16bc:	c0 3a       	cpi	r28, 0xA0	; 160
    16be:	f8 e0       	ldi	r31, 0x08	; 8
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    16c0:	df 07       	cpc	r29, r31
    16c2:	31 f4       	brne	.+12     	; 0x16d0 <usart_init_spi+0x214>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    16c4:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    16c8:	84 fd       	sbrc	r24, 4
    16ca:	86 c0       	rjmp	.+268    	; 0x17d8 <usart_init_spi+0x31c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    16cc:	11 e1       	ldi	r17, 0x11	; 17
    16ce:	85 c0       	rjmp	.+266    	; 0x17da <usart_init_spi+0x31e>
    16d0:	80 3b       	cpi	r24, 0xB0	; 176
    16d2:	38 e0       	ldi	r19, 0x08	; 8
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    16d4:	93 07       	cpc	r25, r19
    16d6:	79 f0       	breq	.+30     	; 0x16f6 <usart_init_spi+0x23a>
    16d8:	80 3a       	cpi	r24, 0xA0	; 160
    16da:	e9 e0       	ldi	r30, 0x09	; 9
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    16dc:	9e 07       	cpc	r25, r30
    16de:	31 f4       	brne	.+12     	; 0x16ec <usart_init_spi+0x230>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    16e0:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    16e4:	34 fd       	sbrc	r19, 4
    16e6:	7c c0       	rjmp	.+248    	; 0x17e0 <usart_init_spi+0x324>
    16e8:	19 e1       	ldi	r17, 0x19	; 25
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    16ea:	10 c0       	rjmp	.+32     	; 0x170c <usart_init_spi+0x250>
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    16ec:	80 3b       	cpi	r24, 0xB0	; 176
    16ee:	f9 e0       	ldi	r31, 0x09	; 9
    16f0:	9f 07       	cpc	r25, r31
    16f2:	a9 f0       	breq	.+42     	; 0x171e <usart_init_spi+0x262>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    16f4:	01 c0       	rjmp	.+2      	; 0x16f8 <usart_init_spi+0x23c>
    16f6:	15 e1       	ldi	r17, 0x15	; 21
    16f8:	80 3a       	cpi	r24, 0xA0	; 160
    16fa:	3a e0       	ldi	r19, 0x0A	; 10
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    16fc:	93 07       	cpc	r25, r19
    16fe:	31 f4       	brne	.+12     	; 0x170c <usart_init_spi+0x250>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1700:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1704:	84 fd       	sbrc	r24, 4
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1706:	6e c0       	rjmp	.+220    	; 0x17e4 <usart_init_spi+0x328>
    1708:	11 e2       	ldi	r17, 0x21	; 33
    170a:	0c c0       	rjmp	.+24     	; 0x1724 <usart_init_spi+0x268>
    170c:	80 3a       	cpi	r24, 0xA0	; 160
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    170e:	9b 40       	sbci	r25, 0x0B	; 11
    1710:	49 f4       	brne	.+18     	; 0x1724 <usart_init_spi+0x268>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1712:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1716:	84 fd       	sbrc	r24, 4
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1718:	04 c0       	rjmp	.+8      	; 0x1722 <usart_init_spi+0x266>
    171a:	19 e2       	ldi	r17, 0x29	; 41
    171c:	03 c0       	rjmp	.+6      	; 0x1724 <usart_init_spi+0x268>
    171e:	1d e1       	ldi	r17, 0x1D	; 29
    1720:	01 c0       	rjmp	.+2      	; 0x1724 <usart_init_spi+0x268>
    1722:	1d e2       	ldi	r17, 0x2D	; 45
    1724:	e1 2f       	mov	r30, r17
    1726:	e6 95       	lsr	r30
    1728:	e6 95       	lsr	r30
    172a:	e6 95       	lsr	r30
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    172c:	30 e2       	ldi	r19, 0x20	; 32
    172e:	e3 9f       	mul	r30, r19
    1730:	f0 01       	movw	r30, r0
    1732:	11 24       	eor	r1, r1
    1734:	fa 5f       	subi	r31, 0xFA	; 250
    1736:	17 70       	andi	r17, 0x07	; 7
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	90 e0       	ldi	r25, 0x00	; 0
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    173c:	01 2e       	mov	r0, r17
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    173e:	02 c0       	rjmp	.+4      	; 0x1744 <usart_init_spi+0x288>
    1740:	88 0f       	add	r24, r24
    1742:	99 1f       	adc	r25, r25
    1744:	0a 94       	dec	r0
    1746:	e2 f7       	brpl	.-8      	; 0x1740 <usart_init_spi+0x284>
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1748:	81 83       	std	Z+1, r24	; 0x01
    174a:	22 30       	cpi	r18, 0x02	; 2

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    174c:	10 f0       	brcs	.+4      	; 0x1752 <usart_init_spi+0x296>
    174e:	40 e0       	ldi	r20, 0x00	; 0

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1750:	01 c0       	rjmp	.+2      	; 0x1754 <usart_init_spi+0x298>
	cpu_irq_disable();
    1752:	40 e4       	ldi	r20, 0x40	; 64
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1754:	df 01       	movw	r26, r30
    1756:	50 96       	adiw	r26, 0x10	; 16
    1758:	a1 0f       	add	r26, r17
	*pin_ctrl |= mode;
    175a:	b1 1d       	adc	r27, r1
    175c:	3f b7       	in	r19, 0x3f	; 63
    175e:	f8 94       	cli
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1760:	2c 91       	ld	r18, X
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1762:	27 70       	andi	r18, 0x07	; 7
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1764:	2c 93       	st	X, r18
    1766:	9c 91       	ld	r25, X
    1768:	94 2b       	or	r25, r20
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    176a:	9c 93       	st	X, r25
    176c:	3f bf       	out	0x3f, r19	; 63
    176e:	85 83       	std	Z+5, r24	; 0x05
    1770:	8d 81       	ldd	r24, Y+5	; 0x05
		usart->CTRLC |= USART_UCPHA_bm;
    1772:	80 6c       	ori	r24, 0xC0	; 192
    1774:	8d 83       	std	Y+5, r24	; 0x05
    1776:	f7 01       	movw	r30, r14
    1778:	84 81       	ldd	r24, Z+4	; 0x04
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    177a:	8d 7f       	andi	r24, 0xFD	; 253
    177c:	81 30       	cpi	r24, 0x01	; 1
    177e:	21 f4       	brne	.+8      	; 0x1788 <usart_init_spi+0x2cc>
	}
	if (opt->data_order) {
    1780:	8d 81       	ldd	r24, Y+5	; 0x05
    1782:	82 60       	ori	r24, 0x02	; 2
    1784:	8d 83       	std	Y+5, r24	; 0x05
    1786:	03 c0       	rjmp	.+6      	; 0x178e <usart_init_spi+0x2d2>
		(usart)->CTRLC |= USART_DORD_bm;
    1788:	8d 81       	ldd	r24, Y+5	; 0x05
    178a:	8d 7f       	andi	r24, 0xFD	; 253
    178c:	8d 83       	std	Y+5, r24	; 0x05
    178e:	f7 01       	movw	r30, r14
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1790:	85 81       	ldd	r24, Z+5	; 0x05
    1792:	88 23       	and	r24, r24
    1794:	21 f0       	breq	.+8      	; 0x179e <usart_init_spi+0x2e2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1796:	8d 81       	ldd	r24, Y+5	; 0x05
    1798:	84 60       	ori	r24, 0x04	; 4
    179a:	8d 83       	std	Y+5, r24	; 0x05
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <usart_init_spi+0x2e8>
    179e:	8d 81       	ldd	r24, Y+5	; 0x05
    17a0:	8b 7f       	andi	r24, 0xFB	; 251
    17a2:	8d 83       	std	Y+5, r24	; 0x05
    17a4:	f7 01       	movw	r30, r14
    17a6:	40 81       	ld	r20, Z
    17a8:	51 81       	ldd	r21, Z+1	; 0x01
    17aa:	62 81       	ldd	r22, Z+2	; 0x02
    17ac:	73 81       	ldd	r23, Z+3	; 0x03
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    17ae:	00 e8       	ldi	r16, 0x80	; 128
    17b0:	14 e8       	ldi	r17, 0x84	; 132
    17b2:	2e e1       	ldi	r18, 0x1E	; 30
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	ce 01       	movw	r24, r28
    17b8:	4f de       	rcall	.-866    	; 0x1458 <usart_spi_set_baudrate>
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    17ba:	8c 81       	ldd	r24, Y+4	; 0x04
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    17bc:	88 60       	ori	r24, 0x08	; 8
    17be:	8c 83       	std	Y+4, r24	; 0x04
    17c0:	8c 81       	ldd	r24, Y+4	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    17c2:	80 61       	ori	r24, 0x10	; 16
    17c4:	8c 83       	std	Y+4, r24	; 0x04
    17c6:	10 c0       	rjmp	.+32     	; 0x17e8 <usart_init_spi+0x32c>
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    17c8:	8c 81       	ldd	r24, Y+4	; 0x04
    17ca:	8f 7e       	andi	r24, 0xEF	; 239
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    17cc:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    17ce:	f7 01       	movw	r30, r14
    17d0:	24 81       	ldd	r18, Z+4	; 0x04
    17d2:	22 50       	subi	r18, 0x02	; 2
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    17d4:	ce 01       	movw	r24, r28
    17d6:	7c cf       	rjmp	.-264    	; 0x16d0 <usart_init_spi+0x214>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    17d8:	15 e1       	ldi	r17, 0x15	; 21
    17da:	80 ea       	ldi	r24, 0xA0	; 160
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    17dc:	98 e0       	ldi	r25, 0x08	; 8
    17de:	86 cf       	rjmp	.-244    	; 0x16ec <usart_init_spi+0x230>
    17e0:	1d e1       	ldi	r17, 0x1D	; 29
    17e2:	94 cf       	rjmp	.-216    	; 0x170c <usart_init_spi+0x250>
    17e4:	15 e2       	ldi	r17, 0x25	; 37
    17e6:	9e cf       	rjmp	.-196    	; 0x1724 <usart_init_spi+0x268>
    17e8:	df 91       	pop	r29
    17ea:	cf 91       	pop	r28
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	08 95       	ret

000017f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    17f6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17f8:	03 96       	adiw	r24, 0x03	; 3
    17fa:	81 83       	std	Z+1, r24	; 0x01
    17fc:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    17fe:	2f ef       	ldi	r18, 0xFF	; 255
    1800:	3f ef       	ldi	r19, 0xFF	; 255
    1802:	23 83       	std	Z+3, r18	; 0x03
    1804:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1806:	85 83       	std	Z+5, r24	; 0x05
    1808:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    180a:	87 83       	std	Z+7, r24	; 0x07
    180c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    180e:	10 82       	st	Z, r1
    1810:	08 95       	ret

00001812 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1812:	fc 01       	movw	r30, r24
    1814:	10 86       	std	Z+8, r1	; 0x08
    1816:	11 86       	std	Z+9, r1	; 0x09
    1818:	08 95       	ret

0000181a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    181a:	cf 93       	push	r28
    181c:	df 93       	push	r29
    181e:	9c 01       	movw	r18, r24
    1820:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1822:	dc 01       	movw	r26, r24
    1824:	11 96       	adiw	r26, 0x01	; 1
    1826:	cd 91       	ld	r28, X+
    1828:	dc 91       	ld	r29, X
    182a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    182c:	c2 83       	std	Z+2, r28	; 0x02
    182e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1830:	8c 81       	ldd	r24, Y+4	; 0x04
    1832:	9d 81       	ldd	r25, Y+5	; 0x05
    1834:	84 83       	std	Z+4, r24	; 0x04
    1836:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1838:	8c 81       	ldd	r24, Y+4	; 0x04
    183a:	9d 81       	ldd	r25, Y+5	; 0x05
    183c:	dc 01       	movw	r26, r24
    183e:	12 96       	adiw	r26, 0x02	; 2
    1840:	6d 93       	st	X+, r22
    1842:	7c 93       	st	X, r23
    1844:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1846:	6c 83       	std	Y+4, r22	; 0x04
    1848:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    184a:	20 87       	std	Z+8, r18	; 0x08
    184c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    184e:	f9 01       	movw	r30, r18
    1850:	80 81       	ld	r24, Z
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	80 83       	st	Z, r24
}
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	08 95       	ret

0000185c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1862:	48 81       	ld	r20, Y
    1864:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1866:	4f 3f       	cpi	r20, 0xFF	; 255
    1868:	2f ef       	ldi	r18, 0xFF	; 255
    186a:	52 07       	cpc	r21, r18
    186c:	21 f4       	brne	.+8      	; 0x1876 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    186e:	fc 01       	movw	r30, r24
    1870:	a7 81       	ldd	r26, Z+7	; 0x07
    1872:	b0 85       	ldd	r27, Z+8	; 0x08
    1874:	0d c0       	rjmp	.+26     	; 0x1890 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1876:	dc 01       	movw	r26, r24
    1878:	13 96       	adiw	r26, 0x03	; 3
    187a:	01 c0       	rjmp	.+2      	; 0x187e <vListInsert+0x22>
    187c:	df 01       	movw	r26, r30
    187e:	12 96       	adiw	r26, 0x02	; 2
    1880:	ed 91       	ld	r30, X+
    1882:	fc 91       	ld	r31, X
    1884:	13 97       	sbiw	r26, 0x03	; 3
    1886:	20 81       	ld	r18, Z
    1888:	31 81       	ldd	r19, Z+1	; 0x01
    188a:	42 17       	cp	r20, r18
    188c:	53 07       	cpc	r21, r19
    188e:	b0 f7       	brcc	.-20     	; 0x187c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1890:	12 96       	adiw	r26, 0x02	; 2
    1892:	ed 91       	ld	r30, X+
    1894:	fc 91       	ld	r31, X
    1896:	13 97       	sbiw	r26, 0x03	; 3
    1898:	ea 83       	std	Y+2, r30	; 0x02
    189a:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    189c:	c4 83       	std	Z+4, r28	; 0x04
    189e:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    18a0:	ac 83       	std	Y+4, r26	; 0x04
    18a2:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    18a4:	12 96       	adiw	r26, 0x02	; 2
    18a6:	cd 93       	st	X+, r28
    18a8:	dc 93       	st	X, r29
    18aa:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18ac:	88 87       	std	Y+8, r24	; 0x08
    18ae:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    18b0:	fc 01       	movw	r30, r24
    18b2:	20 81       	ld	r18, Z
    18b4:	2f 5f       	subi	r18, 0xFF	; 255
    18b6:	20 83       	st	Z, r18
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	08 95       	ret

000018be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    18c4:	a0 85       	ldd	r26, Z+8	; 0x08
    18c6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    18c8:	c2 81       	ldd	r28, Z+2	; 0x02
    18ca:	d3 81       	ldd	r29, Z+3	; 0x03
    18cc:	84 81       	ldd	r24, Z+4	; 0x04
    18ce:	95 81       	ldd	r25, Z+5	; 0x05
    18d0:	8c 83       	std	Y+4, r24	; 0x04
    18d2:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    18d4:	c4 81       	ldd	r28, Z+4	; 0x04
    18d6:	d5 81       	ldd	r29, Z+5	; 0x05
    18d8:	82 81       	ldd	r24, Z+2	; 0x02
    18da:	93 81       	ldd	r25, Z+3	; 0x03
    18dc:	8a 83       	std	Y+2, r24	; 0x02
    18de:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    18e0:	11 96       	adiw	r26, 0x01	; 1
    18e2:	8d 91       	ld	r24, X+
    18e4:	9c 91       	ld	r25, X
    18e6:	12 97       	sbiw	r26, 0x02	; 2
    18e8:	e8 17       	cp	r30, r24
    18ea:	f9 07       	cpc	r31, r25
    18ec:	31 f4       	brne	.+12     	; 0x18fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    18ee:	84 81       	ldd	r24, Z+4	; 0x04
    18f0:	95 81       	ldd	r25, Z+5	; 0x05
    18f2:	11 96       	adiw	r26, 0x01	; 1
    18f4:	8d 93       	st	X+, r24
    18f6:	9c 93       	st	X, r25
    18f8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    18fa:	10 86       	std	Z+8, r1	; 0x08
    18fc:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    18fe:	8c 91       	ld	r24, X
    1900:	81 50       	subi	r24, 0x01	; 1
    1902:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1904:	df 91       	pop	r29
    1906:	cf 91       	pop	r28
    1908:	08 95       	ret

0000190a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    190a:	0f 93       	push	r16
    190c:	1f 93       	push	r17
    190e:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1910:	71 e1       	ldi	r23, 0x11	; 17
    1912:	fc 01       	movw	r30, r24
    1914:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1916:	31 97       	sbiw	r30, 0x01	; 1
    1918:	62 e2       	ldi	r22, 0x22	; 34
    191a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    191c:	31 97       	sbiw	r30, 0x01	; 1
    191e:	23 e3       	ldi	r18, 0x33	; 51
    1920:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1922:	01 2e       	mov	r0, r17
    1924:	00 0c       	add	r0, r0
    1926:	22 0b       	sbc	r18, r18
    1928:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    192a:	31 97       	sbiw	r30, 0x01	; 1
    192c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    192e:	31 97       	sbiw	r30, 0x01	; 1
    1930:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1932:	31 97       	sbiw	r30, 0x01	; 1
    1934:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1936:	31 97       	sbiw	r30, 0x01	; 1
    1938:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    193a:	31 97       	sbiw	r30, 0x01	; 1
    193c:	20 e8       	ldi	r18, 0x80	; 128
    193e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1940:	31 97       	sbiw	r30, 0x01	; 1
    1942:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1944:	31 97       	sbiw	r30, 0x01	; 1
    1946:	22 e0       	ldi	r18, 0x02	; 2
    1948:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    194a:	31 97       	sbiw	r30, 0x01	; 1
    194c:	23 e0       	ldi	r18, 0x03	; 3
    194e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1950:	31 97       	sbiw	r30, 0x01	; 1
    1952:	24 e0       	ldi	r18, 0x04	; 4
    1954:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1956:	31 97       	sbiw	r30, 0x01	; 1
    1958:	25 e0       	ldi	r18, 0x05	; 5
    195a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    195c:	31 97       	sbiw	r30, 0x01	; 1
    195e:	26 e0       	ldi	r18, 0x06	; 6
    1960:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1962:	31 97       	sbiw	r30, 0x01	; 1
    1964:	27 e0       	ldi	r18, 0x07	; 7
    1966:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1968:	31 97       	sbiw	r30, 0x01	; 1
    196a:	28 e0       	ldi	r18, 0x08	; 8
    196c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    196e:	31 97       	sbiw	r30, 0x01	; 1
    1970:	29 e0       	ldi	r18, 0x09	; 9
    1972:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1974:	31 97       	sbiw	r30, 0x01	; 1
    1976:	20 e1       	ldi	r18, 0x10	; 16
    1978:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    197a:	31 97       	sbiw	r30, 0x01	; 1
    197c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    197e:	31 97       	sbiw	r30, 0x01	; 1
    1980:	22 e1       	ldi	r18, 0x12	; 18
    1982:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1984:	31 97       	sbiw	r30, 0x01	; 1
    1986:	23 e1       	ldi	r18, 0x13	; 19
    1988:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    198a:	31 97       	sbiw	r30, 0x01	; 1
    198c:	24 e1       	ldi	r18, 0x14	; 20
    198e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1990:	31 97       	sbiw	r30, 0x01	; 1
    1992:	25 e1       	ldi	r18, 0x15	; 21
    1994:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1996:	31 97       	sbiw	r30, 0x01	; 1
    1998:	26 e1       	ldi	r18, 0x16	; 22
    199a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    199c:	31 97       	sbiw	r30, 0x01	; 1
    199e:	27 e1       	ldi	r18, 0x17	; 23
    19a0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    19a2:	31 97       	sbiw	r30, 0x01	; 1
    19a4:	28 e1       	ldi	r18, 0x18	; 24
    19a6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    19a8:	31 97       	sbiw	r30, 0x01	; 1
    19aa:	29 e1       	ldi	r18, 0x19	; 25
    19ac:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    19ae:	31 97       	sbiw	r30, 0x01	; 1
    19b0:	20 e2       	ldi	r18, 0x20	; 32
    19b2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    19b4:	31 97       	sbiw	r30, 0x01	; 1
    19b6:	21 e2       	ldi	r18, 0x21	; 33
    19b8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    19ba:	31 97       	sbiw	r30, 0x01	; 1
    19bc:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    19be:	31 97       	sbiw	r30, 0x01	; 1
    19c0:	23 e2       	ldi	r18, 0x23	; 35
    19c2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    19c4:	31 97       	sbiw	r30, 0x01	; 1
    19c6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    19c8:	31 97       	sbiw	r30, 0x01	; 1
    19ca:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    19cc:	31 97       	sbiw	r30, 0x01	; 1
    19ce:	26 e2       	ldi	r18, 0x26	; 38
    19d0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    19d2:	31 97       	sbiw	r30, 0x01	; 1
    19d4:	27 e2       	ldi	r18, 0x27	; 39
    19d6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    19d8:	31 97       	sbiw	r30, 0x01	; 1
    19da:	28 e2       	ldi	r18, 0x28	; 40
    19dc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    19de:	31 97       	sbiw	r30, 0x01	; 1
    19e0:	29 e2       	ldi	r18, 0x29	; 41
    19e2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    19e4:	31 97       	sbiw	r30, 0x01	; 1
    19e6:	20 e3       	ldi	r18, 0x30	; 48
    19e8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    19ea:	31 97       	sbiw	r30, 0x01	; 1
    19ec:	21 e3       	ldi	r18, 0x31	; 49
    19ee:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    19f0:	87 97       	sbiw	r24, 0x27	; 39
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	08 95       	ret

000019f8 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    19f8:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    19fa:	e0 e7       	ldi	r30, 0x70	; 112
    19fc:	f0 e0       	ldi	r31, 0x00	; 0
    19fe:	83 81       	ldd	r24, Z+3	; 0x03
    1a00:	8a 7f       	andi	r24, 0xFA	; 250
    1a02:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1a04:	e0 e0       	ldi	r30, 0x00	; 0
    1a06:	f8 e0       	ldi	r31, 0x08	; 8
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	9a ef       	ldi	r25, 0xFA	; 250
    1a0c:	86 a3       	std	Z+38, r24	; 0x26
    1a0e:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1a10:	91 e0       	ldi	r25, 0x01	; 1
    1a12:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1a14:	a0 ea       	ldi	r26, 0xA0	; 160
    1a16:	b0 e0       	ldi	r27, 0x00	; 0
    1a18:	12 96       	adiw	r26, 0x02	; 2
    1a1a:	8c 91       	ld	r24, X
    1a1c:	12 97       	sbiw	r26, 0x02	; 2
    1a1e:	81 60       	ori	r24, 0x01	; 1
    1a20:	12 96       	adiw	r26, 0x02	; 2
    1a22:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1a24:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1a26:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1a28:	a0 91 b8 22 	lds	r26, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    1a2c:	b0 91 b9 22 	lds	r27, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    1a30:	0d 90       	ld	r0, X+
    1a32:	0d be       	out	0x3d, r0	; 61
    1a34:	0d 90       	ld	r0, X+
    1a36:	0e be       	out	0x3e, r0	; 62
    1a38:	ff 91       	pop	r31
    1a3a:	ef 91       	pop	r30
    1a3c:	df 91       	pop	r29
    1a3e:	cf 91       	pop	r28
    1a40:	bf 91       	pop	r27
    1a42:	af 91       	pop	r26
    1a44:	9f 91       	pop	r25
    1a46:	8f 91       	pop	r24
    1a48:	7f 91       	pop	r23
    1a4a:	6f 91       	pop	r22
    1a4c:	5f 91       	pop	r21
    1a4e:	4f 91       	pop	r20
    1a50:	3f 91       	pop	r19
    1a52:	2f 91       	pop	r18
    1a54:	1f 91       	pop	r17
    1a56:	0f 91       	pop	r16
    1a58:	ff 90       	pop	r15
    1a5a:	ef 90       	pop	r14
    1a5c:	df 90       	pop	r13
    1a5e:	cf 90       	pop	r12
    1a60:	bf 90       	pop	r11
    1a62:	af 90       	pop	r10
    1a64:	9f 90       	pop	r9
    1a66:	8f 90       	pop	r8
    1a68:	7f 90       	pop	r7
    1a6a:	6f 90       	pop	r6
    1a6c:	5f 90       	pop	r5
    1a6e:	4f 90       	pop	r4
    1a70:	3f 90       	pop	r3
    1a72:	2f 90       	pop	r2
    1a74:	1f 90       	pop	r1
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63
    1a7a:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1a7c:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
    1a80:	08 95       	ret

00001a82 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1a82:	0f 92       	push	r0
    1a84:	0f b6       	in	r0, 0x3f	; 63
    1a86:	f8 94       	cli
    1a88:	0f 92       	push	r0
    1a8a:	1f 92       	push	r1
    1a8c:	11 24       	eor	r1, r1
    1a8e:	2f 92       	push	r2
    1a90:	3f 92       	push	r3
    1a92:	4f 92       	push	r4
    1a94:	5f 92       	push	r5
    1a96:	6f 92       	push	r6
    1a98:	7f 92       	push	r7
    1a9a:	8f 92       	push	r8
    1a9c:	9f 92       	push	r9
    1a9e:	af 92       	push	r10
    1aa0:	bf 92       	push	r11
    1aa2:	cf 92       	push	r12
    1aa4:	df 92       	push	r13
    1aa6:	ef 92       	push	r14
    1aa8:	ff 92       	push	r15
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	2f 93       	push	r18
    1ab0:	3f 93       	push	r19
    1ab2:	4f 93       	push	r20
    1ab4:	5f 93       	push	r21
    1ab6:	6f 93       	push	r22
    1ab8:	7f 93       	push	r23
    1aba:	8f 93       	push	r24
    1abc:	9f 93       	push	r25
    1abe:	af 93       	push	r26
    1ac0:	bf 93       	push	r27
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	ef 93       	push	r30
    1ac8:	ff 93       	push	r31
    1aca:	a0 91 b8 22 	lds	r26, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    1ace:	b0 91 b9 22 	lds	r27, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    1ad2:	0d b6       	in	r0, 0x3d	; 61
    1ad4:	0d 92       	st	X+, r0
    1ad6:	0e b6       	in	r0, 0x3e	; 62
    vTaskSwitchContext();
    1ad8:	0d 92       	st	X+, r0
    portRESTORE_CONTEXT();
    1ada:	0e d6       	rcall	.+3100   	; 0x26f8 <vTaskSwitchContext>
    1adc:	a0 91 b8 22 	lds	r26, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    1ae0:	b0 91 b9 22 	lds	r27, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    1ae4:	0d 90       	ld	r0, X+
    1ae6:	0d be       	out	0x3d, r0	; 61
    1ae8:	0d 90       	ld	r0, X+
    1aea:	0e be       	out	0x3e, r0	; 62
    1aec:	ff 91       	pop	r31
    1aee:	ef 91       	pop	r30
    1af0:	df 91       	pop	r29
    1af2:	cf 91       	pop	r28
    1af4:	bf 91       	pop	r27
    1af6:	af 91       	pop	r26
    1af8:	9f 91       	pop	r25
    1afa:	8f 91       	pop	r24
    1afc:	7f 91       	pop	r23
    1afe:	6f 91       	pop	r22
    1b00:	5f 91       	pop	r21
    1b02:	4f 91       	pop	r20
    1b04:	3f 91       	pop	r19
    1b06:	2f 91       	pop	r18
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	ff 90       	pop	r15
    1b0e:	ef 90       	pop	r14
    1b10:	df 90       	pop	r13
    1b12:	cf 90       	pop	r12
    1b14:	bf 90       	pop	r11
    1b16:	af 90       	pop	r10
    1b18:	9f 90       	pop	r9
    1b1a:	8f 90       	pop	r8
    1b1c:	7f 90       	pop	r7
    1b1e:	6f 90       	pop	r6
    1b20:	5f 90       	pop	r5
    1b22:	4f 90       	pop	r4
    1b24:	3f 90       	pop	r3
    1b26:	2f 90       	pop	r2
    1b28:	1f 90       	pop	r1
    1b2a:	0f 90       	pop	r0
    1b2c:	0f be       	out	0x3f, r0	; 63

    asm volatile ( "ret" );
    1b2e:	0f 90       	pop	r0
    1b30:	08 95       	ret

00001b32 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1b32:	0f 92       	push	r0
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	0f 92       	push	r0
    1b3a:	1f 92       	push	r1
    1b3c:	11 24       	eor	r1, r1
    1b3e:	2f 92       	push	r2
    1b40:	3f 92       	push	r3
    1b42:	4f 92       	push	r4
    1b44:	5f 92       	push	r5
    1b46:	6f 92       	push	r6
    1b48:	7f 92       	push	r7
    1b4a:	8f 92       	push	r8
    1b4c:	9f 92       	push	r9
    1b4e:	af 92       	push	r10
    1b50:	bf 92       	push	r11
    1b52:	cf 92       	push	r12
    1b54:	df 92       	push	r13
    1b56:	ef 92       	push	r14
    1b58:	ff 92       	push	r15
    1b5a:	0f 93       	push	r16
    1b5c:	1f 93       	push	r17
    1b5e:	2f 93       	push	r18
    1b60:	3f 93       	push	r19
    1b62:	4f 93       	push	r20
    1b64:	5f 93       	push	r21
    1b66:	6f 93       	push	r22
    1b68:	7f 93       	push	r23
    1b6a:	8f 93       	push	r24
    1b6c:	9f 93       	push	r25
    1b6e:	af 93       	push	r26
    1b70:	bf 93       	push	r27
    1b72:	cf 93       	push	r28
    1b74:	df 93       	push	r29
    1b76:	ef 93       	push	r30
    1b78:	ff 93       	push	r31
    1b7a:	a0 91 b8 22 	lds	r26, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    1b7e:	b0 91 b9 22 	lds	r27, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    1b82:	0d b6       	in	r0, 0x3d	; 61
    1b84:	0d 92       	st	X+, r0
    1b86:	0e b6       	in	r0, 0x3e	; 62
        if( xTaskIncrementTick() != pdFALSE )
    1b88:	0d 92       	st	X+, r0
        {
            vTaskSwitchContext();
    1b8a:	4b d4       	rcall	.+2198   	; 0x2422 <xTaskIncrementTick>
    1b8c:	81 11       	cpse	r24, r1
        }
        portRESTORE_CONTEXT();
    1b8e:	b4 d5       	rcall	.+2920   	; 0x26f8 <vTaskSwitchContext>
    1b90:	a0 91 b8 22 	lds	r26, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    1b94:	b0 91 b9 22 	lds	r27, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    1b98:	0d 90       	ld	r0, X+
    1b9a:	0d be       	out	0x3d, r0	; 61
    1b9c:	0d 90       	ld	r0, X+
    1b9e:	0e be       	out	0x3e, r0	; 62
    1ba0:	ff 91       	pop	r31
    1ba2:	ef 91       	pop	r30
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	bf 91       	pop	r27
    1baa:	af 91       	pop	r26
    1bac:	9f 91       	pop	r25
    1bae:	8f 91       	pop	r24
    1bb0:	7f 91       	pop	r23
    1bb2:	6f 91       	pop	r22
    1bb4:	5f 91       	pop	r21
    1bb6:	4f 91       	pop	r20
    1bb8:	3f 91       	pop	r19
    1bba:	2f 91       	pop	r18
    1bbc:	1f 91       	pop	r17
    1bbe:	0f 91       	pop	r16
    1bc0:	ff 90       	pop	r15
    1bc2:	ef 90       	pop	r14
    1bc4:	df 90       	pop	r13
    1bc6:	cf 90       	pop	r12
    1bc8:	bf 90       	pop	r11
    1bca:	af 90       	pop	r10
    1bcc:	9f 90       	pop	r9
    1bce:	8f 90       	pop	r8
    1bd0:	7f 90       	pop	r7
    1bd2:	6f 90       	pop	r6
    1bd4:	5f 90       	pop	r5
    1bd6:	4f 90       	pop	r4
    1bd8:	3f 90       	pop	r3
    1bda:	2f 90       	pop	r2
    1bdc:	1f 90       	pop	r1
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63

        asm volatile ( "reti" );
    1be2:	0f 90       	pop	r0
    1be4:	18 95       	reti

00001be6 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1be6:	cf 93       	push	r28
    1be8:	df 93       	push	r29
void *pvReturn;

	vTaskSuspendAll();
    1bea:	ec 01       	movw	r28, r24
	{
		pvReturn = malloc( xWantedSize );
    1bec:	0a d4       	rcall	.+2068   	; 0x2402 <vTaskSuspendAll>
    1bee:	ce 01       	movw	r24, r28
    1bf0:	0e 94 42 1c 	call	0x3884	; 0x3884 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1bf4:	ec 01       	movw	r28, r24
		}
	}
	#endif

	return pvReturn;
}
    1bf6:	e8 d4       	rcall	.+2512   	; 0x25c8 <xTaskResumeAll>
    1bf8:	ce 01       	movw	r24, r28
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	08 95       	ret

00001c00 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1c00:	cf 93       	push	r28
    1c02:	df 93       	push	r29
	if( pv )
    1c04:	00 97       	sbiw	r24, 0x00	; 0
    1c06:	31 f0       	breq	.+12     	; 0x1c14 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    1c08:	ec 01       	movw	r28, r24
		{
			free( pv );
    1c0a:	fb d3       	rcall	.+2038   	; 0x2402 <vTaskSuspendAll>
    1c0c:	ce 01       	movw	r24, r28
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    1c0e:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <free>
	}
}
    1c12:	da d4       	rcall	.+2484   	; 0x25c8 <xTaskResumeAll>
    1c14:	df 91       	pop	r29
    1c16:	cf 91       	pop	r28
    1c18:	08 95       	ret

00001c1a <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	ec 01       	movw	r28, r24
    1c22:	14 2f       	mov	r17, r20
    1c24:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c26:	44 23       	and	r20, r20
    1c28:	d9 f1       	breq	.+118    	; 0x1ca0 <prvCopyDataToQueue+0x86>
    1c2a:	11 11       	cpse	r17, r1
    1c2c:	16 c0       	rjmp	.+44     	; 0x1c5a <prvCopyDataToQueue+0x40>
    1c2e:	50 e0       	ldi	r21, 0x00	; 0
    1c30:	8c 81       	ldd	r24, Y+4	; 0x04
    1c32:	9d 81       	ldd	r25, Y+5	; 0x05
    1c34:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <memcpy>
    1c38:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3e:	82 0f       	add	r24, r18
    1c40:	91 1d       	adc	r25, r1
    1c42:	8c 83       	std	Y+4, r24	; 0x04
    1c44:	9d 83       	std	Y+5, r25	; 0x05
    1c46:	2a 81       	ldd	r18, Y+2	; 0x02
    1c48:	3b 81       	ldd	r19, Y+3	; 0x03
    1c4a:	82 17       	cp	r24, r18
    1c4c:	93 07       	cpc	r25, r19
    1c4e:	40 f1       	brcs	.+80     	; 0x1ca0 <prvCopyDataToQueue+0x86>
    1c50:	88 81       	ld	r24, Y
    1c52:	99 81       	ldd	r25, Y+1	; 0x01
    1c54:	8c 83       	std	Y+4, r24	; 0x04
    1c56:	9d 83       	std	Y+5, r25	; 0x05
    1c58:	23 c0       	rjmp	.+70     	; 0x1ca0 <prvCopyDataToQueue+0x86>
    1c5a:	50 e0       	ldi	r21, 0x00	; 0
    1c5c:	8e 81       	ldd	r24, Y+6	; 0x06
    1c5e:	9f 81       	ldd	r25, Y+7	; 0x07
    1c60:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <memcpy>
    1c64:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	91 95       	neg	r25
    1c6a:	81 95       	neg	r24
    1c6c:	91 09       	sbc	r25, r1
    1c6e:	2e 81       	ldd	r18, Y+6	; 0x06
    1c70:	3f 81       	ldd	r19, Y+7	; 0x07
    1c72:	28 0f       	add	r18, r24
    1c74:	39 1f       	adc	r19, r25
    1c76:	2e 83       	std	Y+6, r18	; 0x06
    1c78:	3f 83       	std	Y+7, r19	; 0x07
    1c7a:	48 81       	ld	r20, Y
    1c7c:	59 81       	ldd	r21, Y+1	; 0x01
    1c7e:	24 17       	cp	r18, r20
    1c80:	35 07       	cpc	r19, r21
    1c82:	30 f4       	brcc	.+12     	; 0x1c90 <prvCopyDataToQueue+0x76>
    1c84:	2a 81       	ldd	r18, Y+2	; 0x02
    1c86:	3b 81       	ldd	r19, Y+3	; 0x03
    1c88:	82 0f       	add	r24, r18
    1c8a:	93 1f       	adc	r25, r19
    1c8c:	8e 83       	std	Y+6, r24	; 0x06
    1c8e:	9f 83       	std	Y+7, r25	; 0x07
    1c90:	12 30       	cpi	r17, 0x02	; 2
    1c92:	31 f4       	brne	.+12     	; 0x1ca0 <prvCopyDataToQueue+0x86>
    1c94:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c96:	88 23       	and	r24, r24
    1c98:	19 f0       	breq	.+6      	; 0x1ca0 <prvCopyDataToQueue+0x86>
    1c9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c9c:	81 50       	subi	r24, 0x01	; 1
    1c9e:	8a 8f       	std	Y+26, r24	; 0x1a
    1ca0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ca2:	8f 5f       	subi	r24, 0xFF	; 255
    1ca4:	8a 8f       	std	Y+26, r24	; 0x1a
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	1f 91       	pop	r17
    1cae:	08 95       	ret

00001cb0 <prvCopyDataFromQueue>:
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	44 8d       	ldd	r20, Z+28	; 0x1c
    1cb4:	44 23       	and	r20, r20
    1cb6:	a9 f0       	breq	.+42     	; 0x1ce2 <prvCopyDataFromQueue+0x32>
    1cb8:	50 e0       	ldi	r21, 0x00	; 0
    1cba:	26 81       	ldd	r18, Z+6	; 0x06
    1cbc:	37 81       	ldd	r19, Z+7	; 0x07
    1cbe:	24 0f       	add	r18, r20
    1cc0:	35 1f       	adc	r19, r21
    1cc2:	26 83       	std	Z+6, r18	; 0x06
    1cc4:	37 83       	std	Z+7, r19	; 0x07
    1cc6:	82 81       	ldd	r24, Z+2	; 0x02
    1cc8:	93 81       	ldd	r25, Z+3	; 0x03
    1cca:	28 17       	cp	r18, r24
    1ccc:	39 07       	cpc	r19, r25
    1cce:	20 f0       	brcs	.+8      	; 0x1cd8 <prvCopyDataFromQueue+0x28>
    1cd0:	80 81       	ld	r24, Z
    1cd2:	91 81       	ldd	r25, Z+1	; 0x01
    1cd4:	86 83       	std	Z+6, r24	; 0x06
    1cd6:	97 83       	std	Z+7, r25	; 0x07
    1cd8:	cb 01       	movw	r24, r22
    1cda:	66 81       	ldd	r22, Z+6	; 0x06
    1cdc:	77 81       	ldd	r23, Z+7	; 0x07
    1cde:	0c 94 63 1d 	jmp	0x3ac6	; 0x3ac6 <memcpy>
    1ce2:	08 95       	ret

00001ce4 <prvUnlockQueue>:
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
    1cec:	ec 01       	movw	r28, r24
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	0f 92       	push	r0
    1cf4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1cf6:	18 16       	cp	r1, r24
    1cf8:	ac f4       	brge	.+42     	; 0x1d24 <prvUnlockQueue+0x40>
    1cfa:	89 89       	ldd	r24, Y+17	; 0x11
    1cfc:	81 11       	cpse	r24, r1
    1cfe:	05 c0       	rjmp	.+10     	; 0x1d0a <prvUnlockQueue+0x26>
    1d00:	11 c0       	rjmp	.+34     	; 0x1d24 <prvUnlockQueue+0x40>
    1d02:	89 89       	ldd	r24, Y+17	; 0x11
    1d04:	81 11       	cpse	r24, r1
    1d06:	04 c0       	rjmp	.+8      	; 0x1d10 <prvUnlockQueue+0x2c>
    1d08:	0d c0       	rjmp	.+26     	; 0x1d24 <prvUnlockQueue+0x40>
    1d0a:	8e 01       	movw	r16, r28
    1d0c:	0f 5e       	subi	r16, 0xEF	; 239
    1d0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d10:	c8 01       	movw	r24, r16
    1d12:	93 d5       	rcall	.+2854   	; 0x283a <xTaskRemoveFromEventList>
    1d14:	81 11       	cpse	r24, r1
    1d16:	13 d6       	rcall	.+3110   	; 0x293e <vTaskMissedYield>
    1d18:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d1a:	81 50       	subi	r24, 0x01	; 1
    1d1c:	8e 8f       	std	Y+30, r24	; 0x1e
    1d1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d20:	18 16       	cp	r1, r24
    1d22:	7c f3       	brlt	.-34     	; 0x1d02 <prvUnlockQueue+0x1e>
    1d24:	8f ef       	ldi	r24, 0xFF	; 255
    1d26:	8e 8f       	std	Y+30, r24	; 0x1e
    1d28:	0f 90       	pop	r0
    1d2a:	0f be       	out	0x3f, r0	; 63
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	0f 92       	push	r0
    1d32:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d34:	18 16       	cp	r1, r24
    1d36:	ac f4       	brge	.+42     	; 0x1d62 <prvUnlockQueue+0x7e>
    1d38:	88 85       	ldd	r24, Y+8	; 0x08
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <prvUnlockQueue+0x64>
    1d3e:	11 c0       	rjmp	.+34     	; 0x1d62 <prvUnlockQueue+0x7e>
    1d40:	88 85       	ldd	r24, Y+8	; 0x08
    1d42:	81 11       	cpse	r24, r1
    1d44:	04 c0       	rjmp	.+8      	; 0x1d4e <prvUnlockQueue+0x6a>
    1d46:	0d c0       	rjmp	.+26     	; 0x1d62 <prvUnlockQueue+0x7e>
    1d48:	8e 01       	movw	r16, r28
    1d4a:	08 5f       	subi	r16, 0xF8	; 248
    1d4c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d4e:	c8 01       	movw	r24, r16
    1d50:	74 d5       	rcall	.+2792   	; 0x283a <xTaskRemoveFromEventList>
    1d52:	81 11       	cpse	r24, r1
    1d54:	f4 d5       	rcall	.+3048   	; 0x293e <vTaskMissedYield>
    1d56:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d58:	81 50       	subi	r24, 0x01	; 1
    1d5a:	8d 8f       	std	Y+29, r24	; 0x1d
    1d5c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d5e:	18 16       	cp	r1, r24
    1d60:	7c f3       	brlt	.-34     	; 0x1d40 <prvUnlockQueue+0x5c>
    1d62:	8f ef       	ldi	r24, 0xFF	; 255
    1d64:	8d 8f       	std	Y+29, r24	; 0x1d
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <xQueueGenericReset>:
    1d74:	cf 93       	push	r28
    1d76:	df 93       	push	r29
    1d78:	ec 01       	movw	r28, r24
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	0f 92       	push	r0
    1d80:	48 81       	ld	r20, Y
    1d82:	59 81       	ldd	r21, Y+1	; 0x01
    1d84:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d86:	30 e0       	ldi	r19, 0x00	; 0
    1d88:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1d8a:	72 9f       	mul	r23, r18
    1d8c:	c0 01       	movw	r24, r0
    1d8e:	73 9f       	mul	r23, r19
    1d90:	90 0d       	add	r25, r0
    1d92:	11 24       	eor	r1, r1
    1d94:	fa 01       	movw	r30, r20
    1d96:	e8 0f       	add	r30, r24
    1d98:	f9 1f       	adc	r31, r25
    1d9a:	ea 83       	std	Y+2, r30	; 0x02
    1d9c:	fb 83       	std	Y+3, r31	; 0x03
    1d9e:	1a 8e       	std	Y+26, r1	; 0x1a
    1da0:	4c 83       	std	Y+4, r20	; 0x04
    1da2:	5d 83       	std	Y+5, r21	; 0x05
    1da4:	82 1b       	sub	r24, r18
    1da6:	93 0b       	sbc	r25, r19
    1da8:	84 0f       	add	r24, r20
    1daa:	95 1f       	adc	r25, r21
    1dac:	8e 83       	std	Y+6, r24	; 0x06
    1dae:	9f 83       	std	Y+7, r25	; 0x07
    1db0:	8f ef       	ldi	r24, 0xFF	; 255
    1db2:	8d 8f       	std	Y+29, r24	; 0x1d
    1db4:	8e 8f       	std	Y+30, r24	; 0x1e
    1db6:	61 11       	cpse	r22, r1
    1db8:	0a c0       	rjmp	.+20     	; 0x1dce <xQueueGenericReset+0x5a>
    1dba:	88 85       	ldd	r24, Y+8	; 0x08
    1dbc:	88 23       	and	r24, r24
    1dbe:	69 f0       	breq	.+26     	; 0x1dda <xQueueGenericReset+0x66>
    1dc0:	ce 01       	movw	r24, r28
    1dc2:	08 96       	adiw	r24, 0x08	; 8
    1dc4:	3a d5       	rcall	.+2676   	; 0x283a <xTaskRemoveFromEventList>
    1dc6:	81 30       	cpi	r24, 0x01	; 1
    1dc8:	41 f4       	brne	.+16     	; 0x1dda <xQueueGenericReset+0x66>
    1dca:	5b de       	rcall	.-842    	; 0x1a82 <vPortYield>
    1dcc:	06 c0       	rjmp	.+12     	; 0x1dda <xQueueGenericReset+0x66>
    1dce:	ce 01       	movw	r24, r28
    1dd0:	08 96       	adiw	r24, 0x08	; 8
    1dd2:	11 dd       	rcall	.-1502   	; 0x17f6 <vListInitialise>
    1dd4:	ce 01       	movw	r24, r28
    1dd6:	41 96       	adiw	r24, 0x11	; 17
    1dd8:	0e dd       	rcall	.-1508   	; 0x17f6 <vListInitialise>
    1dda:	0f 90       	pop	r0
    1ddc:	0f be       	out	0x3f, r0	; 63
    1dde:	81 e0       	ldi	r24, 0x01	; 1
    1de0:	df 91       	pop	r29
    1de2:	cf 91       	pop	r28
    1de4:	08 95       	ret

00001de6 <xQueueGenericCreate>:
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
    1dee:	08 2f       	mov	r16, r24
    1df0:	16 2f       	mov	r17, r22
    1df2:	66 23       	and	r22, r22
    1df4:	a9 f0       	breq	.+42     	; 0x1e20 <xQueueGenericCreate+0x3a>
    1df6:	86 9f       	mul	r24, r22
    1df8:	c0 01       	movw	r24, r0
    1dfa:	11 24       	eor	r1, r1
    1dfc:	80 96       	adiw	r24, 0x20	; 32
    1dfe:	f3 de       	rcall	.-538    	; 0x1be6 <pvPortMalloc>
    1e00:	ec 01       	movw	r28, r24
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	21 f4       	brne	.+8      	; 0x1e0e <xQueueGenericCreate+0x28>
    1e06:	12 c0       	rjmp	.+36     	; 0x1e2c <xQueueGenericCreate+0x46>
    1e08:	c8 83       	st	Y, r28
    1e0a:	d9 83       	std	Y+1, r29	; 0x01
    1e0c:	03 c0       	rjmp	.+6      	; 0x1e14 <xQueueGenericCreate+0x2e>
    1e0e:	4f 96       	adiw	r24, 0x1f	; 31
    1e10:	88 83       	st	Y, r24
    1e12:	99 83       	std	Y+1, r25	; 0x01
    1e14:	0b 8f       	std	Y+27, r16	; 0x1b
    1e16:	1c 8f       	std	Y+28, r17	; 0x1c
    1e18:	61 e0       	ldi	r22, 0x01	; 1
    1e1a:	ce 01       	movw	r24, r28
    1e1c:	ab df       	rcall	.-170    	; 0x1d74 <xQueueGenericReset>
    1e1e:	06 c0       	rjmp	.+12     	; 0x1e2c <xQueueGenericCreate+0x46>
    1e20:	8f e1       	ldi	r24, 0x1F	; 31
    1e22:	90 e0       	ldi	r25, 0x00	; 0
    1e24:	e0 de       	rcall	.-576    	; 0x1be6 <pvPortMalloc>
    1e26:	ec 01       	movw	r28, r24
    1e28:	89 2b       	or	r24, r25
    1e2a:	71 f7       	brne	.-36     	; 0x1e08 <xQueueGenericCreate+0x22>
    1e2c:	ce 01       	movw	r24, r28
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16
    1e36:	08 95       	ret

00001e38 <xQueueGenericSend>:
    1e38:	af 92       	push	r10
    1e3a:	bf 92       	push	r11
    1e3c:	cf 92       	push	r12
    1e3e:	df 92       	push	r13
    1e40:	ef 92       	push	r14
    1e42:	ff 92       	push	r15
    1e44:	0f 93       	push	r16
    1e46:	1f 93       	push	r17
    1e48:	cf 93       	push	r28
    1e4a:	df 93       	push	r29
    1e4c:	cd b7       	in	r28, 0x3d	; 61
    1e4e:	de b7       	in	r29, 0x3e	; 62
    1e50:	25 97       	sbiw	r28, 0x05	; 5
    1e52:	cd bf       	out	0x3d, r28	; 61
    1e54:	de bf       	out	0x3e, r29	; 62
    1e56:	8c 01       	movw	r16, r24
    1e58:	6b 01       	movw	r12, r22
    1e5a:	4c 83       	std	Y+4, r20	; 0x04
    1e5c:	5d 83       	std	Y+5, r21	; 0x05
    1e5e:	a2 2e       	mov	r10, r18
    1e60:	b1 2c       	mov	r11, r1
    1e62:	7c 01       	movw	r14, r24
    1e64:	88 e0       	ldi	r24, 0x08	; 8
    1e66:	e8 0e       	add	r14, r24
    1e68:	f1 1c       	adc	r15, r1
    1e6a:	0f b6       	in	r0, 0x3f	; 63
    1e6c:	f8 94       	cli
    1e6e:	0f 92       	push	r0
    1e70:	f8 01       	movw	r30, r16
    1e72:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e74:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e76:	98 17       	cp	r25, r24
    1e78:	18 f0       	brcs	.+6      	; 0x1e80 <xQueueGenericSend+0x48>
    1e7a:	f2 e0       	ldi	r31, 0x02	; 2
    1e7c:	af 12       	cpse	r10, r31
    1e7e:	15 c0       	rjmp	.+42     	; 0x1eaa <xQueueGenericSend+0x72>
    1e80:	4a 2d       	mov	r20, r10
    1e82:	b6 01       	movw	r22, r12
    1e84:	c8 01       	movw	r24, r16
    1e86:	c9 de       	rcall	.-622    	; 0x1c1a <prvCopyDataToQueue>
    1e88:	f8 01       	movw	r30, r16
    1e8a:	91 89       	ldd	r25, Z+17	; 0x11
    1e8c:	99 23       	and	r25, r25
    1e8e:	39 f0       	breq	.+14     	; 0x1e9e <xQueueGenericSend+0x66>
    1e90:	c8 01       	movw	r24, r16
    1e92:	41 96       	adiw	r24, 0x11	; 17
    1e94:	d2 d4       	rcall	.+2468   	; 0x283a <xTaskRemoveFromEventList>
    1e96:	81 30       	cpi	r24, 0x01	; 1
    1e98:	21 f4       	brne	.+8      	; 0x1ea2 <xQueueGenericSend+0x6a>
    1e9a:	f3 dd       	rcall	.-1050   	; 0x1a82 <vPortYield>
    1e9c:	02 c0       	rjmp	.+4      	; 0x1ea2 <xQueueGenericSend+0x6a>
    1e9e:	81 11       	cpse	r24, r1
    1ea0:	f0 dd       	rcall	.-1056   	; 0x1a82 <vPortYield>
    1ea2:	0f 90       	pop	r0
    1ea4:	0f be       	out	0x3f, r0	; 63
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	46 c0       	rjmp	.+140    	; 0x1f36 <xQueueGenericSend+0xfe>
    1eaa:	8c 81       	ldd	r24, Y+4	; 0x04
    1eac:	9d 81       	ldd	r25, Y+5	; 0x05
    1eae:	89 2b       	or	r24, r25
    1eb0:	21 f4       	brne	.+8      	; 0x1eba <xQueueGenericSend+0x82>
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
    1eb6:	80 e0       	ldi	r24, 0x00	; 0
    1eb8:	3e c0       	rjmp	.+124    	; 0x1f36 <xQueueGenericSend+0xfe>
    1eba:	b1 10       	cpse	r11, r1
    1ebc:	05 c0       	rjmp	.+10     	; 0x1ec8 <xQueueGenericSend+0x90>
    1ebe:	ce 01       	movw	r24, r28
    1ec0:	01 96       	adiw	r24, 0x01	; 1
    1ec2:	01 d5       	rcall	.+2562   	; 0x28c6 <vTaskSetTimeOutState>
    1ec4:	bb 24       	eor	r11, r11
    1ec6:	b3 94       	inc	r11
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63
    1ecc:	9a d2       	rcall	.+1332   	; 0x2402 <vTaskSuspendAll>
    1ece:	0f b6       	in	r0, 0x3f	; 63
    1ed0:	f8 94       	cli
    1ed2:	0f 92       	push	r0
    1ed4:	f8 01       	movw	r30, r16
    1ed6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ed8:	8f 3f       	cpi	r24, 0xFF	; 255
    1eda:	09 f4       	brne	.+2      	; 0x1ede <xQueueGenericSend+0xa6>
    1edc:	15 8e       	std	Z+29, r1	; 0x1d
    1ede:	f8 01       	movw	r30, r16
    1ee0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ee2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ee4:	09 f4       	brne	.+2      	; 0x1ee8 <xQueueGenericSend+0xb0>
    1ee6:	16 8e       	std	Z+30, r1	; 0x1e
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	be 01       	movw	r22, r28
    1eee:	6c 5f       	subi	r22, 0xFC	; 252
    1ef0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ef2:	ce 01       	movw	r24, r28
    1ef4:	01 96       	adiw	r24, 0x01	; 1
    1ef6:	f2 d4       	rcall	.+2532   	; 0x28dc <xTaskCheckForTimeOut>
    1ef8:	81 11       	cpse	r24, r1
    1efa:	19 c0       	rjmp	.+50     	; 0x1f2e <xQueueGenericSend+0xf6>
    1efc:	0f b6       	in	r0, 0x3f	; 63
    1efe:	f8 94       	cli
    1f00:	0f 92       	push	r0
    1f02:	f8 01       	movw	r30, r16
    1f04:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f06:	0f 90       	pop	r0
    1f08:	0f be       	out	0x3f, r0	; 63
    1f0a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f0c:	98 13       	cpse	r25, r24
    1f0e:	0b c0       	rjmp	.+22     	; 0x1f26 <xQueueGenericSend+0xee>
    1f10:	6c 81       	ldd	r22, Y+4	; 0x04
    1f12:	7d 81       	ldd	r23, Y+5	; 0x05
    1f14:	c7 01       	movw	r24, r14
    1f16:	5d d4       	rcall	.+2234   	; 0x27d2 <vTaskPlaceOnEventList>
    1f18:	c8 01       	movw	r24, r16
    1f1a:	e4 de       	rcall	.-568    	; 0x1ce4 <prvUnlockQueue>
    1f1c:	55 d3       	rcall	.+1706   	; 0x25c8 <xTaskResumeAll>
    1f1e:	81 11       	cpse	r24, r1
    1f20:	a4 cf       	rjmp	.-184    	; 0x1e6a <xQueueGenericSend+0x32>
    1f22:	af dd       	rcall	.-1186   	; 0x1a82 <vPortYield>
    1f24:	a2 cf       	rjmp	.-188    	; 0x1e6a <xQueueGenericSend+0x32>
    1f26:	c8 01       	movw	r24, r16
    1f28:	dd de       	rcall	.-582    	; 0x1ce4 <prvUnlockQueue>
    1f2a:	4e d3       	rcall	.+1692   	; 0x25c8 <xTaskResumeAll>
    1f2c:	9e cf       	rjmp	.-196    	; 0x1e6a <xQueueGenericSend+0x32>
    1f2e:	c8 01       	movw	r24, r16
    1f30:	d9 de       	rcall	.-590    	; 0x1ce4 <prvUnlockQueue>
    1f32:	4a d3       	rcall	.+1684   	; 0x25c8 <xTaskResumeAll>
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	25 96       	adiw	r28, 0x05	; 5
    1f38:	cd bf       	out	0x3d, r28	; 61
    1f3a:	de bf       	out	0x3e, r29	; 62
    1f3c:	df 91       	pop	r29
    1f3e:	cf 91       	pop	r28
    1f40:	1f 91       	pop	r17
    1f42:	0f 91       	pop	r16
    1f44:	ff 90       	pop	r15
    1f46:	ef 90       	pop	r14
    1f48:	df 90       	pop	r13
    1f4a:	cf 90       	pop	r12
    1f4c:	bf 90       	pop	r11
    1f4e:	af 90       	pop	r10
    1f50:	08 95       	ret

00001f52 <xQueueGenericSendFromISR>:
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	fa 01       	movw	r30, r20
    1f5c:	dc 01       	movw	r26, r24
    1f5e:	5a 96       	adiw	r26, 0x1a	; 26
    1f60:	5c 91       	ld	r21, X
    1f62:	5a 97       	sbiw	r26, 0x1a	; 26
    1f64:	5b 96       	adiw	r26, 0x1b	; 27
    1f66:	3c 91       	ld	r19, X
    1f68:	53 17       	cp	r21, r19
    1f6a:	10 f0       	brcs	.+4      	; 0x1f70 <xQueueGenericSendFromISR+0x1e>
    1f6c:	22 30       	cpi	r18, 0x02	; 2
    1f6e:	d9 f4       	brne	.+54     	; 0x1fa6 <xQueueGenericSendFromISR+0x54>
    1f70:	42 2f       	mov	r20, r18
    1f72:	8f 01       	movw	r16, r30
    1f74:	ec 01       	movw	r28, r24
    1f76:	51 de       	rcall	.-862    	; 0x1c1a <prvCopyDataToQueue>
    1f78:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f7c:	79 f4       	brne	.+30     	; 0x1f9c <xQueueGenericSendFromISR+0x4a>
    1f7e:	89 89       	ldd	r24, Y+17	; 0x11
    1f80:	88 23       	and	r24, r24
    1f82:	99 f0       	breq	.+38     	; 0x1faa <xQueueGenericSendFromISR+0x58>
    1f84:	ce 01       	movw	r24, r28
    1f86:	41 96       	adiw	r24, 0x11	; 17
    1f88:	58 d4       	rcall	.+2224   	; 0x283a <xTaskRemoveFromEventList>
    1f8a:	88 23       	and	r24, r24
    1f8c:	81 f0       	breq	.+32     	; 0x1fae <xQueueGenericSendFromISR+0x5c>
    1f8e:	01 15       	cp	r16, r1
    1f90:	11 05       	cpc	r17, r1
    1f92:	79 f0       	breq	.+30     	; 0x1fb2 <xQueueGenericSendFromISR+0x60>
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	f8 01       	movw	r30, r16
    1f98:	80 83       	st	Z, r24
    1f9a:	0c c0       	rjmp	.+24     	; 0x1fb4 <xQueueGenericSendFromISR+0x62>
    1f9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f9e:	8f 5f       	subi	r24, 0xFF	; 255
    1fa0:	8e 8f       	std	Y+30, r24	; 0x1e
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	07 c0       	rjmp	.+14     	; 0x1fb4 <xQueueGenericSendFromISR+0x62>
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	05 c0       	rjmp	.+10     	; 0x1fb4 <xQueueGenericSendFromISR+0x62>
    1faa:	81 e0       	ldi	r24, 0x01	; 1
    1fac:	03 c0       	rjmp	.+6      	; 0x1fb4 <xQueueGenericSendFromISR+0x62>
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	01 c0       	rjmp	.+2      	; 0x1fb4 <xQueueGenericSendFromISR+0x62>
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	1f 91       	pop	r17
    1fba:	0f 91       	pop	r16
    1fbc:	08 95       	ret

00001fbe <xQueueGenericReceive>:
    1fbe:	af 92       	push	r10
    1fc0:	bf 92       	push	r11
    1fc2:	cf 92       	push	r12
    1fc4:	df 92       	push	r13
    1fc6:	ef 92       	push	r14
    1fc8:	ff 92       	push	r15
    1fca:	0f 93       	push	r16
    1fcc:	1f 93       	push	r17
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
    1fd2:	cd b7       	in	r28, 0x3d	; 61
    1fd4:	de b7       	in	r29, 0x3e	; 62
    1fd6:	25 97       	sbiw	r28, 0x05	; 5
    1fd8:	cd bf       	out	0x3d, r28	; 61
    1fda:	de bf       	out	0x3e, r29	; 62
    1fdc:	8c 01       	movw	r16, r24
    1fde:	6b 01       	movw	r12, r22
    1fe0:	4c 83       	std	Y+4, r20	; 0x04
    1fe2:	5d 83       	std	Y+5, r21	; 0x05
    1fe4:	a2 2e       	mov	r10, r18
    1fe6:	b1 2c       	mov	r11, r1
    1fe8:	7c 01       	movw	r14, r24
    1fea:	81 e1       	ldi	r24, 0x11	; 17
    1fec:	e8 0e       	add	r14, r24
    1fee:	f1 1c       	adc	r15, r1
    1ff0:	0f b6       	in	r0, 0x3f	; 63
    1ff2:	f8 94       	cli
    1ff4:	0f 92       	push	r0
    1ff6:	f8 01       	movw	r30, r16
    1ff8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ffa:	88 23       	and	r24, r24
    1ffc:	21 f1       	breq	.+72     	; 0x2046 <xQueueGenericReceive+0x88>
    1ffe:	e6 80       	ldd	r14, Z+6	; 0x06
    2000:	f7 80       	ldd	r15, Z+7	; 0x07
    2002:	b6 01       	movw	r22, r12
    2004:	c8 01       	movw	r24, r16
    2006:	54 de       	rcall	.-856    	; 0x1cb0 <prvCopyDataFromQueue>
    2008:	a1 10       	cpse	r10, r1
    200a:	0e c0       	rjmp	.+28     	; 0x2028 <xQueueGenericReceive+0x6a>
    200c:	f8 01       	movw	r30, r16
    200e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2010:	81 50       	subi	r24, 0x01	; 1
    2012:	82 8f       	std	Z+26, r24	; 0x1a
    2014:	80 85       	ldd	r24, Z+8	; 0x08
    2016:	88 23       	and	r24, r24
    2018:	91 f0       	breq	.+36     	; 0x203e <xQueueGenericReceive+0x80>
    201a:	c8 01       	movw	r24, r16
    201c:	08 96       	adiw	r24, 0x08	; 8
    201e:	0d d4       	rcall	.+2074   	; 0x283a <xTaskRemoveFromEventList>
    2020:	81 30       	cpi	r24, 0x01	; 1
    2022:	69 f4       	brne	.+26     	; 0x203e <xQueueGenericReceive+0x80>
    2024:	2e dd       	rcall	.-1444   	; 0x1a82 <vPortYield>
    2026:	0b c0       	rjmp	.+22     	; 0x203e <xQueueGenericReceive+0x80>
    2028:	f8 01       	movw	r30, r16
    202a:	e6 82       	std	Z+6, r14	; 0x06
    202c:	f7 82       	std	Z+7, r15	; 0x07
    202e:	81 89       	ldd	r24, Z+17	; 0x11
    2030:	88 23       	and	r24, r24
    2032:	29 f0       	breq	.+10     	; 0x203e <xQueueGenericReceive+0x80>
    2034:	c8 01       	movw	r24, r16
    2036:	41 96       	adiw	r24, 0x11	; 17
    2038:	00 d4       	rcall	.+2048   	; 0x283a <xTaskRemoveFromEventList>
    203a:	81 11       	cpse	r24, r1
    203c:	22 dd       	rcall	.-1468   	; 0x1a82 <vPortYield>
    203e:	0f 90       	pop	r0
    2040:	0f be       	out	0x3f, r0	; 63
    2042:	81 e0       	ldi	r24, 0x01	; 1
    2044:	45 c0       	rjmp	.+138    	; 0x20d0 <xQueueGenericReceive+0x112>
    2046:	8c 81       	ldd	r24, Y+4	; 0x04
    2048:	9d 81       	ldd	r25, Y+5	; 0x05
    204a:	89 2b       	or	r24, r25
    204c:	21 f4       	brne	.+8      	; 0x2056 <xQueueGenericReceive+0x98>
    204e:	0f 90       	pop	r0
    2050:	0f be       	out	0x3f, r0	; 63
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	3d c0       	rjmp	.+122    	; 0x20d0 <xQueueGenericReceive+0x112>
    2056:	b1 10       	cpse	r11, r1
    2058:	05 c0       	rjmp	.+10     	; 0x2064 <xQueueGenericReceive+0xa6>
    205a:	ce 01       	movw	r24, r28
    205c:	01 96       	adiw	r24, 0x01	; 1
    205e:	33 d4       	rcall	.+2150   	; 0x28c6 <vTaskSetTimeOutState>
    2060:	bb 24       	eor	r11, r11
    2062:	b3 94       	inc	r11
    2064:	0f 90       	pop	r0
    2066:	0f be       	out	0x3f, r0	; 63
    2068:	cc d1       	rcall	.+920    	; 0x2402 <vTaskSuspendAll>
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	0f 92       	push	r0
    2070:	f8 01       	movw	r30, r16
    2072:	85 8d       	ldd	r24, Z+29	; 0x1d
    2074:	8f 3f       	cpi	r24, 0xFF	; 255
    2076:	09 f4       	brne	.+2      	; 0x207a <xQueueGenericReceive+0xbc>
    2078:	15 8e       	std	Z+29, r1	; 0x1d
    207a:	f8 01       	movw	r30, r16
    207c:	86 8d       	ldd	r24, Z+30	; 0x1e
    207e:	8f 3f       	cpi	r24, 0xFF	; 255
    2080:	09 f4       	brne	.+2      	; 0x2084 <xQueueGenericReceive+0xc6>
    2082:	16 8e       	std	Z+30, r1	; 0x1e
    2084:	0f 90       	pop	r0
    2086:	0f be       	out	0x3f, r0	; 63
    2088:	be 01       	movw	r22, r28
    208a:	6c 5f       	subi	r22, 0xFC	; 252
    208c:	7f 4f       	sbci	r23, 0xFF	; 255
    208e:	ce 01       	movw	r24, r28
    2090:	01 96       	adiw	r24, 0x01	; 1
    2092:	24 d4       	rcall	.+2120   	; 0x28dc <xTaskCheckForTimeOut>
    2094:	81 11       	cpse	r24, r1
    2096:	18 c0       	rjmp	.+48     	; 0x20c8 <xQueueGenericReceive+0x10a>
    2098:	0f b6       	in	r0, 0x3f	; 63
    209a:	f8 94       	cli
    209c:	0f 92       	push	r0
    209e:	f8 01       	movw	r30, r16
    20a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a2:	0f 90       	pop	r0
    20a4:	0f be       	out	0x3f, r0	; 63
    20a6:	81 11       	cpse	r24, r1
    20a8:	0b c0       	rjmp	.+22     	; 0x20c0 <xQueueGenericReceive+0x102>
    20aa:	6c 81       	ldd	r22, Y+4	; 0x04
    20ac:	7d 81       	ldd	r23, Y+5	; 0x05
    20ae:	c7 01       	movw	r24, r14
    20b0:	90 d3       	rcall	.+1824   	; 0x27d2 <vTaskPlaceOnEventList>
    20b2:	c8 01       	movw	r24, r16
    20b4:	17 de       	rcall	.-978    	; 0x1ce4 <prvUnlockQueue>
    20b6:	88 d2       	rcall	.+1296   	; 0x25c8 <xTaskResumeAll>
    20b8:	81 11       	cpse	r24, r1
    20ba:	9a cf       	rjmp	.-204    	; 0x1ff0 <xQueueGenericReceive+0x32>
    20bc:	e2 dc       	rcall	.-1596   	; 0x1a82 <vPortYield>
    20be:	98 cf       	rjmp	.-208    	; 0x1ff0 <xQueueGenericReceive+0x32>
    20c0:	c8 01       	movw	r24, r16
    20c2:	10 de       	rcall	.-992    	; 0x1ce4 <prvUnlockQueue>
    20c4:	81 d2       	rcall	.+1282   	; 0x25c8 <xTaskResumeAll>
    20c6:	94 cf       	rjmp	.-216    	; 0x1ff0 <xQueueGenericReceive+0x32>
    20c8:	c8 01       	movw	r24, r16
    20ca:	0c de       	rcall	.-1000   	; 0x1ce4 <prvUnlockQueue>
    20cc:	7d d2       	rcall	.+1274   	; 0x25c8 <xTaskResumeAll>
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	25 96       	adiw	r28, 0x05	; 5
    20d2:	cd bf       	out	0x3d, r28	; 61
    20d4:	de bf       	out	0x3e, r29	; 62
    20d6:	df 91       	pop	r29
    20d8:	cf 91       	pop	r28
    20da:	1f 91       	pop	r17
    20dc:	0f 91       	pop	r16
    20de:	ff 90       	pop	r15
    20e0:	ef 90       	pop	r14
    20e2:	df 90       	pop	r13
    20e4:	cf 90       	pop	r12
    20e6:	bf 90       	pop	r11
    20e8:	af 90       	pop	r10
    20ea:	08 95       	ret

000020ec <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	0f 92       	push	r0
    20f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    20fa:	8f 3f       	cpi	r24, 0xFF	; 255
    20fc:	09 f4       	brne	.+2      	; 0x2100 <vQueueWaitForMessageRestricted+0x14>
    20fe:	1d 8e       	std	Y+29, r1	; 0x1d
    2100:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2102:	8f 3f       	cpi	r24, 0xFF	; 255
    2104:	09 f4       	brne	.+2      	; 0x2108 <vQueueWaitForMessageRestricted+0x1c>
    2106:	1e 8e       	std	Y+30, r1	; 0x1e
    2108:	0f 90       	pop	r0
    210a:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    210c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    210e:	81 11       	cpse	r24, r1
    2110:	03 c0       	rjmp	.+6      	; 0x2118 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2112:	ce 01       	movw	r24, r28
    2114:	41 96       	adiw	r24, 0x11	; 17
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2116:	77 d3       	rcall	.+1774   	; 0x2806 <vTaskPlaceOnEventListRestricted>
    2118:	ce 01       	movw	r24, r28
	}
    211a:	e4 dd       	rcall	.-1080   	; 0x1ce4 <prvUnlockQueue>
    211c:	df 91       	pop	r29
    211e:	cf 91       	pop	r28
    2120:	08 95       	ret

00002122 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2122:	cb e8       	ldi	r28, 0x8B	; 139
    2124:	d2 e2       	ldi	r29, 0x22	; 34
    2126:	88 81       	ld	r24, Y
    2128:	82 30       	cpi	r24, 0x02	; 2
    212a:	f0 f3       	brcs	.-4      	; 0x2128 <prvIdleTask+0x6>
    212c:	aa dc       	rcall	.-1708   	; 0x1a82 <vPortYield>
    212e:	fb cf       	rjmp	.-10     	; 0x2126 <prvIdleTask+0x4>

00002130 <prvAddCurrentTaskToDelayedList>:
    2130:	cf 93       	push	r28
    2132:	df 93       	push	r29
    2134:	ec 01       	movw	r28, r24
    2136:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    213a:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    213e:	82 83       	std	Z+2, r24	; 0x02
    2140:	93 83       	std	Z+3, r25	; 0x03
    2142:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    2146:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    214a:	c8 17       	cp	r28, r24
    214c:	d9 07       	cpc	r29, r25
    214e:	60 f4       	brcc	.+24     	; 0x2168 <prvAddCurrentTaskToDelayedList+0x38>
    2150:	60 91 b8 22 	lds	r22, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2154:	70 91 b9 22 	lds	r23, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2158:	80 91 75 22 	lds	r24, 0x2275	; 0x802275 <pxOverflowDelayedTaskList>
    215c:	90 91 76 22 	lds	r25, 0x2276	; 0x802276 <pxOverflowDelayedTaskList+0x1>
    2160:	6e 5f       	subi	r22, 0xFE	; 254
    2162:	7f 4f       	sbci	r23, 0xFF	; 255
    2164:	7b db       	rcall	.-2314   	; 0x185c <vListInsert>
    2166:	16 c0       	rjmp	.+44     	; 0x2194 <prvAddCurrentTaskToDelayedList+0x64>
    2168:	60 91 b8 22 	lds	r22, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    216c:	70 91 b9 22 	lds	r23, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2170:	80 91 77 22 	lds	r24, 0x2277	; 0x802277 <pxDelayedTaskList>
    2174:	90 91 78 22 	lds	r25, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    2178:	6e 5f       	subi	r22, 0xFE	; 254
    217a:	7f 4f       	sbci	r23, 0xFF	; 255
    217c:	6f db       	rcall	.-2338   	; 0x185c <vListInsert>
    217e:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <xNextTaskUnblockTime>
    2182:	90 91 62 22 	lds	r25, 0x2262	; 0x802262 <xNextTaskUnblockTime+0x1>
    2186:	c8 17       	cp	r28, r24
    2188:	d9 07       	cpc	r29, r25
    218a:	20 f4       	brcc	.+8      	; 0x2194 <prvAddCurrentTaskToDelayedList+0x64>
    218c:	c0 93 61 22 	sts	0x2261, r28	; 0x802261 <xNextTaskUnblockTime>
    2190:	d0 93 62 22 	sts	0x2262, r29	; 0x802262 <xNextTaskUnblockTime+0x1>
    2194:	df 91       	pop	r29
    2196:	cf 91       	pop	r28
    2198:	08 95       	ret

0000219a <xTaskGenericCreate>:
    219a:	4f 92       	push	r4
    219c:	5f 92       	push	r5
    219e:	6f 92       	push	r6
    21a0:	7f 92       	push	r7
    21a2:	8f 92       	push	r8
    21a4:	9f 92       	push	r9
    21a6:	af 92       	push	r10
    21a8:	bf 92       	push	r11
    21aa:	cf 92       	push	r12
    21ac:	df 92       	push	r13
    21ae:	ef 92       	push	r14
    21b0:	ff 92       	push	r15
    21b2:	0f 93       	push	r16
    21b4:	1f 93       	push	r17
    21b6:	cf 93       	push	r28
    21b8:	df 93       	push	r29
    21ba:	4c 01       	movw	r8, r24
    21bc:	eb 01       	movw	r28, r22
    21be:	5a 01       	movw	r10, r20
    21c0:	29 01       	movw	r4, r18
    21c2:	c1 14       	cp	r12, r1
    21c4:	d1 04       	cpc	r13, r1
    21c6:	31 f4       	brne	.+12     	; 0x21d4 <xTaskGenericCreate+0x3a>
    21c8:	ca 01       	movw	r24, r20
    21ca:	0d dd       	rcall	.-1510   	; 0x1be6 <pvPortMalloc>
    21cc:	6c 01       	movw	r12, r24
    21ce:	89 2b       	or	r24, r25
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <xTaskGenericCreate+0x3a>
    21d2:	d2 c0       	rjmp	.+420    	; 0x2378 <xTaskGenericCreate+0x1de>
    21d4:	86 e2       	ldi	r24, 0x26	; 38
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	06 dd       	rcall	.-1524   	; 0x1be6 <pvPortMalloc>
    21da:	3c 01       	movw	r6, r24
    21dc:	00 97       	sbiw	r24, 0x00	; 0
    21de:	79 f0       	breq	.+30     	; 0x21fe <xTaskGenericCreate+0x64>
    21e0:	fc 01       	movw	r30, r24
    21e2:	c7 8a       	std	Z+23, r12	; 0x17
    21e4:	d0 8e       	std	Z+24, r13	; 0x18
    21e6:	f1 e0       	ldi	r31, 0x01	; 1
    21e8:	af 1a       	sub	r10, r31
    21ea:	b1 08       	sbc	r11, r1
    21ec:	ca 0c       	add	r12, r10
    21ee:	db 1c       	adc	r13, r11
    21f0:	88 81       	ld	r24, Y
    21f2:	f3 01       	movw	r30, r6
    21f4:	81 8f       	std	Z+25, r24	; 0x19
    21f6:	88 81       	ld	r24, Y
    21f8:	81 11       	cpse	r24, r1
    21fa:	04 c0       	rjmp	.+8      	; 0x2204 <xTaskGenericCreate+0x6a>
    21fc:	13 c0       	rjmp	.+38     	; 0x2224 <xTaskGenericCreate+0x8a>
    21fe:	c6 01       	movw	r24, r12
    2200:	ff dc       	rcall	.-1538   	; 0x1c00 <vPortFree>
    2202:	ba c0       	rjmp	.+372    	; 0x2378 <xTaskGenericCreate+0x1de>
    2204:	d3 01       	movw	r26, r6
    2206:	5a 96       	adiw	r26, 0x1a	; 26
    2208:	fe 01       	movw	r30, r28
    220a:	31 96       	adiw	r30, 0x01	; 1
    220c:	9e 01       	movw	r18, r28
    220e:	28 5f       	subi	r18, 0xF8	; 248
    2210:	3f 4f       	sbci	r19, 0xFF	; 255
    2212:	ef 01       	movw	r28, r30
    2214:	81 91       	ld	r24, Z+
    2216:	8d 93       	st	X+, r24
    2218:	88 81       	ld	r24, Y
    221a:	88 23       	and	r24, r24
    221c:	19 f0       	breq	.+6      	; 0x2224 <xTaskGenericCreate+0x8a>
    221e:	2e 17       	cp	r18, r30
    2220:	3f 07       	cpc	r19, r31
    2222:	b9 f7       	brne	.-18     	; 0x2212 <xTaskGenericCreate+0x78>
    2224:	f3 01       	movw	r30, r6
    2226:	10 a2       	std	Z+32, r1	; 0x20
    2228:	10 2f       	mov	r17, r16
    222a:	05 30       	cpi	r16, 0x05	; 5
    222c:	08 f0       	brcs	.+2      	; 0x2230 <xTaskGenericCreate+0x96>
    222e:	14 e0       	ldi	r17, 0x04	; 4
    2230:	f3 01       	movw	r30, r6
    2232:	16 8b       	std	Z+22, r17	; 0x16
    2234:	e3 01       	movw	r28, r6
    2236:	22 96       	adiw	r28, 0x02	; 2
    2238:	ce 01       	movw	r24, r28
    223a:	eb da       	rcall	.-2602   	; 0x1812 <vListInitialiseItem>
    223c:	c3 01       	movw	r24, r6
    223e:	0c 96       	adiw	r24, 0x0c	; 12
    2240:	e8 da       	rcall	.-2608   	; 0x1812 <vListInitialiseItem>
    2242:	f3 01       	movw	r30, r6
    2244:	60 86       	std	Z+8, r6	; 0x08
    2246:	71 86       	std	Z+9, r7	; 0x09
    2248:	85 e0       	ldi	r24, 0x05	; 5
    224a:	90 e0       	ldi	r25, 0x00	; 0
    224c:	81 1b       	sub	r24, r17
    224e:	91 09       	sbc	r25, r1
    2250:	84 87       	std	Z+12, r24	; 0x0c
    2252:	95 87       	std	Z+13, r25	; 0x0d
    2254:	62 8a       	std	Z+18, r6	; 0x12
    2256:	73 8a       	std	Z+19, r7	; 0x13
    2258:	11 a2       	std	Z+33, r1	; 0x21
    225a:	12 a2       	std	Z+34, r1	; 0x22
    225c:	13 a2       	std	Z+35, r1	; 0x23
    225e:	14 a2       	std	Z+36, r1	; 0x24
    2260:	15 a2       	std	Z+37, r1	; 0x25
    2262:	a2 01       	movw	r20, r4
    2264:	b4 01       	movw	r22, r8
    2266:	c6 01       	movw	r24, r12
    2268:	50 db       	rcall	.-2400   	; 0x190a <pxPortInitialiseStack>
    226a:	f3 01       	movw	r30, r6
    226c:	80 83       	st	Z, r24
    226e:	91 83       	std	Z+1, r25	; 0x01
    2270:	e1 14       	cp	r14, r1
    2272:	f1 04       	cpc	r15, r1
    2274:	19 f0       	breq	.+6      	; 0x227c <xTaskGenericCreate+0xe2>
    2276:	f7 01       	movw	r30, r14
    2278:	60 82       	st	Z, r6
    227a:	71 82       	std	Z+1, r7	; 0x01
    227c:	0f b6       	in	r0, 0x3f	; 63
    227e:	f8 94       	cli
    2280:	0f 92       	push	r0
    2282:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <uxCurrentNumberOfTasks>
    2286:	8f 5f       	subi	r24, 0xFF	; 255
    2288:	80 93 6b 22 	sts	0x226B, r24	; 0x80226b <uxCurrentNumberOfTasks>
    228c:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2290:	90 91 b9 22 	lds	r25, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2294:	89 2b       	or	r24, r25
    2296:	91 f5       	brne	.+100    	; 0x22fc <xTaskGenericCreate+0x162>
    2298:	60 92 b8 22 	sts	0x22B8, r6	; 0x8022b8 <pxCurrentTCB>
    229c:	70 92 b9 22 	sts	0x22B9, r7	; 0x8022b9 <pxCurrentTCB+0x1>
    22a0:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <uxCurrentNumberOfTasks>
    22a4:	81 30       	cpi	r24, 0x01	; 1
    22a6:	c9 f5       	brne	.+114    	; 0x231a <xTaskGenericCreate+0x180>
    22a8:	0f 2e       	mov	r0, r31
    22aa:	fb e8       	ldi	r31, 0x8B	; 139
    22ac:	ef 2e       	mov	r14, r31
    22ae:	f2 e2       	ldi	r31, 0x22	; 34
    22b0:	ff 2e       	mov	r15, r31
    22b2:	f0 2d       	mov	r31, r0
    22b4:	0f 2e       	mov	r0, r31
    22b6:	f8 eb       	ldi	r31, 0xB8	; 184
    22b8:	cf 2e       	mov	r12, r31
    22ba:	f2 e2       	ldi	r31, 0x22	; 34
    22bc:	df 2e       	mov	r13, r31
    22be:	f0 2d       	mov	r31, r0
    22c0:	c7 01       	movw	r24, r14
    22c2:	99 da       	rcall	.-2766   	; 0x17f6 <vListInitialise>
    22c4:	f9 e0       	ldi	r31, 0x09	; 9
    22c6:	ef 0e       	add	r14, r31
    22c8:	f1 1c       	adc	r15, r1
    22ca:	ec 14       	cp	r14, r12
    22cc:	fd 04       	cpc	r15, r13
    22ce:	c1 f7       	brne	.-16     	; 0x22c0 <xTaskGenericCreate+0x126>
    22d0:	82 e8       	ldi	r24, 0x82	; 130
    22d2:	92 e2       	ldi	r25, 0x22	; 34
    22d4:	90 da       	rcall	.-2784   	; 0x17f6 <vListInitialise>
    22d6:	89 e7       	ldi	r24, 0x79	; 121
    22d8:	92 e2       	ldi	r25, 0x22	; 34
    22da:	8d da       	rcall	.-2790   	; 0x17f6 <vListInitialise>
    22dc:	8c e6       	ldi	r24, 0x6C	; 108
    22de:	92 e2       	ldi	r25, 0x22	; 34
    22e0:	8a da       	rcall	.-2796   	; 0x17f6 <vListInitialise>
    22e2:	82 e8       	ldi	r24, 0x82	; 130
    22e4:	92 e2       	ldi	r25, 0x22	; 34
    22e6:	80 93 77 22 	sts	0x2277, r24	; 0x802277 <pxDelayedTaskList>
    22ea:	90 93 78 22 	sts	0x2278, r25	; 0x802278 <pxDelayedTaskList+0x1>
    22ee:	89 e7       	ldi	r24, 0x79	; 121
    22f0:	92 e2       	ldi	r25, 0x22	; 34
    22f2:	80 93 75 22 	sts	0x2275, r24	; 0x802275 <pxOverflowDelayedTaskList>
    22f6:	90 93 76 22 	sts	0x2276, r25	; 0x802276 <pxOverflowDelayedTaskList+0x1>
    22fa:	0f c0       	rjmp	.+30     	; 0x231a <xTaskGenericCreate+0x180>
    22fc:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xSchedulerRunning>
    2300:	81 11       	cpse	r24, r1
    2302:	0b c0       	rjmp	.+22     	; 0x231a <xTaskGenericCreate+0x180>
    2304:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2308:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    230c:	86 89       	ldd	r24, Z+22	; 0x16
    230e:	08 17       	cp	r16, r24
    2310:	20 f0       	brcs	.+8      	; 0x231a <xTaskGenericCreate+0x180>
    2312:	60 92 b8 22 	sts	0x22B8, r6	; 0x8022b8 <pxCurrentTCB>
    2316:	70 92 b9 22 	sts	0x22B9, r7	; 0x8022b9 <pxCurrentTCB+0x1>
    231a:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <uxTaskNumber>
    231e:	8f 5f       	subi	r24, 0xFF	; 255
    2320:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <uxTaskNumber>
    2324:	f3 01       	movw	r30, r6
    2326:	86 89       	ldd	r24, Z+22	; 0x16
    2328:	90 91 68 22 	lds	r25, 0x2268	; 0x802268 <uxTopReadyPriority>
    232c:	98 17       	cp	r25, r24
    232e:	10 f4       	brcc	.+4      	; 0x2334 <xTaskGenericCreate+0x19a>
    2330:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxTopReadyPriority>
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	9c 01       	movw	r18, r24
    2338:	22 0f       	add	r18, r18
    233a:	33 1f       	adc	r19, r19
    233c:	22 0f       	add	r18, r18
    233e:	33 1f       	adc	r19, r19
    2340:	22 0f       	add	r18, r18
    2342:	33 1f       	adc	r19, r19
    2344:	82 0f       	add	r24, r18
    2346:	93 1f       	adc	r25, r19
    2348:	be 01       	movw	r22, r28
    234a:	85 57       	subi	r24, 0x75	; 117
    234c:	9d 4d       	sbci	r25, 0xDD	; 221
    234e:	65 da       	rcall	.-2870   	; 0x181a <vListInsertEnd>
    2350:	0f 90       	pop	r0
    2352:	0f be       	out	0x3f, r0	; 63
    2354:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xSchedulerRunning>
    2358:	88 23       	and	r24, r24
    235a:	51 f0       	breq	.+20     	; 0x2370 <xTaskGenericCreate+0x1d6>
    235c:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2360:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2364:	86 89       	ldd	r24, Z+22	; 0x16
    2366:	80 17       	cp	r24, r16
    2368:	28 f4       	brcc	.+10     	; 0x2374 <xTaskGenericCreate+0x1da>
    236a:	8b db       	rcall	.-2282   	; 0x1a82 <vPortYield>
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	05 c0       	rjmp	.+10     	; 0x237a <xTaskGenericCreate+0x1e0>
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	03 c0       	rjmp	.+6      	; 0x237a <xTaskGenericCreate+0x1e0>
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	01 c0       	rjmp	.+2      	; 0x237a <xTaskGenericCreate+0x1e0>
    2378:	8f ef       	ldi	r24, 0xFF	; 255
    237a:	df 91       	pop	r29
    237c:	cf 91       	pop	r28
    237e:	1f 91       	pop	r17
    2380:	0f 91       	pop	r16
    2382:	ff 90       	pop	r15
    2384:	ef 90       	pop	r14
    2386:	df 90       	pop	r13
    2388:	cf 90       	pop	r12
    238a:	bf 90       	pop	r11
    238c:	af 90       	pop	r10
    238e:	9f 90       	pop	r9
    2390:	8f 90       	pop	r8
    2392:	7f 90       	pop	r7
    2394:	6f 90       	pop	r6
    2396:	5f 90       	pop	r5
    2398:	4f 90       	pop	r4
    239a:	08 95       	ret

0000239c <vTaskStartScheduler>:
    239c:	af 92       	push	r10
    239e:	bf 92       	push	r11
    23a0:	cf 92       	push	r12
    23a2:	df 92       	push	r13
    23a4:	ef 92       	push	r14
    23a6:	ff 92       	push	r15
    23a8:	0f 93       	push	r16
    23aa:	a1 2c       	mov	r10, r1
    23ac:	b1 2c       	mov	r11, r1
    23ae:	c1 2c       	mov	r12, r1
    23b0:	d1 2c       	mov	r13, r1
    23b2:	e1 2c       	mov	r14, r1
    23b4:	f1 2c       	mov	r15, r1
    23b6:	00 e0       	ldi	r16, 0x00	; 0
    23b8:	20 e0       	ldi	r18, 0x00	; 0
    23ba:	30 e0       	ldi	r19, 0x00	; 0
    23bc:	45 e5       	ldi	r20, 0x55	; 85
    23be:	50 e0       	ldi	r21, 0x00	; 0
    23c0:	6d e0       	ldi	r22, 0x0D	; 13
    23c2:	70 e2       	ldi	r23, 0x20	; 32
    23c4:	81 e9       	ldi	r24, 0x91	; 145
    23c6:	90 e1       	ldi	r25, 0x10	; 16
    23c8:	e8 de       	rcall	.-560    	; 0x219a <xTaskGenericCreate>
    23ca:	81 30       	cpi	r24, 0x01	; 1
    23cc:	91 f4       	brne	.+36     	; 0x23f2 <vTaskStartScheduler+0x56>
    23ce:	20 d3       	rcall	.+1600   	; 0x2a10 <xTimerCreateTimerTask>
    23d0:	81 30       	cpi	r24, 0x01	; 1
    23d2:	79 f4       	brne	.+30     	; 0x23f2 <vTaskStartScheduler+0x56>
    23d4:	f8 94       	cli
    23d6:	8f ef       	ldi	r24, 0xFF	; 255
    23d8:	9f ef       	ldi	r25, 0xFF	; 255
    23da:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xNextTaskUnblockTime>
    23de:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xNextTaskUnblockTime+0x1>
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <xSchedulerRunning>
    23e8:	10 92 69 22 	sts	0x2269, r1	; 0x802269 <xTickCount>
    23ec:	10 92 6a 22 	sts	0x226A, r1	; 0x80226a <xTickCount+0x1>
    23f0:	03 db       	rcall	.-2554   	; 0x19f8 <xPortStartScheduler>
    23f2:	0f 91       	pop	r16
    23f4:	ff 90       	pop	r15
    23f6:	ef 90       	pop	r14
    23f8:	df 90       	pop	r13
    23fa:	cf 90       	pop	r12
    23fc:	bf 90       	pop	r11
    23fe:	af 90       	pop	r10
    2400:	08 95       	ret

00002402 <vTaskSuspendAll>:
    2402:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    2406:	8f 5f       	subi	r24, 0xFF	; 255
    2408:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <uxSchedulerSuspended>
    240c:	08 95       	ret

0000240e <xTaskGetTickCount>:
    240e:	0f b6       	in	r0, 0x3f	; 63
    2410:	f8 94       	cli
    2412:	0f 92       	push	r0
    2414:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    2418:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    241c:	0f 90       	pop	r0
    241e:	0f be       	out	0x3f, r0	; 63
    2420:	08 95       	ret

00002422 <xTaskIncrementTick>:
    2422:	df 92       	push	r13
    2424:	ef 92       	push	r14
    2426:	ff 92       	push	r15
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	cf 93       	push	r28
    242e:	df 93       	push	r29
    2430:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    2434:	81 11       	cpse	r24, r1
    2436:	b3 c0       	rjmp	.+358    	; 0x259e <xTaskIncrementTick+0x17c>
    2438:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    243c:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    2440:	01 96       	adiw	r24, 0x01	; 1
    2442:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xTickCount>
    2446:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xTickCount+0x1>
    244a:	e0 90 69 22 	lds	r14, 0x2269	; 0x802269 <xTickCount>
    244e:	f0 90 6a 22 	lds	r15, 0x226A	; 0x80226a <xTickCount+0x1>
    2452:	e1 14       	cp	r14, r1
    2454:	f1 04       	cpc	r15, r1
    2456:	99 f5       	brne	.+102    	; 0x24be <xTaskIncrementTick+0x9c>
    2458:	80 91 77 22 	lds	r24, 0x2277	; 0x802277 <pxDelayedTaskList>
    245c:	90 91 78 22 	lds	r25, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    2460:	20 91 75 22 	lds	r18, 0x2275	; 0x802275 <pxOverflowDelayedTaskList>
    2464:	30 91 76 22 	lds	r19, 0x2276	; 0x802276 <pxOverflowDelayedTaskList+0x1>
    2468:	20 93 77 22 	sts	0x2277, r18	; 0x802277 <pxDelayedTaskList>
    246c:	30 93 78 22 	sts	0x2278, r19	; 0x802278 <pxDelayedTaskList+0x1>
    2470:	80 93 75 22 	sts	0x2275, r24	; 0x802275 <pxOverflowDelayedTaskList>
    2474:	90 93 76 22 	sts	0x2276, r25	; 0x802276 <pxOverflowDelayedTaskList+0x1>
    2478:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <xNumOfOverflows>
    247c:	8f 5f       	subi	r24, 0xFF	; 255
    247e:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNumOfOverflows>
    2482:	e0 91 77 22 	lds	r30, 0x2277	; 0x802277 <pxDelayedTaskList>
    2486:	f0 91 78 22 	lds	r31, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    248a:	80 81       	ld	r24, Z
    248c:	81 11       	cpse	r24, r1
    248e:	07 c0       	rjmp	.+14     	; 0x249e <xTaskIncrementTick+0x7c>
    2490:	8f ef       	ldi	r24, 0xFF	; 255
    2492:	9f ef       	ldi	r25, 0xFF	; 255
    2494:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xNextTaskUnblockTime>
    2498:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xNextTaskUnblockTime+0x1>
    249c:	10 c0       	rjmp	.+32     	; 0x24be <xTaskIncrementTick+0x9c>
    249e:	e0 91 77 22 	lds	r30, 0x2277	; 0x802277 <pxDelayedTaskList>
    24a2:	f0 91 78 22 	lds	r31, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    24a6:	05 80       	ldd	r0, Z+5	; 0x05
    24a8:	f6 81       	ldd	r31, Z+6	; 0x06
    24aa:	e0 2d       	mov	r30, r0
    24ac:	06 80       	ldd	r0, Z+6	; 0x06
    24ae:	f7 81       	ldd	r31, Z+7	; 0x07
    24b0:	e0 2d       	mov	r30, r0
    24b2:	82 81       	ldd	r24, Z+2	; 0x02
    24b4:	93 81       	ldd	r25, Z+3	; 0x03
    24b6:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xNextTaskUnblockTime>
    24ba:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xNextTaskUnblockTime+0x1>
    24be:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <xNextTaskUnblockTime>
    24c2:	90 91 62 22 	lds	r25, 0x2262	; 0x802262 <xNextTaskUnblockTime+0x1>
    24c6:	e8 16       	cp	r14, r24
    24c8:	f9 06       	cpc	r15, r25
    24ca:	10 f4       	brcc	.+4      	; 0x24d0 <xTaskIncrementTick+0xae>
    24cc:	d1 2c       	mov	r13, r1
    24ce:	4f c0       	rjmp	.+158    	; 0x256e <xTaskIncrementTick+0x14c>
    24d0:	d1 2c       	mov	r13, r1
    24d2:	e0 91 77 22 	lds	r30, 0x2277	; 0x802277 <pxDelayedTaskList>
    24d6:	f0 91 78 22 	lds	r31, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    24da:	80 81       	ld	r24, Z
    24dc:	81 11       	cpse	r24, r1
    24de:	07 c0       	rjmp	.+14     	; 0x24ee <xTaskIncrementTick+0xcc>
    24e0:	8f ef       	ldi	r24, 0xFF	; 255
    24e2:	9f ef       	ldi	r25, 0xFF	; 255
    24e4:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xNextTaskUnblockTime>
    24e8:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xNextTaskUnblockTime+0x1>
    24ec:	40 c0       	rjmp	.+128    	; 0x256e <xTaskIncrementTick+0x14c>
    24ee:	e0 91 77 22 	lds	r30, 0x2277	; 0x802277 <pxDelayedTaskList>
    24f2:	f0 91 78 22 	lds	r31, 0x2278	; 0x802278 <pxDelayedTaskList+0x1>
    24f6:	05 80       	ldd	r0, Z+5	; 0x05
    24f8:	f6 81       	ldd	r31, Z+6	; 0x06
    24fa:	e0 2d       	mov	r30, r0
    24fc:	c6 81       	ldd	r28, Z+6	; 0x06
    24fe:	d7 81       	ldd	r29, Z+7	; 0x07
    2500:	8a 81       	ldd	r24, Y+2	; 0x02
    2502:	9b 81       	ldd	r25, Y+3	; 0x03
    2504:	e8 16       	cp	r14, r24
    2506:	f9 06       	cpc	r15, r25
    2508:	28 f4       	brcc	.+10     	; 0x2514 <xTaskIncrementTick+0xf2>
    250a:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xNextTaskUnblockTime>
    250e:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xNextTaskUnblockTime+0x1>
    2512:	2d c0       	rjmp	.+90     	; 0x256e <xTaskIncrementTick+0x14c>
    2514:	8e 01       	movw	r16, r28
    2516:	0e 5f       	subi	r16, 0xFE	; 254
    2518:	1f 4f       	sbci	r17, 0xFF	; 255
    251a:	c8 01       	movw	r24, r16
    251c:	d0 d9       	rcall	.-3168   	; 0x18be <uxListRemove>
    251e:	8c 89       	ldd	r24, Y+20	; 0x14
    2520:	9d 89       	ldd	r25, Y+21	; 0x15
    2522:	89 2b       	or	r24, r25
    2524:	19 f0       	breq	.+6      	; 0x252c <xTaskIncrementTick+0x10a>
    2526:	ce 01       	movw	r24, r28
    2528:	0c 96       	adiw	r24, 0x0c	; 12
    252a:	c9 d9       	rcall	.-3182   	; 0x18be <uxListRemove>
    252c:	8e 89       	ldd	r24, Y+22	; 0x16
    252e:	90 91 68 22 	lds	r25, 0x2268	; 0x802268 <uxTopReadyPriority>
    2532:	98 17       	cp	r25, r24
    2534:	10 f4       	brcc	.+4      	; 0x253a <xTaskIncrementTick+0x118>
    2536:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxTopReadyPriority>
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	9c 01       	movw	r18, r24
    253e:	22 0f       	add	r18, r18
    2540:	33 1f       	adc	r19, r19
    2542:	22 0f       	add	r18, r18
    2544:	33 1f       	adc	r19, r19
    2546:	22 0f       	add	r18, r18
    2548:	33 1f       	adc	r19, r19
    254a:	82 0f       	add	r24, r18
    254c:	93 1f       	adc	r25, r19
    254e:	b8 01       	movw	r22, r16
    2550:	85 57       	subi	r24, 0x75	; 117
    2552:	9d 4d       	sbci	r25, 0xDD	; 221
    2554:	62 d9       	rcall	.-3388   	; 0x181a <vListInsertEnd>
    2556:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    255a:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    255e:	9e 89       	ldd	r25, Y+22	; 0x16
    2560:	86 89       	ldd	r24, Z+22	; 0x16
    2562:	98 17       	cp	r25, r24
    2564:	08 f4       	brcc	.+2      	; 0x2568 <xTaskIncrementTick+0x146>
    2566:	b5 cf       	rjmp	.-150    	; 0x24d2 <xTaskIncrementTick+0xb0>
    2568:	dd 24       	eor	r13, r13
    256a:	d3 94       	inc	r13
    256c:	b2 cf       	rjmp	.-156    	; 0x24d2 <xTaskIncrementTick+0xb0>
    256e:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2572:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2576:	86 89       	ldd	r24, Z+22	; 0x16
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	fc 01       	movw	r30, r24
    257c:	ee 0f       	add	r30, r30
    257e:	ff 1f       	adc	r31, r31
    2580:	ee 0f       	add	r30, r30
    2582:	ff 1f       	adc	r31, r31
    2584:	ee 0f       	add	r30, r30
    2586:	ff 1f       	adc	r31, r31
    2588:	8e 0f       	add	r24, r30
    258a:	9f 1f       	adc	r25, r31
    258c:	fc 01       	movw	r30, r24
    258e:	e5 57       	subi	r30, 0x75	; 117
    2590:	fd 4d       	sbci	r31, 0xDD	; 221
    2592:	80 81       	ld	r24, Z
    2594:	82 30       	cpi	r24, 0x02	; 2
    2596:	48 f0       	brcs	.+18     	; 0x25aa <xTaskIncrementTick+0x188>
    2598:	dd 24       	eor	r13, r13
    259a:	d3 94       	inc	r13
    259c:	06 c0       	rjmp	.+12     	; 0x25aa <xTaskIncrementTick+0x188>
    259e:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxPendedTicks>
    25a2:	8f 5f       	subi	r24, 0xFF	; 255
    25a4:	80 93 66 22 	sts	0x2266, r24	; 0x802266 <uxPendedTicks>
    25a8:	d1 2c       	mov	r13, r1
    25aa:	80 91 65 22 	lds	r24, 0x2265	; 0x802265 <xYieldPending>
    25ae:	88 23       	and	r24, r24
    25b0:	11 f0       	breq	.+4      	; 0x25b6 <xTaskIncrementTick+0x194>
    25b2:	dd 24       	eor	r13, r13
    25b4:	d3 94       	inc	r13
    25b6:	8d 2d       	mov	r24, r13
    25b8:	df 91       	pop	r29
    25ba:	cf 91       	pop	r28
    25bc:	1f 91       	pop	r17
    25be:	0f 91       	pop	r16
    25c0:	ff 90       	pop	r15
    25c2:	ef 90       	pop	r14
    25c4:	df 90       	pop	r13
    25c6:	08 95       	ret

000025c8 <xTaskResumeAll>:
    25c8:	df 92       	push	r13
    25ca:	ef 92       	push	r14
    25cc:	ff 92       	push	r15
    25ce:	0f 93       	push	r16
    25d0:	1f 93       	push	r17
    25d2:	cf 93       	push	r28
    25d4:	df 93       	push	r29
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	f8 94       	cli
    25da:	0f 92       	push	r0
    25dc:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    25e0:	81 50       	subi	r24, 0x01	; 1
    25e2:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <uxSchedulerSuspended>
    25e6:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    25ea:	81 11       	cpse	r24, r1
    25ec:	5d c0       	rjmp	.+186    	; 0x26a8 <xTaskResumeAll+0xe0>
    25ee:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <uxCurrentNumberOfTasks>
    25f2:	81 11       	cpse	r24, r1
    25f4:	30 c0       	rjmp	.+96     	; 0x2656 <xTaskResumeAll+0x8e>
    25f6:	5b c0       	rjmp	.+182    	; 0x26ae <xTaskResumeAll+0xe6>
    25f8:	d7 01       	movw	r26, r14
    25fa:	15 96       	adiw	r26, 0x05	; 5
    25fc:	ed 91       	ld	r30, X+
    25fe:	fc 91       	ld	r31, X
    2600:	16 97       	sbiw	r26, 0x06	; 6
    2602:	c6 81       	ldd	r28, Z+6	; 0x06
    2604:	d7 81       	ldd	r29, Z+7	; 0x07
    2606:	ce 01       	movw	r24, r28
    2608:	0c 96       	adiw	r24, 0x0c	; 12
    260a:	59 d9       	rcall	.-3406   	; 0x18be <uxListRemove>
    260c:	8e 01       	movw	r16, r28
    260e:	0e 5f       	subi	r16, 0xFE	; 254
    2610:	1f 4f       	sbci	r17, 0xFF	; 255
    2612:	c8 01       	movw	r24, r16
    2614:	54 d9       	rcall	.-3416   	; 0x18be <uxListRemove>
    2616:	8e 89       	ldd	r24, Y+22	; 0x16
    2618:	90 91 68 22 	lds	r25, 0x2268	; 0x802268 <uxTopReadyPriority>
    261c:	98 17       	cp	r25, r24
    261e:	10 f4       	brcc	.+4      	; 0x2624 <xTaskResumeAll+0x5c>
    2620:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxTopReadyPriority>
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	9c 01       	movw	r18, r24
    2628:	22 0f       	add	r18, r18
    262a:	33 1f       	adc	r19, r19
    262c:	22 0f       	add	r18, r18
    262e:	33 1f       	adc	r19, r19
    2630:	22 0f       	add	r18, r18
    2632:	33 1f       	adc	r19, r19
    2634:	82 0f       	add	r24, r18
    2636:	93 1f       	adc	r25, r19
    2638:	b8 01       	movw	r22, r16
    263a:	85 57       	subi	r24, 0x75	; 117
    263c:	9d 4d       	sbci	r25, 0xDD	; 221
    263e:	ed d8       	rcall	.-3622   	; 0x181a <vListInsertEnd>
    2640:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2644:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2648:	9e 89       	ldd	r25, Y+22	; 0x16
    264a:	86 89       	ldd	r24, Z+22	; 0x16
    264c:	98 17       	cp	r25, r24
    264e:	58 f0       	brcs	.+22     	; 0x2666 <xTaskResumeAll+0x9e>
    2650:	d0 92 65 22 	sts	0x2265, r13	; 0x802265 <xYieldPending>
    2654:	08 c0       	rjmp	.+16     	; 0x2666 <xTaskResumeAll+0x9e>
    2656:	0f 2e       	mov	r0, r31
    2658:	fc e6       	ldi	r31, 0x6C	; 108
    265a:	ef 2e       	mov	r14, r31
    265c:	f2 e2       	ldi	r31, 0x22	; 34
    265e:	ff 2e       	mov	r15, r31
    2660:	f0 2d       	mov	r31, r0
    2662:	dd 24       	eor	r13, r13
    2664:	d3 94       	inc	r13
    2666:	f7 01       	movw	r30, r14
    2668:	80 81       	ld	r24, Z
    266a:	81 11       	cpse	r24, r1
    266c:	c5 cf       	rjmp	.-118    	; 0x25f8 <xTaskResumeAll+0x30>
    266e:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxPendedTicks>
    2672:	88 23       	and	r24, r24
    2674:	91 f0       	breq	.+36     	; 0x269a <xTaskResumeAll+0xd2>
    2676:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxPendedTicks>
    267a:	88 23       	and	r24, r24
    267c:	71 f0       	breq	.+28     	; 0x269a <xTaskResumeAll+0xd2>
    267e:	c1 e0       	ldi	r28, 0x01	; 1
    2680:	d0 de       	rcall	.-608    	; 0x2422 <xTaskIncrementTick>
    2682:	81 11       	cpse	r24, r1
    2684:	c0 93 65 22 	sts	0x2265, r28	; 0x802265 <xYieldPending>
    2688:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxPendedTicks>
    268c:	81 50       	subi	r24, 0x01	; 1
    268e:	80 93 66 22 	sts	0x2266, r24	; 0x802266 <uxPendedTicks>
    2692:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxPendedTicks>
    2696:	81 11       	cpse	r24, r1
    2698:	f3 cf       	rjmp	.-26     	; 0x2680 <xTaskResumeAll+0xb8>
    269a:	80 91 65 22 	lds	r24, 0x2265	; 0x802265 <xYieldPending>
    269e:	81 30       	cpi	r24, 0x01	; 1
    26a0:	29 f4       	brne	.+10     	; 0x26ac <xTaskResumeAll+0xe4>
    26a2:	ef d9       	rcall	.-3106   	; 0x1a82 <vPortYield>
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	03 c0       	rjmp	.+6      	; 0x26ae <xTaskResumeAll+0xe6>
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <xTaskResumeAll+0xe6>
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	0f 90       	pop	r0
    26b0:	0f be       	out	0x3f, r0	; 63
    26b2:	df 91       	pop	r29
    26b4:	cf 91       	pop	r28
    26b6:	1f 91       	pop	r17
    26b8:	0f 91       	pop	r16
    26ba:	ff 90       	pop	r15
    26bc:	ef 90       	pop	r14
    26be:	df 90       	pop	r13
    26c0:	08 95       	ret

000026c2 <vTaskDelay>:
    26c2:	cf 93       	push	r28
    26c4:	df 93       	push	r29
    26c6:	ec 01       	movw	r28, r24
    26c8:	89 2b       	or	r24, r25
    26ca:	91 f0       	breq	.+36     	; 0x26f0 <vTaskDelay+0x2e>
    26cc:	9a de       	rcall	.-716    	; 0x2402 <vTaskSuspendAll>
    26ce:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    26d2:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    26d6:	c8 0f       	add	r28, r24
    26d8:	d9 1f       	adc	r29, r25
    26da:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    26de:	90 91 b9 22 	lds	r25, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    26e2:	02 96       	adiw	r24, 0x02	; 2
    26e4:	ec d8       	rcall	.-3624   	; 0x18be <uxListRemove>
    26e6:	ce 01       	movw	r24, r28
    26e8:	23 dd       	rcall	.-1466   	; 0x2130 <prvAddCurrentTaskToDelayedList>
    26ea:	6e df       	rcall	.-292    	; 0x25c8 <xTaskResumeAll>
    26ec:	81 11       	cpse	r24, r1
    26ee:	01 c0       	rjmp	.+2      	; 0x26f2 <vTaskDelay+0x30>
    26f0:	c8 d9       	rcall	.-3184   	; 0x1a82 <vPortYield>
    26f2:	df 91       	pop	r29
    26f4:	cf 91       	pop	r28
    26f6:	08 95       	ret

000026f8 <vTaskSwitchContext>:
    26f8:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    26fc:	88 23       	and	r24, r24
    26fe:	21 f0       	breq	.+8      	; 0x2708 <vTaskSwitchContext+0x10>
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	80 93 65 22 	sts	0x2265, r24	; 0x802265 <xYieldPending>
    2706:	08 95       	ret
    2708:	10 92 65 22 	sts	0x2265, r1	; 0x802265 <xYieldPending>
    270c:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxTopReadyPriority>
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	fc 01       	movw	r30, r24
    2714:	ee 0f       	add	r30, r30
    2716:	ff 1f       	adc	r31, r31
    2718:	ee 0f       	add	r30, r30
    271a:	ff 1f       	adc	r31, r31
    271c:	ee 0f       	add	r30, r30
    271e:	ff 1f       	adc	r31, r31
    2720:	8e 0f       	add	r24, r30
    2722:	9f 1f       	adc	r25, r31
    2724:	fc 01       	movw	r30, r24
    2726:	e5 57       	subi	r30, 0x75	; 117
    2728:	fd 4d       	sbci	r31, 0xDD	; 221
    272a:	80 81       	ld	r24, Z
    272c:	81 11       	cpse	r24, r1
    272e:	17 c0       	rjmp	.+46     	; 0x275e <vTaskSwitchContext+0x66>
    2730:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxTopReadyPriority>
    2734:	81 50       	subi	r24, 0x01	; 1
    2736:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxTopReadyPriority>
    273a:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxTopReadyPriority>
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	fc 01       	movw	r30, r24
    2742:	ee 0f       	add	r30, r30
    2744:	ff 1f       	adc	r31, r31
    2746:	ee 0f       	add	r30, r30
    2748:	ff 1f       	adc	r31, r31
    274a:	ee 0f       	add	r30, r30
    274c:	ff 1f       	adc	r31, r31
    274e:	8e 0f       	add	r24, r30
    2750:	9f 1f       	adc	r25, r31
    2752:	fc 01       	movw	r30, r24
    2754:	e5 57       	subi	r30, 0x75	; 117
    2756:	fd 4d       	sbci	r31, 0xDD	; 221
    2758:	80 81       	ld	r24, Z
    275a:	88 23       	and	r24, r24
    275c:	49 f3       	breq	.-46     	; 0x2730 <vTaskSwitchContext+0x38>
    275e:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxTopReadyPriority>
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	9c 01       	movw	r18, r24
    2766:	22 0f       	add	r18, r18
    2768:	33 1f       	adc	r19, r19
    276a:	22 0f       	add	r18, r18
    276c:	33 1f       	adc	r19, r19
    276e:	22 0f       	add	r18, r18
    2770:	33 1f       	adc	r19, r19
    2772:	28 0f       	add	r18, r24
    2774:	39 1f       	adc	r19, r25
    2776:	d9 01       	movw	r26, r18
    2778:	a5 57       	subi	r26, 0x75	; 117
    277a:	bd 4d       	sbci	r27, 0xDD	; 221
    277c:	11 96       	adiw	r26, 0x01	; 1
    277e:	ed 91       	ld	r30, X+
    2780:	fc 91       	ld	r31, X
    2782:	12 97       	sbiw	r26, 0x02	; 2
    2784:	02 80       	ldd	r0, Z+2	; 0x02
    2786:	f3 81       	ldd	r31, Z+3	; 0x03
    2788:	e0 2d       	mov	r30, r0
    278a:	11 96       	adiw	r26, 0x01	; 1
    278c:	ed 93       	st	X+, r30
    278e:	fc 93       	st	X, r31
    2790:	12 97       	sbiw	r26, 0x02	; 2
    2792:	22 57       	subi	r18, 0x72	; 114
    2794:	3d 4d       	sbci	r19, 0xDD	; 221
    2796:	e2 17       	cp	r30, r18
    2798:	f3 07       	cpc	r31, r19
    279a:	29 f4       	brne	.+10     	; 0x27a6 <vTaskSwitchContext+0xae>
    279c:	22 81       	ldd	r18, Z+2	; 0x02
    279e:	33 81       	ldd	r19, Z+3	; 0x03
    27a0:	fd 01       	movw	r30, r26
    27a2:	21 83       	std	Z+1, r18	; 0x01
    27a4:	32 83       	std	Z+2, r19	; 0x02
    27a6:	fc 01       	movw	r30, r24
    27a8:	ee 0f       	add	r30, r30
    27aa:	ff 1f       	adc	r31, r31
    27ac:	ee 0f       	add	r30, r30
    27ae:	ff 1f       	adc	r31, r31
    27b0:	ee 0f       	add	r30, r30
    27b2:	ff 1f       	adc	r31, r31
    27b4:	8e 0f       	add	r24, r30
    27b6:	9f 1f       	adc	r25, r31
    27b8:	fc 01       	movw	r30, r24
    27ba:	e5 57       	subi	r30, 0x75	; 117
    27bc:	fd 4d       	sbci	r31, 0xDD	; 221
    27be:	01 80       	ldd	r0, Z+1	; 0x01
    27c0:	f2 81       	ldd	r31, Z+2	; 0x02
    27c2:	e0 2d       	mov	r30, r0
    27c4:	86 81       	ldd	r24, Z+6	; 0x06
    27c6:	97 81       	ldd	r25, Z+7	; 0x07
    27c8:	80 93 b8 22 	sts	0x22B8, r24	; 0x8022b8 <pxCurrentTCB>
    27cc:	90 93 b9 22 	sts	0x22B9, r25	; 0x8022b9 <pxCurrentTCB+0x1>
    27d0:	08 95       	ret

000027d2 <vTaskPlaceOnEventList>:
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	eb 01       	movw	r28, r22
    27d8:	60 91 b8 22 	lds	r22, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    27dc:	70 91 b9 22 	lds	r23, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    27e0:	64 5f       	subi	r22, 0xF4	; 244
    27e2:	7f 4f       	sbci	r23, 0xFF	; 255
    27e4:	3b d8       	rcall	.-3978   	; 0x185c <vListInsert>
    27e6:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    27ea:	90 91 b9 22 	lds	r25, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    27ee:	02 96       	adiw	r24, 0x02	; 2
    27f0:	66 d8       	rcall	.-3892   	; 0x18be <uxListRemove>
    27f2:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    27f6:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    27fa:	8c 0f       	add	r24, r28
    27fc:	9d 1f       	adc	r25, r29
    27fe:	98 dc       	rcall	.-1744   	; 0x2130 <prvAddCurrentTaskToDelayedList>
    2800:	df 91       	pop	r29
    2802:	cf 91       	pop	r28
    2804:	08 95       	ret

00002806 <vTaskPlaceOnEventListRestricted>:
    2806:	cf 93       	push	r28
    2808:	df 93       	push	r29
    280a:	eb 01       	movw	r28, r22
    280c:	60 91 b8 22 	lds	r22, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    2810:	70 91 b9 22 	lds	r23, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2814:	64 5f       	subi	r22, 0xF4	; 244
    2816:	7f 4f       	sbci	r23, 0xFF	; 255
    2818:	00 d8       	rcall	.-4096   	; 0x181a <vListInsertEnd>
    281a:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    281e:	90 91 b9 22 	lds	r25, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    2822:	02 96       	adiw	r24, 0x02	; 2
    2824:	4c d8       	rcall	.-3944   	; 0x18be <uxListRemove>
    2826:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xTickCount>
    282a:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xTickCount+0x1>
    282e:	8c 0f       	add	r24, r28
    2830:	9d 1f       	adc	r25, r29
    2832:	7e dc       	rcall	.-1796   	; 0x2130 <prvAddCurrentTaskToDelayedList>
    2834:	df 91       	pop	r29
    2836:	cf 91       	pop	r28
    2838:	08 95       	ret

0000283a <xTaskRemoveFromEventList>:
    283a:	0f 93       	push	r16
    283c:	1f 93       	push	r17
    283e:	cf 93       	push	r28
    2840:	df 93       	push	r29
    2842:	dc 01       	movw	r26, r24
    2844:	15 96       	adiw	r26, 0x05	; 5
    2846:	ed 91       	ld	r30, X+
    2848:	fc 91       	ld	r31, X
    284a:	16 97       	sbiw	r26, 0x06	; 6
    284c:	c6 81       	ldd	r28, Z+6	; 0x06
    284e:	d7 81       	ldd	r29, Z+7	; 0x07
    2850:	8e 01       	movw	r16, r28
    2852:	04 5f       	subi	r16, 0xF4	; 244
    2854:	1f 4f       	sbci	r17, 0xFF	; 255
    2856:	c8 01       	movw	r24, r16
    2858:	32 d8       	rcall	.-3996   	; 0x18be <uxListRemove>
    285a:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    285e:	81 11       	cpse	r24, r1
    2860:	1b c0       	rjmp	.+54     	; 0x2898 <xTaskRemoveFromEventList+0x5e>
    2862:	0a 50       	subi	r16, 0x0A	; 10
    2864:	11 09       	sbc	r17, r1
    2866:	c8 01       	movw	r24, r16
    2868:	2a d8       	rcall	.-4012   	; 0x18be <uxListRemove>
    286a:	8e 89       	ldd	r24, Y+22	; 0x16
    286c:	90 91 68 22 	lds	r25, 0x2268	; 0x802268 <uxTopReadyPriority>
    2870:	98 17       	cp	r25, r24
    2872:	10 f4       	brcc	.+4      	; 0x2878 <xTaskRemoveFromEventList+0x3e>
    2874:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxTopReadyPriority>
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	9c 01       	movw	r18, r24
    287c:	22 0f       	add	r18, r18
    287e:	33 1f       	adc	r19, r19
    2880:	22 0f       	add	r18, r18
    2882:	33 1f       	adc	r19, r19
    2884:	22 0f       	add	r18, r18
    2886:	33 1f       	adc	r19, r19
    2888:	82 0f       	add	r24, r18
    288a:	93 1f       	adc	r25, r19
    288c:	b8 01       	movw	r22, r16
    288e:	85 57       	subi	r24, 0x75	; 117
    2890:	9d 4d       	sbci	r25, 0xDD	; 221
    2892:	0e 94 0d 0c 	call	0x181a	; 0x181a <vListInsertEnd>
    2896:	05 c0       	rjmp	.+10     	; 0x28a2 <xTaskRemoveFromEventList+0x68>
    2898:	b8 01       	movw	r22, r16
    289a:	8c e6       	ldi	r24, 0x6C	; 108
    289c:	92 e2       	ldi	r25, 0x22	; 34
    289e:	0e 94 0d 0c 	call	0x181a	; 0x181a <vListInsertEnd>
    28a2:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <pxCurrentTCB>
    28a6:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <pxCurrentTCB+0x1>
    28aa:	9e 89       	ldd	r25, Y+22	; 0x16
    28ac:	86 89       	ldd	r24, Z+22	; 0x16
    28ae:	89 17       	cp	r24, r25
    28b0:	20 f4       	brcc	.+8      	; 0x28ba <xTaskRemoveFromEventList+0x80>
    28b2:	81 e0       	ldi	r24, 0x01	; 1
    28b4:	80 93 65 22 	sts	0x2265, r24	; 0x802265 <xYieldPending>
    28b8:	01 c0       	rjmp	.+2      	; 0x28bc <xTaskRemoveFromEventList+0x82>
    28ba:	80 e0       	ldi	r24, 0x00	; 0
    28bc:	df 91       	pop	r29
    28be:	cf 91       	pop	r28
    28c0:	1f 91       	pop	r17
    28c2:	0f 91       	pop	r16
    28c4:	08 95       	ret

000028c6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    28c6:	20 91 64 22 	lds	r18, 0x2264	; 0x802264 <xNumOfOverflows>
    28ca:	fc 01       	movw	r30, r24
    28cc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    28ce:	20 91 69 22 	lds	r18, 0x2269	; 0x802269 <xTickCount>
    28d2:	30 91 6a 22 	lds	r19, 0x226A	; 0x80226a <xTickCount+0x1>
    28d6:	21 83       	std	Z+1, r18	; 0x01
    28d8:	32 83       	std	Z+2, r19	; 0x02
    28da:	08 95       	ret

000028dc <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    28dc:	cf 93       	push	r28
    28de:	df 93       	push	r29
    28e0:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    28e2:	0f b6       	in	r0, 0x3f	; 63
    28e4:	f8 94       	cli
    28e6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    28e8:	20 91 69 22 	lds	r18, 0x2269	; 0x802269 <xTickCount>
    28ec:	30 91 6a 22 	lds	r19, 0x226A	; 0x80226a <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    28f0:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <xNumOfOverflows>
    28f4:	90 81       	ld	r25, Z
    28f6:	98 17       	cp	r25, r24
    28f8:	29 f0       	breq	.+10     	; 0x2904 <xTaskCheckForTimeOut+0x28>
    28fa:	81 81       	ldd	r24, Z+1	; 0x01
    28fc:	92 81       	ldd	r25, Z+2	; 0x02
    28fe:	28 17       	cp	r18, r24
    2900:	39 07       	cpc	r19, r25
    2902:	a8 f4       	brcc	.+42     	; 0x292e <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2904:	a1 81       	ldd	r26, Z+1	; 0x01
    2906:	b2 81       	ldd	r27, Z+2	; 0x02
    2908:	eb 01       	movw	r28, r22
    290a:	48 81       	ld	r20, Y
    290c:	59 81       	ldd	r21, Y+1	; 0x01
    290e:	c9 01       	movw	r24, r18
    2910:	8a 1b       	sub	r24, r26
    2912:	9b 0b       	sbc	r25, r27
    2914:	84 17       	cp	r24, r20
    2916:	95 07       	cpc	r25, r21
    2918:	60 f4       	brcc	.+24     	; 0x2932 <xTaskCheckForTimeOut+0x56>
    291a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    291c:	a2 1b       	sub	r26, r18
    291e:	b3 0b       	sbc	r27, r19
    2920:	4a 0f       	add	r20, r26
    2922:	5b 1f       	adc	r21, r27
    2924:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    2926:	59 83       	std	Y+1, r21	; 0x01
			xReturn = pdFALSE;
    2928:	ce df       	rcall	.-100    	; 0x28c6 <vTaskSetTimeOutState>
    292a:	80 e0       	ldi	r24, 0x00	; 0
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    292c:	03 c0       	rjmp	.+6      	; 0x2934 <xTaskCheckForTimeOut+0x58>
    292e:	81 e0       	ldi	r24, 0x01	; 1
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2930:	01 c0       	rjmp	.+2      	; 0x2934 <xTaskCheckForTimeOut+0x58>
		}
	}
	taskEXIT_CRITICAL();
    2932:	81 e0       	ldi	r24, 0x01	; 1
    2934:	0f 90       	pop	r0

	return xReturn;
}
    2936:	0f be       	out	0x3f, r0	; 63
    2938:	df 91       	pop	r29
    293a:	cf 91       	pop	r28
    293c:	08 95       	ret

0000293e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    293e:	81 e0       	ldi	r24, 0x01	; 1
    2940:	80 93 65 22 	sts	0x2265, r24	; 0x802265 <xYieldPending>
    2944:	08 95       	ret

00002946 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2946:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xSchedulerRunning>
    294a:	88 23       	and	r24, r24
    294c:	31 f0       	breq	.+12     	; 0x295a <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    294e:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <uxSchedulerSuspended>
    2952:	88 23       	and	r24, r24
    2954:	21 f0       	breq	.+8      	; 0x295e <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2956:	80 e0       	ldi	r24, 0x00	; 0
    2958:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    295e:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2960:	08 95       	ret

00002962 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2962:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2964:	62 83       	std	Z+2, r22	; 0x02
    2966:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2968:	80 87       	std	Z+8, r24	; 0x08
    296a:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    296c:	46 17       	cp	r20, r22
    296e:	57 07       	cpc	r21, r23
    2970:	90 f0       	brcs	.+36     	; 0x2996 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2972:	42 1b       	sub	r20, r18
    2974:	53 0b       	sbc	r21, r19
    2976:	84 85       	ldd	r24, Z+12	; 0x0c
    2978:	95 85       	ldd	r25, Z+13	; 0x0d
    297a:	48 17       	cp	r20, r24
    297c:	59 07       	cpc	r21, r25
    297e:	e0 f4       	brcc	.+56     	; 0x29b8 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2980:	bf 01       	movw	r22, r30
    2982:	6e 5f       	subi	r22, 0xFE	; 254
    2984:	7f 4f       	sbci	r23, 0xFF	; 255
    2986:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <pxOverflowTimerList>
    298a:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <pxOverflowTimerList+0x1>
    298e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2992:	80 e0       	ldi	r24, 0x00	; 0
    2994:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2996:	42 17       	cp	r20, r18
    2998:	53 07       	cpc	r21, r19
    299a:	18 f4       	brcc	.+6      	; 0x29a2 <prvInsertTimerInActiveList+0x40>
    299c:	62 17       	cp	r22, r18
    299e:	73 07       	cpc	r23, r19
    29a0:	68 f4       	brcc	.+26     	; 0x29bc <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    29a2:	bf 01       	movw	r22, r30
    29a4:	6e 5f       	subi	r22, 0xFE	; 254
    29a6:	7f 4f       	sbci	r23, 0xFF	; 255
    29a8:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTimerList>
    29ac:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTimerList+0x1>
    29b0:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    29b4:	80 e0       	ldi	r24, 0x00	; 0
    29b6:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    29b8:	81 e0       	ldi	r24, 0x01	; 1
    29ba:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    29bc:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    29be:	08 95       	ret

000029c0 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	f8 94       	cli
    29c4:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    29c6:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>
    29ca:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
    29ce:	89 2b       	or	r24, r25
    29d0:	e1 f4       	brne	.+56     	; 0x2a0a <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    29d2:	8b ec       	ldi	r24, 0xCB	; 203
    29d4:	92 e2       	ldi	r25, 0x22	; 34
    29d6:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    29da:	82 ec       	ldi	r24, 0xC2	; 194
    29dc:	92 e2       	ldi	r25, 0x22	; 34
    29de:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    29e2:	8b ec       	ldi	r24, 0xCB	; 203
    29e4:	92 e2       	ldi	r25, 0x22	; 34
    29e6:	80 93 c0 22 	sts	0x22C0, r24	; 0x8022c0 <pxCurrentTimerList>
    29ea:	90 93 c1 22 	sts	0x22C1, r25	; 0x8022c1 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    29ee:	82 ec       	ldi	r24, 0xC2	; 194
    29f0:	92 e2       	ldi	r25, 0x22	; 34
    29f2:	80 93 be 22 	sts	0x22BE, r24	; 0x8022be <pxOverflowTimerList>
    29f6:	90 93 bf 22 	sts	0x22BF, r25	; 0x8022bf <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    29fa:	40 e0       	ldi	r20, 0x00	; 0
    29fc:	65 e0       	ldi	r22, 0x05	; 5
    29fe:	8a e0       	ldi	r24, 0x0A	; 10
    2a00:	f2 d9       	rcall	.-3100   	; 0x1de6 <xQueueGenericCreate>
    2a02:	80 93 bc 22 	sts	0x22BC, r24	; 0x8022bc <xTimerQueue>
    2a06:	90 93 bd 22 	sts	0x22BD, r25	; 0x8022bd <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2a0a:	0f 90       	pop	r0
    2a0c:	0f be       	out	0x3f, r0	; 63
    2a0e:	08 95       	ret

00002a10 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    2a10:	af 92       	push	r10
    2a12:	bf 92       	push	r11
    2a14:	cf 92       	push	r12
    2a16:	df 92       	push	r13
    2a18:	ef 92       	push	r14
    2a1a:	ff 92       	push	r15

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2a1c:	0f 93       	push	r16

	if( xTimerQueue != NULL )
    2a1e:	d0 df       	rcall	.-96     	; 0x29c0 <prvCheckForValidListAndQueue>
    2a20:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>
    2a24:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
    2a28:	89 2b       	or	r24, r25
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2a2a:	89 f0       	breq	.+34     	; 0x2a4e <xTimerCreateTimerTask+0x3e>
    2a2c:	a1 2c       	mov	r10, r1
    2a2e:	b1 2c       	mov	r11, r1
    2a30:	c1 2c       	mov	r12, r1
    2a32:	d1 2c       	mov	r13, r1
    2a34:	e1 2c       	mov	r14, r1
    2a36:	f1 2c       	mov	r15, r1
    2a38:	03 e0       	ldi	r16, 0x03	; 3
    2a3a:	20 e0       	ldi	r18, 0x00	; 0
    2a3c:	30 e0       	ldi	r19, 0x00	; 0
    2a3e:	45 e5       	ldi	r20, 0x55	; 85
    2a40:	50 e0       	ldi	r21, 0x00	; 0
    2a42:	62 e1       	ldi	r22, 0x12	; 18
    2a44:	70 e2       	ldi	r23, 0x20	; 32
    2a46:	86 e1       	ldi	r24, 0x16	; 22
    2a48:	96 e1       	ldi	r25, 0x16	; 22
    2a4a:	a7 db       	rcall	.-2226   	; 0x219a <xTaskGenericCreate>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2a4c:	01 c0       	rjmp	.+2      	; 0x2a50 <xTimerCreateTimerTask+0x40>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2a4e:	80 e0       	ldi	r24, 0x00	; 0
    2a50:	0f 91       	pop	r16
    2a52:	ff 90       	pop	r15
    2a54:	ef 90       	pop	r14
    2a56:	df 90       	pop	r13
    2a58:	cf 90       	pop	r12
    2a5a:	bf 90       	pop	r11
    2a5c:	af 90       	pop	r10
    2a5e:	08 95       	ret

00002a60 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2a60:	8f 92       	push	r8
    2a62:	9f 92       	push	r9
    2a64:	bf 92       	push	r11
    2a66:	cf 92       	push	r12
    2a68:	df 92       	push	r13
    2a6a:	ef 92       	push	r14
    2a6c:	ff 92       	push	r15
    2a6e:	0f 93       	push	r16
    2a70:	1f 93       	push	r17
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2a76:	61 15       	cp	r22, r1
    2a78:	71 05       	cpc	r23, r1
    2a7a:	c9 f0       	breq	.+50     	; 0x2aae <xTimerCreate+0x4e>
    2a7c:	69 01       	movw	r12, r18
    2a7e:	b4 2e       	mov	r11, r20
    2a80:	7b 01       	movw	r14, r22
    2a82:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2a84:	83 e1       	ldi	r24, 0x13	; 19
    2a86:	90 e0       	ldi	r25, 0x00	; 0
    2a88:	ae d8       	rcall	.-3748   	; 0x1be6 <pvPortMalloc>
    2a8a:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2a8c:	89 2b       	or	r24, r25
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2a8e:	89 f0       	breq	.+34     	; 0x2ab2 <xTimerCreate+0x52>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2a90:	97 df       	rcall	.-210    	; 0x29c0 <prvCheckForValidListAndQueue>
    2a92:	88 82       	st	Y, r8
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2a94:	99 82       	std	Y+1, r9	; 0x01
    2a96:	ec 86       	std	Y+12, r14	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    2a98:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->pvTimerID = pvTimerID;
    2a9a:	be 86       	std	Y+14, r11	; 0x0e
    2a9c:	cf 86       	std	Y+15, r12	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2a9e:	d8 8a       	std	Y+16, r13	; 0x10
    2aa0:	09 8b       	std	Y+17, r16	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2aa2:	1a 8b       	std	Y+18, r17	; 0x12
    2aa4:	ce 01       	movw	r24, r28
    2aa6:	02 96       	adiw	r24, 0x02	; 2
    2aa8:	0e 94 09 0c 	call	0x1812	; 0x1812 <vListInitialiseItem>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2aac:	02 c0       	rjmp	.+4      	; 0x2ab2 <xTimerCreate+0x52>
    2aae:	c0 e0       	ldi	r28, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2ab0:	d0 e0       	ldi	r29, 0x00	; 0
    2ab2:	ce 01       	movw	r24, r28
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	1f 91       	pop	r17
    2aba:	0f 91       	pop	r16
    2abc:	ff 90       	pop	r15
    2abe:	ef 90       	pop	r14
    2ac0:	df 90       	pop	r13
    2ac2:	cf 90       	pop	r12
    2ac4:	bf 90       	pop	r11
    2ac6:	9f 90       	pop	r9
    2ac8:	8f 90       	pop	r8
    2aca:	08 95       	ret

00002acc <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2acc:	0f 93       	push	r16
    2ace:	1f 93       	push	r17
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	cd b7       	in	r28, 0x3d	; 61
    2ad6:	de b7       	in	r29, 0x3e	; 62
    2ad8:	25 97       	sbiw	r28, 0x05	; 5
    2ada:	cd bf       	out	0x3d, r28	; 61
    2adc:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2ade:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <xTimerQueue>
    2ae2:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
    2ae6:	30 97       	sbiw	r30, 0x00	; 0
    2ae8:	51 f1       	breq	.+84     	; 0x2b3e <xTimerGenericCommand+0x72>
    2aea:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2aec:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2aee:	4a 83       	std	Y+2, r20	; 0x02
    2af0:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2af2:	8c 83       	std	Y+4, r24	; 0x04
    2af4:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2af6:	66 30       	cpi	r22, 0x06	; 6
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2af8:	d4 f4       	brge	.+52     	; 0x2b2e <xTimerGenericCommand+0x62>
    2afa:	25 df       	rcall	.-438    	; 0x2946 <xTaskGetSchedulerState>
    2afc:	82 30       	cpi	r24, 0x02	; 2
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2afe:	59 f4       	brne	.+22     	; 0x2b16 <xTimerGenericCommand+0x4a>
    2b00:	20 e0       	ldi	r18, 0x00	; 0
    2b02:	a8 01       	movw	r20, r16
    2b04:	be 01       	movw	r22, r28
    2b06:	6f 5f       	subi	r22, 0xFF	; 255
    2b08:	7f 4f       	sbci	r23, 0xFF	; 255
    2b0a:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>
    2b0e:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
    2b12:	92 d9       	rcall	.-3292   	; 0x1e38 <xQueueGenericSend>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2b14:	15 c0       	rjmp	.+42     	; 0x2b40 <xTimerGenericCommand+0x74>
    2b16:	20 e0       	ldi	r18, 0x00	; 0
    2b18:	40 e0       	ldi	r20, 0x00	; 0
    2b1a:	50 e0       	ldi	r21, 0x00	; 0
    2b1c:	be 01       	movw	r22, r28
    2b1e:	6f 5f       	subi	r22, 0xFF	; 255
    2b20:	7f 4f       	sbci	r23, 0xFF	; 255
    2b22:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>
    2b26:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
    2b2a:	86 d9       	rcall	.-3316   	; 0x1e38 <xQueueGenericSend>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2b2c:	09 c0       	rjmp	.+18     	; 0x2b40 <xTimerGenericCommand+0x74>
    2b2e:	20 e0       	ldi	r18, 0x00	; 0
    2b30:	ad 01       	movw	r20, r26
    2b32:	be 01       	movw	r22, r28
    2b34:	6f 5f       	subi	r22, 0xFF	; 255
    2b36:	7f 4f       	sbci	r23, 0xFF	; 255
    2b38:	cf 01       	movw	r24, r30
    2b3a:	0b da       	rcall	.-3050   	; 0x1f52 <xQueueGenericSendFromISR>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2b3c:	01 c0       	rjmp	.+2      	; 0x2b40 <xTimerGenericCommand+0x74>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2b3e:	80 e0       	ldi	r24, 0x00	; 0
    2b40:	25 96       	adiw	r28, 0x05	; 5
    2b42:	cd bf       	out	0x3d, r28	; 61
    2b44:	de bf       	out	0x3e, r29	; 62
    2b46:	df 91       	pop	r29
    2b48:	cf 91       	pop	r28
    2b4a:	1f 91       	pop	r17
    2b4c:	0f 91       	pop	r16
    2b4e:	08 95       	ret

00002b50 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2b50:	af 92       	push	r10
    2b52:	bf 92       	push	r11
    2b54:	cf 92       	push	r12
    2b56:	df 92       	push	r13
    2b58:	ef 92       	push	r14
    2b5a:	ff 92       	push	r15
    2b5c:	0f 93       	push	r16
    2b5e:	1f 93       	push	r17
    2b60:	cf 93       	push	r28
    2b62:	df 93       	push	r29
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2b64:	6c 01       	movw	r12, r24
    2b66:	53 dc       	rcall	.-1882   	; 0x240e <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    2b68:	7c 01       	movw	r14, r24
    2b6a:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xLastTime.4459>
    2b6e:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xLastTime.4459+0x1>
    2b72:	e8 16       	cp	r14, r24
    2b74:	f9 06       	cpc	r15, r25
    2b76:	08 f0       	brcs	.+2      	; 0x2b7a <prvSampleTimeNow+0x2a>
    2b78:	47 c0       	rjmp	.+142    	; 0x2c08 <prvSampleTimeNow+0xb8>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b7a:	2f c0       	rjmp	.+94     	; 0x2bda <prvSampleTimeNow+0x8a>
    2b7c:	05 80       	ldd	r0, Z+5	; 0x05
    2b7e:	f6 81       	ldd	r31, Z+6	; 0x06
    2b80:	e0 2d       	mov	r30, r0
    2b82:	a0 80       	ld	r10, Z

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b84:	b1 80       	ldd	r11, Z+1	; 0x01
    2b86:	c6 81       	ldd	r28, Z+6	; 0x06
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b88:	d7 81       	ldd	r29, Z+7	; 0x07
    2b8a:	8e 01       	movw	r16, r28
    2b8c:	0e 5f       	subi	r16, 0xFE	; 254
    2b8e:	1f 4f       	sbci	r17, 0xFF	; 255
    2b90:	c8 01       	movw	r24, r16
    2b92:	0e 94 5f 0c 	call	0x18be	; 0x18be <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b96:	e9 89       	ldd	r30, Y+17	; 0x11
    2b98:	fa 89       	ldd	r31, Y+18	; 0x12
    2b9a:	ce 01       	movw	r24, r28

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2b9c:	19 95       	eicall
    2b9e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2ba0:	81 30       	cpi	r24, 0x01	; 1
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2ba2:	d9 f4       	brne	.+54     	; 0x2bda <prvSampleTimeNow+0x8a>
    2ba4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ba6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2ba8:	8a 0d       	add	r24, r10
			if( xReloadTime > xNextExpireTime )
    2baa:	9b 1d       	adc	r25, r11
    2bac:	a8 16       	cp	r10, r24
    2bae:	b9 06       	cpc	r11, r25
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2bb0:	60 f4       	brcc	.+24     	; 0x2bca <prvSampleTimeNow+0x7a>
    2bb2:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2bb4:	9b 83       	std	Y+3, r25	; 0x03
    2bb6:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2bb8:	d9 87       	std	Y+9, r29	; 0x09
    2bba:	b8 01       	movw	r22, r16
    2bbc:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTimerList>
    2bc0:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTimerList+0x1>
    2bc4:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2bc8:	08 c0       	rjmp	.+16     	; 0x2bda <prvSampleTimeNow+0x8a>
    2bca:	00 e0       	ldi	r16, 0x00	; 0
    2bcc:	10 e0       	ldi	r17, 0x00	; 0
    2bce:	20 e0       	ldi	r18, 0x00	; 0
    2bd0:	30 e0       	ldi	r19, 0x00	; 0
    2bd2:	a5 01       	movw	r20, r10
    2bd4:	60 e0       	ldi	r22, 0x00	; 0
    2bd6:	ce 01       	movw	r24, r28

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2bd8:	79 df       	rcall	.-270    	; 0x2acc <xTimerGenericCommand>
    2bda:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTimerList>
    2bde:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTimerList+0x1>
    2be2:	80 81       	ld	r24, Z
    2be4:	81 11       	cpse	r24, r1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2be6:	ca cf       	rjmp	.-108    	; 0x2b7c <prvSampleTimeNow+0x2c>
    2be8:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <pxOverflowTimerList>
    2bec:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <pxOverflowTimerList+0x1>
    2bf0:	80 93 c0 22 	sts	0x22C0, r24	; 0x8022c0 <pxCurrentTimerList>
    2bf4:	90 93 c1 22 	sts	0x22C1, r25	; 0x8022c1 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    2bf8:	e0 93 be 22 	sts	0x22BE, r30	; 0x8022be <pxOverflowTimerList>
    2bfc:	f0 93 bf 22 	sts	0x22BF, r31	; 0x8022bf <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2c00:	81 e0       	ldi	r24, 0x01	; 1
    2c02:	f6 01       	movw	r30, r12
    2c04:	80 83       	st	Z, r24
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2c06:	02 c0       	rjmp	.+4      	; 0x2c0c <prvSampleTimeNow+0xbc>
    2c08:	f6 01       	movw	r30, r12
	}

	xLastTime = xTimeNow;
    2c0a:	10 82       	st	Z, r1
    2c0c:	e0 92 ba 22 	sts	0x22BA, r14	; 0x8022ba <xLastTime.4459>
    2c10:	f0 92 bb 22 	sts	0x22BB, r15	; 0x8022bb <xLastTime.4459+0x1>

	return xTimeNow;
}
    2c14:	c7 01       	movw	r24, r14
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	1f 91       	pop	r17
    2c1c:	0f 91       	pop	r16
    2c1e:	ff 90       	pop	r15
    2c20:	ef 90       	pop	r14
    2c22:	df 90       	pop	r13
    2c24:	cf 90       	pop	r12
    2c26:	bf 90       	pop	r11
    2c28:	af 90       	pop	r10
    2c2a:	08 95       	ret

00002c2c <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2c2c:	cf 93       	push	r28
    2c2e:	df 93       	push	r29
    2c30:	00 d0       	rcall	.+0      	; 0x2c32 <prvTimerTask+0x6>
    2c32:	00 d0       	rcall	.+0      	; 0x2c34 <prvTimerTask+0x8>
    2c34:	cd b7       	in	r28, 0x3d	; 61
    2c36:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c38:	ce 01       	movw	r24, r28
    2c3a:	01 96       	adiw	r24, 0x01	; 1
    2c3c:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2c3e:	e8 2e       	mov	r14, r24
    2c40:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2c42:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTimerList>
    2c46:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    2c4a:	80 81       	ld	r24, Z
    2c4c:	88 23       	and	r24, r24
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <prvTimerTask+0x26>
    2c50:	b6 c0       	rjmp	.+364    	; 0x2dbe <prvTimerTask+0x192>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2c52:	05 80       	ldd	r0, Z+5	; 0x05
    2c54:	f6 81       	ldd	r31, Z+6	; 0x06
    2c56:	e0 2d       	mov	r30, r0
    2c58:	c0 80       	ld	r12, Z
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c5a:	d1 80       	ldd	r13, Z+1	; 0x01
    2c5c:	d2 db       	rcall	.-2140   	; 0x2402 <vTaskSuspendAll>
    2c5e:	c5 01       	movw	r24, r10
		if( xTimerListsWereSwitched == pdFALSE )
    2c60:	77 df       	rcall	.-274    	; 0x2b50 <prvSampleTimeNow>
    2c62:	8c 01       	movw	r16, r24
    2c64:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c66:	81 11       	cpse	r24, r1
    2c68:	42 c0       	rjmp	.+132    	; 0x2cee <prvTimerTask+0xc2>
			{
				( void ) xTaskResumeAll();
    2c6a:	0c 15       	cp	r16, r12
    2c6c:	1d 05       	cpc	r17, r13
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2c6e:	80 f1       	brcs	.+96     	; 0x2cd0 <prvTimerTask+0xa4>
    2c70:	ab dc       	rcall	.-1706   	; 0x25c8 <xTaskResumeAll>
    2c72:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTimerList>
    2c76:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTimerList+0x1>
    2c7a:	05 80       	ldd	r0, Z+5	; 0x05
    2c7c:	f6 81       	ldd	r31, Z+6	; 0x06
    2c7e:	e0 2d       	mov	r30, r0

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c80:	86 80       	ldd	r8, Z+6	; 0x06
    2c82:	97 80       	ldd	r9, Z+7	; 0x07
    2c84:	c4 01       	movw	r24, r8
    2c86:	02 96       	adiw	r24, 0x02	; 2
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2c88:	0e 94 5f 0c 	call	0x18be	; 0x18be <uxListRemove>
    2c8c:	d4 01       	movw	r26, r8
    2c8e:	1e 96       	adiw	r26, 0x0e	; 14
    2c90:	8c 91       	ld	r24, X
    2c92:	1e 97       	sbiw	r26, 0x0e	; 14
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2c94:	81 30       	cpi	r24, 0x01	; 1
    2c96:	a1 f4       	brne	.+40     	; 0x2cc0 <prvTimerTask+0x94>
    2c98:	1c 96       	adiw	r26, 0x0c	; 12
    2c9a:	6d 91       	ld	r22, X+
    2c9c:	7c 91       	ld	r23, X
    2c9e:	1d 97       	sbiw	r26, 0x0d	; 13
    2ca0:	6c 0d       	add	r22, r12
    2ca2:	7d 1d       	adc	r23, r13
    2ca4:	96 01       	movw	r18, r12
    2ca6:	a8 01       	movw	r20, r16
    2ca8:	c4 01       	movw	r24, r8
    2caa:	5b de       	rcall	.-842    	; 0x2962 <prvInsertTimerInActiveList>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2cac:	81 30       	cpi	r24, 0x01	; 1
    2cae:	41 f4       	brne	.+16     	; 0x2cc0 <prvTimerTask+0x94>
    2cb0:	00 e0       	ldi	r16, 0x00	; 0
    2cb2:	10 e0       	ldi	r17, 0x00	; 0
    2cb4:	20 e0       	ldi	r18, 0x00	; 0
    2cb6:	30 e0       	ldi	r19, 0x00	; 0
    2cb8:	a6 01       	movw	r20, r12
    2cba:	60 e0       	ldi	r22, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2cbc:	c4 01       	movw	r24, r8
    2cbe:	06 df       	rcall	.-500    	; 0x2acc <xTimerGenericCommand>
    2cc0:	d4 01       	movw	r26, r8
    2cc2:	51 96       	adiw	r26, 0x11	; 17
    2cc4:	ed 91       	ld	r30, X+
    2cc6:	fc 91       	ld	r31, X
    2cc8:	52 97       	sbiw	r26, 0x12	; 18
    2cca:	c4 01       	movw	r24, r8
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2ccc:	19 95       	eicall
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2cce:	6a c0       	rjmp	.+212    	; 0x2da4 <prvTimerTask+0x178>
    2cd0:	40 e0       	ldi	r20, 0x00	; 0
    2cd2:	b6 01       	movw	r22, r12
    2cd4:	60 1b       	sub	r22, r16
    2cd6:	71 0b       	sbc	r23, r17
    2cd8:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>

				if( xTaskResumeAll() == pdFALSE )
    2cdc:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2ce0:	05 da       	rcall	.-3062   	; 0x20ec <vQueueWaitForMessageRestricted>
    2ce2:	72 dc       	rcall	.-1820   	; 0x25c8 <xTaskResumeAll>
    2ce4:	81 11       	cpse	r24, r1
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2ce6:	5e c0       	rjmp	.+188    	; 0x2da4 <prvTimerTask+0x178>
    2ce8:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <vPortYield>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2cec:	5b c0       	rjmp	.+182    	; 0x2da4 <prvTimerTask+0x178>
    2cee:	6c dc       	rcall	.-1832   	; 0x25c8 <xTaskResumeAll>
    2cf0:	59 c0       	rjmp	.+178    	; 0x2da4 <prvTimerTask+0x178>
    2cf2:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2cf4:	88 23       	and	r24, r24
    2cf6:	0c f4       	brge	.+2      	; 0x2cfa <prvTimerTask+0xce>

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2cf8:	55 c0       	rjmp	.+170    	; 0x2da4 <prvTimerTask+0x178>
    2cfa:	cc 80       	ldd	r12, Y+4	; 0x04
    2cfc:	dd 80       	ldd	r13, Y+5	; 0x05
    2cfe:	f6 01       	movw	r30, r12
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2d00:	82 85       	ldd	r24, Z+10	; 0x0a
    2d02:	93 85       	ldd	r25, Z+11	; 0x0b
    2d04:	89 2b       	or	r24, r25
    2d06:	21 f0       	breq	.+8      	; 0x2d10 <prvTimerTask+0xe4>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2d08:	c6 01       	movw	r24, r12
    2d0a:	02 96       	adiw	r24, 0x02	; 2
    2d0c:	0e 94 5f 0c 	call	0x18be	; 0x18be <uxListRemove>
    2d10:	ce 01       	movw	r24, r28

			switch( xMessage.xMessageID )
    2d12:	06 96       	adiw	r24, 0x06	; 6
    2d14:	1d df       	rcall	.-454    	; 0x2b50 <prvSampleTimeNow>
    2d16:	ac 01       	movw	r20, r24
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	08 2e       	mov	r0, r24
    2d1c:	00 0c       	add	r0, r0
    2d1e:	99 0b       	sbc	r25, r25
    2d20:	aa 0b       	sbc	r26, r26
    2d22:	bb 0b       	sbc	r27, r27
    2d24:	8a 30       	cpi	r24, 0x0A	; 10
    2d26:	91 05       	cpc	r25, r1
    2d28:	08 f0       	brcs	.+2      	; 0x2d2c <prvTimerTask+0x100>
    2d2a:	3c c0       	rjmp	.+120    	; 0x2da4 <prvTimerTask+0x178>
    2d2c:	fc 01       	movw	r30, r24
    2d2e:	88 27       	eor	r24, r24
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    2d30:	e2 50       	subi	r30, 0x02	; 2
    2d32:	ff 4f       	sbci	r31, 0xFF	; 255
    2d34:	8f 4f       	sbci	r24, 0xFF	; 255
    2d36:	9e c5       	rjmp	.+2876   	; 0x3874 <__tablejump2__>
    2d38:	2a 81       	ldd	r18, Y+2	; 0x02
    2d3a:	3b 81       	ldd	r19, Y+3	; 0x03
    2d3c:	d6 01       	movw	r26, r12
    2d3e:	1c 96       	adiw	r26, 0x0c	; 12
    2d40:	6d 91       	ld	r22, X+
    2d42:	7c 91       	ld	r23, X
    2d44:	1d 97       	sbiw	r26, 0x0d	; 13
    2d46:	62 0f       	add	r22, r18
    2d48:	73 1f       	adc	r23, r19
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d4a:	c6 01       	movw	r24, r12
    2d4c:	0a de       	rcall	.-1004   	; 0x2962 <prvInsertTimerInActiveList>
    2d4e:	81 30       	cpi	r24, 0x01	; 1
    2d50:	49 f5       	brne	.+82     	; 0x2da4 <prvTimerTask+0x178>
    2d52:	d6 01       	movw	r26, r12
    2d54:	51 96       	adiw	r26, 0x11	; 17
    2d56:	ed 91       	ld	r30, X+
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2d58:	fc 91       	ld	r31, X
    2d5a:	52 97       	sbiw	r26, 0x12	; 18
    2d5c:	c6 01       	movw	r24, r12
    2d5e:	19 95       	eicall
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2d60:	f6 01       	movw	r30, r12
    2d62:	86 85       	ldd	r24, Z+14	; 0x0e
    2d64:	81 30       	cpi	r24, 0x01	; 1
    2d66:	f1 f4       	brne	.+60     	; 0x2da4 <prvTimerTask+0x178>
    2d68:	4a 81       	ldd	r20, Y+2	; 0x02
    2d6a:	5b 81       	ldd	r21, Y+3	; 0x03
    2d6c:	84 85       	ldd	r24, Z+12	; 0x0c
    2d6e:	95 85       	ldd	r25, Z+13	; 0x0d
    2d70:	48 0f       	add	r20, r24
    2d72:	59 1f       	adc	r21, r25
    2d74:	00 e0       	ldi	r16, 0x00	; 0
    2d76:	10 e0       	ldi	r17, 0x00	; 0
    2d78:	20 e0       	ldi	r18, 0x00	; 0
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
    2d7c:	60 e0       	ldi	r22, 0x00	; 0
    2d7e:	c6 01       	movw	r24, r12
    2d80:	a5 de       	rcall	.-694    	; 0x2acc <xTimerGenericCommand>
    2d82:	10 c0       	rjmp	.+32     	; 0x2da4 <prvTimerTask+0x178>
    2d84:	6a 81       	ldd	r22, Y+2	; 0x02
    2d86:	7b 81       	ldd	r23, Y+3	; 0x03
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d88:	d6 01       	movw	r26, r12
    2d8a:	1c 96       	adiw	r26, 0x0c	; 12
    2d8c:	6d 93       	st	X+, r22
    2d8e:	7c 93       	st	X, r23
    2d90:	1d 97       	sbiw	r26, 0x0d	; 13
    2d92:	64 0f       	add	r22, r20
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2d94:	75 1f       	adc	r23, r21
    2d96:	9a 01       	movw	r18, r20
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d98:	c6 01       	movw	r24, r12
    2d9a:	e3 dd       	rcall	.-1082   	; 0x2962 <prvInsertTimerInActiveList>
    2d9c:	03 c0       	rjmp	.+6      	; 0x2da4 <prvTimerTask+0x178>
    2d9e:	c6 01       	movw	r24, r12
    2da0:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vPortFree>
    2da4:	20 e0       	ldi	r18, 0x00	; 0
    2da6:	40 e0       	ldi	r20, 0x00	; 0
    2da8:	50 e0       	ldi	r21, 0x00	; 0
    2daa:	6e 2d       	mov	r22, r14
    2dac:	7f 2d       	mov	r23, r15
    2dae:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xTimerQueue>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2db2:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xTimerQueue+0x1>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2db6:	03 d9       	rcall	.-3578   	; 0x1fbe <xQueueGenericReceive>
    2db8:	81 11       	cpse	r24, r1
    2dba:	9b cf       	rjmp	.-202    	; 0x2cf2 <prvTimerTask+0xc6>
		if( xTimerListsWereSwitched == pdFALSE )
    2dbc:	42 cf       	rjmp	.-380    	; 0x2c42 <prvTimerTask+0x16>
    2dbe:	21 db       	rcall	.-2494   	; 0x2402 <vTaskSuspendAll>
    2dc0:	c5 01       	movw	r24, r10
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2dc2:	c6 de       	rcall	.-628    	; 0x2b50 <prvSampleTimeNow>
    2dc4:	8c 01       	movw	r16, r24
    2dc6:	89 81       	ldd	r24, Y+1	; 0x01
    2dc8:	81 11       	cpse	r24, r1
    2dca:	91 cf       	rjmp	.-222    	; 0x2cee <prvTimerTask+0xc2>
    2dcc:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <pxOverflowTimerList>
    2dd0:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <pxOverflowTimerList+0x1>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2dd4:	41 e0       	ldi	r20, 0x01	; 1
    2dd6:	80 81       	ld	r24, Z
    2dd8:	81 11       	cpse	r24, r1
    2dda:	40 e0       	ldi	r20, 0x00	; 0
    2ddc:	c1 2c       	mov	r12, r1
    2dde:	d1 2c       	mov	r13, r1
    2de0:	78 cf       	rjmp	.-272    	; 0x2cd2 <prvTimerTask+0xa6>

00002de2 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2de8:	20 e0       	ldi	r18, 0x00	; 0
    2dea:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    2dec:	c6 2f       	mov	r28, r22
    2dee:	d0 e0       	ldi	r29, 0x00	; 0
    2df0:	de 01       	movw	r26, r28
    2df2:	02 2e       	mov	r0, r18
    2df4:	02 c0       	rjmp	.+4      	; 0x2dfa <ioport_configure_port_pin+0x18>
    2df6:	b5 95       	asr	r27
    2df8:	a7 95       	ror	r26
    2dfa:	0a 94       	dec	r0
    2dfc:	e2 f7       	brpl	.-8      	; 0x2df6 <ioport_configure_port_pin+0x14>
    2dfe:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2e00:	50 8b       	std	Z+16, r21	; 0x10
    2e02:	2f 5f       	subi	r18, 0xFF	; 255
    2e04:	3f 4f       	sbci	r19, 0xFF	; 255
    2e06:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    2e08:	28 30       	cpi	r18, 0x08	; 8
    2e0a:	31 05       	cpc	r19, r1
    2e0c:	89 f7       	brne	.-30     	; 0x2df0 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    2e0e:	40 ff       	sbrs	r20, 0
    2e10:	0a c0       	rjmp	.+20     	; 0x2e26 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    2e12:	41 ff       	sbrs	r20, 1
    2e14:	03 c0       	rjmp	.+6      	; 0x2e1c <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    2e16:	fc 01       	movw	r30, r24
    2e18:	65 83       	std	Z+5, r22	; 0x05
    2e1a:	02 c0       	rjmp	.+4      	; 0x2e20 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    2e1c:	fc 01       	movw	r30, r24
    2e1e:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    2e20:	fc 01       	movw	r30, r24
    2e22:	61 83       	std	Z+1, r22	; 0x01
    2e24:	02 c0       	rjmp	.+4      	; 0x2e2a <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    2e26:	fc 01       	movw	r30, r24
    2e28:	62 83       	std	Z+2, r22	; 0x02
	}
}
    2e2a:	df 91       	pop	r29
    2e2c:	cf 91       	pop	r28
    2e2e:	08 95       	ret

00002e30 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    2e30:	43 e0       	ldi	r20, 0x03	; 3
    2e32:	50 e0       	ldi	r21, 0x00	; 0
    2e34:	61 e0       	ldi	r22, 0x01	; 1
    2e36:	80 ee       	ldi	r24, 0xE0	; 224
    2e38:	97 e0       	ldi	r25, 0x07	; 7
    2e3a:	d3 df       	rcall	.-90     	; 0x2de2 <ioport_configure_port_pin>
    2e3c:	43 e0       	ldi	r20, 0x03	; 3
    2e3e:	50 e0       	ldi	r21, 0x00	; 0
    2e40:	62 e0       	ldi	r22, 0x02	; 2
    2e42:	80 ee       	ldi	r24, 0xE0	; 224
    2e44:	97 e0       	ldi	r25, 0x07	; 7
    2e46:	cd df       	rcall	.-102    	; 0x2de2 <ioport_configure_port_pin>
    2e48:	43 e0       	ldi	r20, 0x03	; 3
    2e4a:	50 e0       	ldi	r21, 0x00	; 0
    2e4c:	60 e1       	ldi	r22, 0x10	; 16
    2e4e:	80 e6       	ldi	r24, 0x60	; 96
    2e50:	96 e0       	ldi	r25, 0x06	; 6
    2e52:	c7 df       	rcall	.-114    	; 0x2de2 <ioport_configure_port_pin>
    2e54:	41 e0       	ldi	r20, 0x01	; 1
    2e56:	50 e4       	ldi	r21, 0x40	; 64
    2e58:	60 e2       	ldi	r22, 0x20	; 32
    2e5a:	80 e6       	ldi	r24, 0x60	; 96
    2e5c:	96 e0       	ldi	r25, 0x06	; 6
    2e5e:	c1 df       	rcall	.-126    	; 0x2de2 <ioport_configure_port_pin>
    2e60:	40 e0       	ldi	r20, 0x00	; 0
    2e62:	5b e1       	ldi	r21, 0x1B	; 27
    2e64:	60 e2       	ldi	r22, 0x20	; 32
    2e66:	80 e8       	ldi	r24, 0x80	; 128
    2e68:	96 e0       	ldi	r25, 0x06	; 6
    2e6a:	bb df       	rcall	.-138    	; 0x2de2 <ioport_configure_port_pin>
    2e6c:	40 e0       	ldi	r20, 0x00	; 0
    2e6e:	5b e1       	ldi	r21, 0x1B	; 27
    2e70:	62 e0       	ldi	r22, 0x02	; 2
    2e72:	80 ea       	ldi	r24, 0xA0	; 160
    2e74:	96 e0       	ldi	r25, 0x06	; 6
    2e76:	b5 df       	rcall	.-150    	; 0x2de2 <ioport_configure_port_pin>
    2e78:	40 e0       	ldi	r20, 0x00	; 0
    2e7a:	5b e1       	ldi	r21, 0x1B	; 27
    2e7c:	64 e0       	ldi	r22, 0x04	; 4
    2e7e:	80 ea       	ldi	r24, 0xA0	; 160
    2e80:	96 e0       	ldi	r25, 0x06	; 6
    2e82:	af df       	rcall	.-162    	; 0x2de2 <ioport_configure_port_pin>
    2e84:	43 e0       	ldi	r20, 0x03	; 3
    2e86:	50 e0       	ldi	r21, 0x00	; 0
    2e88:	62 e0       	ldi	r22, 0x02	; 2
    2e8a:	80 e6       	ldi	r24, 0x60	; 96
    2e8c:	96 e0       	ldi	r25, 0x06	; 6
    2e8e:	a9 df       	rcall	.-174    	; 0x2de2 <ioport_configure_port_pin>
    2e90:	43 e0       	ldi	r20, 0x03	; 3
    2e92:	50 e0       	ldi	r21, 0x00	; 0
    2e94:	68 e0       	ldi	r22, 0x08	; 8
    2e96:	80 e6       	ldi	r24, 0x60	; 96
    2e98:	96 e0       	ldi	r25, 0x06	; 6
    2e9a:	a3 df       	rcall	.-186    	; 0x2de2 <ioport_configure_port_pin>
    2e9c:	43 e0       	ldi	r20, 0x03	; 3
    2e9e:	50 e0       	ldi	r21, 0x00	; 0
    2ea0:	68 e0       	ldi	r22, 0x08	; 8
    2ea2:	80 ea       	ldi	r24, 0xA0	; 160
    2ea4:	96 e0       	ldi	r25, 0x06	; 6
    2ea6:	9d df       	rcall	.-198    	; 0x2de2 <ioport_configure_port_pin>
    2ea8:	43 e0       	ldi	r20, 0x03	; 3
    2eaa:	50 e0       	ldi	r21, 0x00	; 0
    2eac:	61 e0       	ldi	r22, 0x01	; 1
    2eae:	80 e6       	ldi	r24, 0x60	; 96
    2eb0:	96 e0       	ldi	r25, 0x06	; 6
    2eb2:	97 df       	rcall	.-210    	; 0x2de2 <ioport_configure_port_pin>
    2eb4:	43 e0       	ldi	r20, 0x03	; 3
    2eb6:	50 e0       	ldi	r21, 0x00	; 0
    2eb8:	68 e0       	ldi	r22, 0x08	; 8
    2eba:	80 e0       	ldi	r24, 0x00	; 0
    2ebc:	96 e0       	ldi	r25, 0x06	; 6
    2ebe:	91 df       	rcall	.-222    	; 0x2de2 <ioport_configure_port_pin>
    2ec0:	41 e0       	ldi	r20, 0x01	; 1
    2ec2:	50 e0       	ldi	r21, 0x00	; 0
    2ec4:	60 e1       	ldi	r22, 0x10	; 16
    2ec6:	80 e8       	ldi	r24, 0x80	; 128
    2ec8:	96 e0       	ldi	r25, 0x06	; 6
    2eca:	8b df       	rcall	.-234    	; 0x2de2 <ioport_configure_port_pin>
    2ecc:	43 e0       	ldi	r20, 0x03	; 3
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	62 e0       	ldi	r22, 0x02	; 2
    2ed2:	80 e6       	ldi	r24, 0x60	; 96
    2ed4:	96 e0       	ldi	r25, 0x06	; 6
    2ed6:	85 df       	rcall	.-246    	; 0x2de2 <ioport_configure_port_pin>
    2ed8:	43 e0       	ldi	r20, 0x03	; 3
    2eda:	50 e0       	ldi	r21, 0x00	; 0
    2edc:	68 e0       	ldi	r22, 0x08	; 8
    2ede:	80 e6       	ldi	r24, 0x60	; 96
    2ee0:	96 e0       	ldi	r25, 0x06	; 6
    2ee2:	7f df       	rcall	.-258    	; 0x2de2 <ioport_configure_port_pin>
    2ee4:	40 e0       	ldi	r20, 0x00	; 0
    2ee6:	50 e0       	ldi	r21, 0x00	; 0
    2ee8:	64 e0       	ldi	r22, 0x04	; 4
    2eea:	80 e6       	ldi	r24, 0x60	; 96
    2eec:	96 e0       	ldi	r25, 0x06	; 6
    2eee:	79 df       	rcall	.-270    	; 0x2de2 <ioport_configure_port_pin>
    2ef0:	43 e0       	ldi	r20, 0x03	; 3
    2ef2:	50 e0       	ldi	r21, 0x00	; 0
    2ef4:	60 e1       	ldi	r22, 0x10	; 16
    2ef6:	80 ea       	ldi	r24, 0xA0	; 160
    2ef8:	96 e0       	ldi	r25, 0x06	; 6
    2efa:	73 df       	rcall	.-282    	; 0x2de2 <ioport_configure_port_pin>
    2efc:	40 e0       	ldi	r20, 0x00	; 0
    2efe:	50 e0       	ldi	r21, 0x00	; 0
    2f00:	61 e0       	ldi	r22, 0x01	; 1
    2f02:	80 e0       	ldi	r24, 0x00	; 0
    2f04:	96 e0       	ldi	r25, 0x06	; 6
    2f06:	6d df       	rcall	.-294    	; 0x2de2 <ioport_configure_port_pin>
    2f08:	40 e0       	ldi	r20, 0x00	; 0
    2f0a:	50 e0       	ldi	r21, 0x00	; 0
    2f0c:	64 e0       	ldi	r22, 0x04	; 4
    2f0e:	80 e0       	ldi	r24, 0x00	; 0
    2f10:	96 e0       	ldi	r25, 0x06	; 6
    2f12:	67 df       	rcall	.-306    	; 0x2de2 <ioport_configure_port_pin>
    2f14:	40 e0       	ldi	r20, 0x00	; 0
    2f16:	50 e0       	ldi	r21, 0x00	; 0
    2f18:	62 e0       	ldi	r22, 0x02	; 2
    2f1a:	80 e2       	ldi	r24, 0x20	; 32
    2f1c:	96 e0       	ldi	r25, 0x06	; 6
    2f1e:	61 df       	rcall	.-318    	; 0x2de2 <ioport_configure_port_pin>
    2f20:	43 e0       	ldi	r20, 0x03	; 3
    2f22:	50 e0       	ldi	r21, 0x00	; 0
    2f24:	68 e0       	ldi	r22, 0x08	; 8
    2f26:	80 e4       	ldi	r24, 0x40	; 64
    2f28:	96 e0       	ldi	r25, 0x06	; 6
    2f2a:	5b df       	rcall	.-330    	; 0x2de2 <ioport_configure_port_pin>
    2f2c:	40 e0       	ldi	r20, 0x00	; 0
    2f2e:	50 e0       	ldi	r21, 0x00	; 0
    2f30:	64 e0       	ldi	r22, 0x04	; 4
    2f32:	80 e4       	ldi	r24, 0x40	; 64
    2f34:	96 e0       	ldi	r25, 0x06	; 6
    2f36:	55 df       	rcall	.-342    	; 0x2de2 <ioport_configure_port_pin>
    2f38:	43 e0       	ldi	r20, 0x03	; 3
    2f3a:	50 e0       	ldi	r21, 0x00	; 0
    2f3c:	68 e0       	ldi	r22, 0x08	; 8
    2f3e:	80 e6       	ldi	r24, 0x60	; 96
    2f40:	96 e0       	ldi	r25, 0x06	; 6
    2f42:	4f df       	rcall	.-354    	; 0x2de2 <ioport_configure_port_pin>
    2f44:	40 e0       	ldi	r20, 0x00	; 0
    2f46:	50 e0       	ldi	r21, 0x00	; 0
    2f48:	64 e0       	ldi	r22, 0x04	; 4
    2f4a:	80 e6       	ldi	r24, 0x60	; 96
    2f4c:	96 e0       	ldi	r25, 0x06	; 6
    2f4e:	49 df       	rcall	.-366    	; 0x2de2 <ioport_configure_port_pin>
    2f50:	43 e0       	ldi	r20, 0x03	; 3
    2f52:	50 e0       	ldi	r21, 0x00	; 0
    2f54:	68 e0       	ldi	r22, 0x08	; 8
    2f56:	80 e8       	ldi	r24, 0x80	; 128
    2f58:	96 e0       	ldi	r25, 0x06	; 6
    2f5a:	43 df       	rcall	.-378    	; 0x2de2 <ioport_configure_port_pin>
    2f5c:	40 e0       	ldi	r20, 0x00	; 0
    2f5e:	50 e0       	ldi	r21, 0x00	; 0
    2f60:	64 e0       	ldi	r22, 0x04	; 4
    2f62:	80 e8       	ldi	r24, 0x80	; 128
    2f64:	96 e0       	ldi	r25, 0x06	; 6
    2f66:	3d cf       	rjmp	.-390    	; 0x2de2 <ioport_configure_port_pin>
    2f68:	08 95       	ret

00002f6a <vTimerCallback>:
static portTASK_FUNCTION_PROTO(testTempS, p_);
static portTASK_FUNCTION_PROTO(testServo, p_);
static portTASK_FUNCTION_PROTO(testMoisture, p_);

void vTimerCallback(){
	increment++;
    2f6a:	80 91 9d 23 	lds	r24, 0x239D	; 0x80239d <increment>
    2f6e:	90 91 9e 23 	lds	r25, 0x239E	; 0x80239e <increment+0x1>
    2f72:	a0 91 9f 23 	lds	r26, 0x239F	; 0x80239f <increment+0x2>
    2f76:	b0 91 a0 23 	lds	r27, 0x23A0	; 0x8023a0 <increment+0x3>
    2f7a:	01 96       	adiw	r24, 0x01	; 1
    2f7c:	a1 1d       	adc	r26, r1
    2f7e:	b1 1d       	adc	r27, r1
    2f80:	80 93 9d 23 	sts	0x239D, r24	; 0x80239d <increment>
    2f84:	90 93 9e 23 	sts	0x239E, r25	; 0x80239e <increment+0x1>
    2f88:	a0 93 9f 23 	sts	0x239F, r26	; 0x80239f <increment+0x2>
    2f8c:	b0 93 a0 23 	sts	0x23A0, r27	; 0x8023a0 <increment+0x3>
    2f90:	08 95       	ret

00002f92 <testLamp>:
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2f92:	c0 ee       	ldi	r28, 0xE0	; 224
    2f94:	d7 e0       	ldi	r29, 0x07	; 7
    2f96:	11 e0       	ldi	r17, 0x01	; 1
    2f98:	01 2f       	mov	r16, r17
    2f9a:	0e 83       	std	Y+6, r16	; 0x06
static portTASK_FUNCTION(testLamp, p_){
	//ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, false);
	
	while(1){
		gpio_set_pin_low(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2f9c:	82 e3       	ldi	r24, 0x32	; 50
    2f9e:	90 e0       	ldi	r25, 0x00	; 0
    2fa0:	90 db       	rcall	.-2272   	; 0x26c2 <vTaskDelay>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2fa2:	1d 83       	std	Y+5, r17	; 0x05
		gpio_set_pin_high(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2fa4:	82 e3       	ldi	r24, 0x32	; 50
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	8c db       	rcall	.-2280   	; 0x26c2 <vTaskDelay>
    2faa:	f7 cf       	rjmp	.-18     	; 0x2f9a <testLamp+0x8>

00002fac <testMoisture>:
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
}

static uint16_t adc_read(){
	uint16_t result;
	adc_enable(&MY_ADC);
    2fac:	c0 e0       	ldi	r28, 0x00	; 0
    2fae:	d2 e0       	ldi	r29, 0x02	; 2
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2fb0:	11 e0       	ldi	r17, 0x01	; 1
    2fb2:	ce 01       	movw	r24, r28
    2fb4:	0e 94 96 07 	call	0xf2c	; 0xf2c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2fb8:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    2fba:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2fbc:	88 81       	ld	r24, Y
    2fbe:	84 60       	ori	r24, 0x04	; 4
    2fc0:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2fc2:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2fc4:	8e 81       	ldd	r24, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2fc6:	80 ff       	sbrs	r24, 0
    2fc8:	fd cf       	rjmp	.-6      	; 0x2fc4 <testMoisture+0x18>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2fca:	1e 83       	std	Y+6, r17	; 0x06
	adc_start_conversion(&MY_ADC, MY_ADC_CH);
	adc_wait_for_interrupt_flag(&MY_ADC, MY_ADC_CH);
	result = adc_get_result(&MY_ADC, MY_ADC_CH);
    2fcc:	6c a1       	ldd	r22, Y+36	; 0x24
    2fce:	7d a1       	ldd	r23, Y+37	; 0x25
		int8_t adc_value;
		float moisture;
		adc_value = adc_read();	/* Copy the ADC value */
		moisture = 100-(adc_value*100.00)/1023.00; /* Calculate moisture in % */
		int a = moisture;
		result3 = a;
    2fd0:	06 2e       	mov	r0, r22
    2fd2:	00 0c       	add	r0, r0
    2fd4:	77 0b       	sbc	r23, r23
    2fd6:	88 0b       	sbc	r24, r24
    2fd8:	99 0b       	sbc	r25, r25
    2fda:	3b d3       	rcall	.+1654   	; 0x3652 <__floatsisf>
    2fdc:	20 e0       	ldi	r18, 0x00	; 0
    2fde:	30 e0       	ldi	r19, 0x00	; 0
    2fe0:	48 ec       	ldi	r20, 0xC8	; 200
    2fe2:	52 e4       	ldi	r21, 0x42	; 66
    2fe4:	c2 d3       	rcall	.+1924   	; 0x376a <__mulsf3>
    2fe6:	20 e0       	ldi	r18, 0x00	; 0
    2fe8:	30 ec       	ldi	r19, 0xC0	; 192
    2fea:	4f e7       	ldi	r20, 0x7F	; 127
    2fec:	54 e4       	ldi	r21, 0x44	; 68
    2fee:	96 d2       	rcall	.+1324   	; 0x351c <__divsf3>
    2ff0:	9b 01       	movw	r18, r22
    2ff2:	ac 01       	movw	r20, r24
    2ff4:	60 e0       	ldi	r22, 0x00	; 0
    2ff6:	70 e0       	ldi	r23, 0x00	; 0
    2ff8:	88 ec       	ldi	r24, 0xC8	; 200
    2ffa:	92 e4       	ldi	r25, 0x42	; 66
    2ffc:	2a d2       	rcall	.+1108   	; 0x3452 <__subsf3>
    2ffe:	f6 d2       	rcall	.+1516   	; 0x35ec <__fixsfsi>
    3000:	60 93 a1 23 	sts	0x23A1, r22	; 0x8023a1 <result3>
    3004:	70 93 a2 23 	sts	0x23A2, r23	; 0x8023a2 <result3+0x1>
		vTaskDelay(10/portTICK_PERIOD_MS);
    3008:	85 e0       	ldi	r24, 0x05	; 5
    300a:	90 e0       	ldi	r25, 0x00	; 0
    300c:	5a db       	rcall	.-2380   	; 0x26c2 <vTaskDelay>
	}
    300e:	d1 cf       	rjmp	.-94     	; 0x2fb2 <testMoisture+0x6>

00003010 <testTempS>:
		}
		vTaskDelay(10/portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(testTempS, p_){
    3010:	cf 93       	push	r28
    3012:	df 93       	push	r29
    3014:	1f 92       	push	r1
    3016:	cd b7       	in	r28, 0x3d	; 61
    3018:	de b7       	in	r29, 0x3e	; 62
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    301a:	00 e0       	ldi	r16, 0x00	; 0
    301c:	12 e0       	ldi	r17, 0x02	; 2

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    301e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    3020:	f8 94       	cli
    3022:	f8 01       	movw	r30, r16
    3024:	80 81       	ld	r24, Z
    3026:	88 60       	ori	r24, 0x08	; 8
    3028:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    302a:	9f bf       	out	0x3f, r25	; 63
	while(1){
		ntc_measure();												// Mengambil data dari pengukuran suhu oleh NTC temperature sensor
		while(!ntc_data_is_ready());								// Menunggu data sampai siap untuk ditampilkan
    302c:	0e 94 73 02 	call	0x4e6	; 0x4e6 <ntc_data_is_ready>
    3030:	88 23       	and	r24, r24
    3032:	e1 f3       	breq	.-8      	; 0x302c <testTempS+0x1c>
		volatile int8_t temperature = ntc_get_temperature();	// Mengambil hasil olah data dalam Celcius
    3034:	0e 94 8b 02 	call	0x516	; 0x516 <ntc_get_temperature>
    3038:	89 83       	std	Y+1, r24	; 0x01
		result2 = temperature;
    303a:	89 81       	ldd	r24, Y+1	; 0x01
    303c:	08 2e       	mov	r0, r24
    303e:	00 0c       	add	r0, r0
    3040:	99 0b       	sbc	r25, r25
    3042:	80 93 a3 23 	sts	0x23A3, r24	; 0x8023a3 <result2>
    3046:	90 93 a4 23 	sts	0x23A4, r25	; 0x8023a4 <result2+0x1>
		vTaskDelay(10/portTICK_PERIOD_MS);
    304a:	85 e0       	ldi	r24, 0x05	; 5
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	39 db       	rcall	.-2446   	; 0x26c2 <vTaskDelay>
	}
    3050:	e6 cf       	rjmp	.-52     	; 0x301e <testTempS+0xe>

00003052 <testLightS>:
    3052:	c0 e0       	ldi	r28, 0x00	; 0
    3054:	d2 e0       	ldi	r29, 0x02	; 2
		// Dikarenakan hasil yang diperoleh merupakan data raw diperlukan sampling agar mendapatkan hasil yang baik
		if(iterations++ >= LIGHTSENSOR_NUM_SAMPLES) {
			iterations = 0;
			intensity /= LIGHTSENSOR_NUM_SAMPLES;
			
			result = intensity;
    3056:	0f 2e       	mov	r0, r31
    3058:	f4 e1       	ldi	r31, 0x14	; 20
    305a:	cf 2e       	mov	r12, r31
    305c:	d1 2c       	mov	r13, r1
    305e:	e1 2c       	mov	r14, r1
    3060:	f1 2c       	mov	r15, r1
    3062:	f0 2d       	mov	r31, r0

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    3064:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    3066:	f8 94       	cli
    3068:	88 81       	ld	r24, Y
    306a:	84 60       	ori	r24, 0x04	; 4
    306c:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    306e:	9f bf       	out	0x3f, r25	; 63
}

static portTASK_FUNCTION(testLightS, p_){
	while(1){
		lightsensor_measure();									// Mengambil data dari pengukuran intensitas oleh light sensor
		while(!lightsensor_data_is_ready());					// Menunggu data sampai siap untuk ditampilkan
    3070:	0e 94 7f 02 	call	0x4fe	; 0x4fe <lightsensor_data_is_ready>
    3074:	88 23       	and	r24, r24
    3076:	e1 f3       	breq	.-8      	; 0x3070 <testLightS+0x1e>
		intensity += lightsensor_get_raw_value();				// Mengambil hasil olah data dalam raw ADC value
    3078:	0e 94 bb 02 	call	0x576	; 0x576 <lightsensor_get_raw_value>
    307c:	09 2e       	mov	r0, r25
    307e:	00 0c       	add	r0, r0
    3080:	aa 0b       	sbc	r26, r26
    3082:	bb 0b       	sbc	r27, r27
    3084:	40 91 a8 23 	lds	r20, 0x23A8	; 0x8023a8 <intensity>
    3088:	50 91 a9 23 	lds	r21, 0x23A9	; 0x8023a9 <intensity+0x1>
    308c:	60 91 aa 23 	lds	r22, 0x23AA	; 0x8023aa <intensity+0x2>
    3090:	70 91 ab 23 	lds	r23, 0x23AB	; 0x8023ab <intensity+0x3>
    3094:	8c 01       	movw	r16, r24
    3096:	9d 01       	movw	r18, r26
    3098:	04 0f       	add	r16, r20
    309a:	15 1f       	adc	r17, r21
    309c:	26 1f       	adc	r18, r22
    309e:	37 1f       	adc	r19, r23
    30a0:	c9 01       	movw	r24, r18
    30a2:	b8 01       	movw	r22, r16
    30a4:	00 93 a8 23 	sts	0x23A8, r16	; 0x8023a8 <intensity>
    30a8:	10 93 a9 23 	sts	0x23A9, r17	; 0x8023a9 <intensity+0x1>
    30ac:	20 93 aa 23 	sts	0x23AA, r18	; 0x8023aa <intensity+0x2>
    30b0:	30 93 ab 23 	sts	0x23AB, r19	; 0x8023ab <intensity+0x3>

		// Dikarenakan hasil yang diperoleh merupakan data raw diperlukan sampling agar mendapatkan hasil yang baik
		if(iterations++ >= LIGHTSENSOR_NUM_SAMPLES) {
    30b4:	20 91 a7 23 	lds	r18, 0x23A7	; 0x8023a7 <iterations>
    30b8:	24 31       	cpi	r18, 0x14	; 20
    30ba:	20 f4       	brcc	.+8      	; 0x30c4 <testLightS+0x72>
    30bc:	2f 5f       	subi	r18, 0xFF	; 255
    30be:	20 93 a7 23 	sts	0x23A7, r18	; 0x8023a7 <iterations>
    30c2:	11 c0       	rjmp	.+34     	; 0x30e6 <testLightS+0x94>
			iterations = 0;
    30c4:	10 92 a7 23 	sts	0x23A7, r1	; 0x8023a7 <iterations>
			intensity /= LIGHTSENSOR_NUM_SAMPLES;
			
			result = intensity;
    30c8:	a7 01       	movw	r20, r14
    30ca:	96 01       	movw	r18, r12
    30cc:	b1 d3       	rcall	.+1890   	; 0x3830 <__udivmodsi4>
    30ce:	20 93 a5 23 	sts	0x23A5, r18	; 0x8023a5 <result>
    30d2:	30 93 a6 23 	sts	0x23A6, r19	; 0x8023a6 <result+0x1>

			intensity = 0;
    30d6:	10 92 a8 23 	sts	0x23A8, r1	; 0x8023a8 <intensity>
    30da:	10 92 a9 23 	sts	0x23A9, r1	; 0x8023a9 <intensity+0x1>
    30de:	10 92 aa 23 	sts	0x23AA, r1	; 0x8023aa <intensity+0x2>
    30e2:	10 92 ab 23 	sts	0x23AB, r1	; 0x8023ab <intensity+0x3>
		}
		vTaskDelay(10/portTICK_PERIOD_MS);
    30e6:	85 e0       	ldi	r24, 0x05	; 5
    30e8:	90 e0       	ldi	r25, 0x00	; 0
    30ea:	eb da       	rcall	.-2602   	; 0x26c2 <vTaskDelay>
	}
    30ec:	bb cf       	rjmp	.-138    	; 0x3064 <testLightS+0x12>

000030ee <testLCD>:
    30ee:	80 e1       	ldi	r24, 0x10	; 16
    30f0:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    30f4:	0f 2e       	mov	r0, r31
    30f6:	fa e1       	ldi	r31, 0x1A	; 26
    30f8:	af 2e       	mov	r10, r31
    30fa:	f0 e2       	ldi	r31, 0x20	; 32
    30fc:	bf 2e       	mov	r11, r31
    30fe:	f0 2d       	mov	r31, r0
    3100:	19 ec       	ldi	r17, 0xC9	; 201
    3102:	c4 ed       	ldi	r28, 0xD4	; 212
    3104:	d2 e2       	ldi	r29, 0x22	; 34
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    3106:	0f 2e       	mov	r0, r31
    3108:	fb e2       	ldi	r31, 0x2B	; 43
    310a:	cf 2e       	mov	r12, r31
    310c:	f0 e2       	ldi	r31, 0x20	; 32
    310e:	df 2e       	mov	r13, r31
    3110:	f0 2d       	mov	r31, r0
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Moisture : %3d",result3);
    3112:	0f 2e       	mov	r0, r31
    3114:	fb e3       	ldi	r31, 0x3B	; 59
    3116:	ef 2e       	mov	r14, r31
    3118:	f0 e2       	ldi	r31, 0x20	; 32
    311a:	ff 2e       	mov	r15, r31
    311c:	f0 2d       	mov	r31, r0
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    311e:	80 91 a6 23 	lds	r24, 0x23A6	; 0x8023a6 <result+0x1>
    3122:	8f 93       	push	r24
    3124:	80 91 a5 23 	lds	r24, 0x23A5	; 0x8023a5 <result>
    3128:	8f 93       	push	r24
    312a:	bf 92       	push	r11
    312c:	af 92       	push	r10
    312e:	1f 92       	push	r1
    3130:	1f 93       	push	r17
    3132:	df 93       	push	r29
    3134:	cf 93       	push	r28
    3136:	d0 d4       	rcall	.+2464   	; 0x3ad8 <snprintf>
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
    3138:	26 e0       	ldi	r18, 0x06	; 6
    313a:	30 e2       	ldi	r19, 0x20	; 32
    313c:	40 e0       	ldi	r20, 0x00	; 0
    313e:	60 e0       	ldi	r22, 0x00	; 0
    3140:	ce 01       	movw	r24, r28
    3142:	0e 94 bc 06 	call	0xd78	; 0xd78 <gfx_mono_draw_string>
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    3146:	80 91 a4 23 	lds	r24, 0x23A4	; 0x8023a4 <result2+0x1>
    314a:	8f 93       	push	r24
    314c:	80 91 a3 23 	lds	r24, 0x23A3	; 0x8023a3 <result2>
    3150:	8f 93       	push	r24
    3152:	df 92       	push	r13
    3154:	cf 92       	push	r12
    3156:	1f 92       	push	r1
    3158:	1f 93       	push	r17
    315a:	df 93       	push	r29
    315c:	cf 93       	push	r28
    315e:	bc d4       	rcall	.+2424   	; 0x3ad8 <snprintf>
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
    3160:	26 e0       	ldi	r18, 0x06	; 6
    3162:	30 e2       	ldi	r19, 0x20	; 32
    3164:	4a e0       	ldi	r20, 0x0A	; 10
    3166:	60 e0       	ldi	r22, 0x00	; 0
    3168:	ce 01       	movw	r24, r28
    316a:	0e 94 bc 06 	call	0xd78	; 0xd78 <gfx_mono_draw_string>
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Moisture : %3d",result3);
    316e:	80 91 a2 23 	lds	r24, 0x23A2	; 0x8023a2 <result3+0x1>
    3172:	8f 93       	push	r24
    3174:	80 91 a1 23 	lds	r24, 0x23A1	; 0x8023a1 <result3>
    3178:	8f 93       	push	r24
    317a:	ff 92       	push	r15
    317c:	ef 92       	push	r14
    317e:	1f 92       	push	r1
    3180:	1f 93       	push	r17
    3182:	df 93       	push	r29
    3184:	cf 93       	push	r28
    3186:	a8 d4       	rcall	.+2384   	; 0x3ad8 <snprintf>
		gfx_mono_draw_string(strbuf,0, 20, &sysfont);
    3188:	26 e0       	ldi	r18, 0x06	; 6
    318a:	30 e2       	ldi	r19, 0x20	; 32
    318c:	44 e1       	ldi	r20, 0x14	; 20
    318e:	60 e0       	ldi	r22, 0x00	; 0
    3190:	ce 01       	movw	r24, r28
    3192:	0e 94 bc 06 	call	0xd78	; 0xd78 <gfx_mono_draw_string>
		
		vTaskDelay(5/portTICK_PERIOD_MS);
    3196:	82 e0       	ldi	r24, 0x02	; 2
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	93 da       	rcall	.-2778   	; 0x26c2 <vTaskDelay>
    319c:	8d b7       	in	r24, 0x3d	; 61
    319e:	9e b7       	in	r25, 0x3e	; 62
    31a0:	48 96       	adiw	r24, 0x18	; 24
    31a2:	8d bf       	out	0x3d, r24	; 61
    31a4:	9e bf       	out	0x3e, r25	; 62
    31a6:	bb cf       	rjmp	.-138    	; 0x311e <testLCD+0x30>

000031a8 <PWM_Init>:
}

void PWM_Init(void)
{
	/* Set output */
	PORTC.DIR |= PIN0_bm;
    31a8:	e0 e4       	ldi	r30, 0x40	; 64
    31aa:	f6 e0       	ldi	r31, 0x06	; 6
    31ac:	80 81       	ld	r24, Z
    31ae:	81 60       	ori	r24, 0x01	; 1
    31b0:	80 83       	st	Z, r24

	/* Set Register */
	TCC0.CTRLA = (PIN2_bm) | (PIN0_bm);
    31b2:	e0 e0       	ldi	r30, 0x00	; 0
    31b4:	f8 e0       	ldi	r31, 0x08	; 8
    31b6:	85 e0       	ldi	r24, 0x05	; 5
    31b8:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    31ba:	86 e1       	ldi	r24, 0x16	; 22
    31bc:	81 83       	std	Z+1, r24	; 0x01
	
	/* Set Period */
	TCC0.PER = 1000;
    31be:	88 ee       	ldi	r24, 0xE8	; 232
    31c0:	93 e0       	ldi	r25, 0x03	; 3
    31c2:	86 a3       	std	Z+38, r24	; 0x26
    31c4:	97 a3       	std	Z+39, r25	; 0x27

	/* Set Compare Register value*/
	TCC0.CCA = 375;
    31c6:	87 e7       	ldi	r24, 0x77	; 119
    31c8:	91 e0       	ldi	r25, 0x01	; 1
    31ca:	80 a7       	std	Z+40, r24	; 0x28
    31cc:	91 a7       	std	Z+41, r25	; 0x29
    31ce:	08 95       	ret

000031d0 <testServo>:
    31d0:	eb df       	rcall	.-42     	; 0x31a8 <PWM_Init>
    31d2:	e0 ea       	ldi	r30, 0xA0	; 160
    31d4:	f6 e0       	ldi	r31, 0x06	; 6
    31d6:	c0 e0       	ldi	r28, 0x00	; 0
    31d8:	d8 e0       	ldi	r29, 0x08	; 8
    31da:	6e e5       	ldi	r22, 0x5E	; 94
    31dc:	71 e0       	ldi	r23, 0x01	; 1
    31de:	a0 e6       	ldi	r26, 0x60	; 96
    31e0:	b6 e0       	ldi	r27, 0x06	; 6
    31e2:	10 e2       	ldi	r17, 0x20	; 32
    31e4:	90 e1       	ldi	r25, 0x10	; 16
    31e6:	41 e0       	ldi	r20, 0x01	; 1
    31e8:	50 e0       	ldi	r21, 0x00	; 0
    31ea:	22 e8       	ldi	r18, 0x82	; 130
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	80 85       	ldd	r24, Z+8	; 0x08
    31f0:	81 fd       	sbrc	r24, 1
    31f2:	0c c0       	rjmp	.+24     	; 0x320c <testServo+0x3c>
    31f4:	80 85       	ldd	r24, Z+8	; 0x08
    31f6:	82 ff       	sbrs	r24, 2
    31f8:	09 c0       	rjmp	.+18     	; 0x320c <testServo+0x3c>
    31fa:	28 a7       	std	Y+40, r18	; 0x28
    31fc:	39 a7       	std	Y+41, r19	; 0x29
    31fe:	16 96       	adiw	r26, 0x06	; 6
    3200:	9c 93       	st	X, r25
    3202:	16 97       	sbiw	r26, 0x06	; 6
    3204:	15 96       	adiw	r26, 0x05	; 5
    3206:	1c 93       	st	X, r17
    3208:	15 97       	sbiw	r26, 0x05	; 5
    320a:	f1 cf       	rjmp	.-30     	; 0x31ee <testServo+0x1e>
    320c:	80 85       	ldd	r24, Z+8	; 0x08
    320e:	82 fd       	sbrc	r24, 2
    3210:	0c c0       	rjmp	.+24     	; 0x322a <testServo+0x5a>
    3212:	80 85       	ldd	r24, Z+8	; 0x08
    3214:	81 ff       	sbrs	r24, 1
    3216:	09 c0       	rjmp	.+18     	; 0x322a <testServo+0x5a>
    3218:	48 a7       	std	Y+40, r20	; 0x28
    321a:	59 a7       	std	Y+41, r21	; 0x29
    321c:	16 96       	adiw	r26, 0x06	; 6
    321e:	1c 93       	st	X, r17
    3220:	16 97       	sbiw	r26, 0x06	; 6
    3222:	15 96       	adiw	r26, 0x05	; 5
    3224:	9c 93       	st	X, r25
    3226:	15 97       	sbiw	r26, 0x05	; 5
    3228:	e2 cf       	rjmp	.-60     	; 0x31ee <testServo+0x1e>
    322a:	80 85       	ldd	r24, Z+8	; 0x08
    322c:	81 ff       	sbrs	r24, 1
    322e:	df cf       	rjmp	.-66     	; 0x31ee <testServo+0x1e>
    3230:	80 85       	ldd	r24, Z+8	; 0x08
    3232:	82 ff       	sbrs	r24, 2
    3234:	dc cf       	rjmp	.-72     	; 0x31ee <testServo+0x1e>
    3236:	68 a7       	std	Y+40, r22	; 0x28
    3238:	79 a7       	std	Y+41, r23	; 0x29
    323a:	15 96       	adiw	r26, 0x05	; 5
    323c:	1c 93       	st	X, r17
    323e:	15 97       	sbiw	r26, 0x05	; 5
    3240:	15 96       	adiw	r26, 0x05	; 5
    3242:	9c 93       	st	X, r25
    3244:	15 97       	sbiw	r26, 0x05	; 5
    3246:	d3 cf       	rjmp	.-90     	; 0x31ee <testServo+0x1e>

00003248 <main>:
    3248:	8f 92       	push	r8
    324a:	9f 92       	push	r9
    324c:	af 92       	push	r10
    324e:	bf 92       	push	r11
    3250:	cf 92       	push	r12
    3252:	df 92       	push	r13
    3254:	ef 92       	push	r14
    3256:	ff 92       	push	r15
    3258:	0f 93       	push	r16
    325a:	1f 93       	push	r17
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
    3260:	cd b7       	in	r28, 0x3d	; 61
    3262:	de b7       	in	r29, 0x3e	; 62
    3264:	2b 97       	sbiw	r28, 0x0b	; 11
    3266:	cd bf       	out	0x3d, r28	; 61
    3268:	de bf       	out	0x3e, r29	; 62
    326a:	e2 dd       	rcall	.-1084   	; 0x2e30 <board_init>
    326c:	87 e0       	ldi	r24, 0x07	; 7
    326e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    3272:	be 01       	movw	r22, r28
    3274:	6f 5f       	subi	r22, 0xFF	; 255
    3276:	7f 4f       	sbci	r23, 0xFF	; 255
    3278:	80 e0       	ldi	r24, 0x00	; 0
    327a:	92 e0       	ldi	r25, 0x02	; 2
    327c:	0e 94 8d 09 	call	0x131a	; 0x131a <adc_read_configuration>
    3280:	ae 01       	movw	r20, r28
    3282:	48 5f       	subi	r20, 0xF8	; 248
    3284:	5f 4f       	sbci	r21, 0xFF	; 255
    3286:	61 e0       	ldi	r22, 0x01	; 1
    3288:	80 e0       	ldi	r24, 0x00	; 0
    328a:	92 e0       	ldi	r25, 0x02	; 2
    328c:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <adcch_read_configuration>
    3290:	9a 81       	ldd	r25, Y+2	; 0x02
    3292:	8b 81       	ldd	r24, Y+3	; 0x03
    3294:	8f 78       	andi	r24, 0x8F	; 143
    3296:	80 61       	ori	r24, 0x10	; 16
    3298:	8b 83       	std	Y+3, r24	; 0x03
    329a:	89 2f       	mov	r24, r25
    329c:	81 7e       	andi	r24, 0xE1	; 225
    329e:	8a 83       	std	Y+2, r24	; 0x02
    32a0:	1c 82       	std	Y+4, r1	; 0x04
    32a2:	02 e0       	ldi	r16, 0x02	; 2
    32a4:	0d 83       	std	Y+5, r16	; 0x05
    32a6:	11 e0       	ldi	r17, 0x01	; 1
    32a8:	18 87       	std	Y+8, r17	; 0x08
    32aa:	19 86       	std	Y+9, r1	; 0x09
    32ac:	be 01       	movw	r22, r28
    32ae:	6f 5f       	subi	r22, 0xFF	; 255
    32b0:	7f 4f       	sbci	r23, 0xFF	; 255
    32b2:	80 e0       	ldi	r24, 0x00	; 0
    32b4:	92 e0       	ldi	r25, 0x02	; 2
    32b6:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_write_configuration>
    32ba:	ae 01       	movw	r20, r28
    32bc:	48 5f       	subi	r20, 0xF8	; 248
    32be:	5f 4f       	sbci	r21, 0xFF	; 255
    32c0:	61 e0       	ldi	r22, 0x01	; 1
    32c2:	80 e0       	ldi	r24, 0x00	; 0
    32c4:	92 e0       	ldi	r25, 0x02	; 2
    32c6:	0e 94 b0 09 	call	0x1360	; 0x1360 <adcch_write_configuration>
    32ca:	be 01       	movw	r22, r28
    32cc:	6f 5f       	subi	r22, 0xFF	; 255
    32ce:	7f 4f       	sbci	r23, 0xFF	; 255
    32d0:	80 e0       	ldi	r24, 0x00	; 0
    32d2:	92 e0       	ldi	r25, 0x02	; 2
    32d4:	0e 94 8d 09 	call	0x131a	; 0x131a <adc_read_configuration>
    32d8:	ae 01       	movw	r20, r28
    32da:	48 5f       	subi	r20, 0xF8	; 248
    32dc:	5f 4f       	sbci	r21, 0xFF	; 255
    32de:	62 e0       	ldi	r22, 0x02	; 2
    32e0:	80 e0       	ldi	r24, 0x00	; 0
    32e2:	92 e0       	ldi	r25, 0x02	; 2
    32e4:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <adcch_read_configuration>
    32e8:	9a 81       	ldd	r25, Y+2	; 0x02
    32ea:	8b 81       	ldd	r24, Y+3	; 0x03
    32ec:	8f 78       	andi	r24, 0x8F	; 143
    32ee:	80 61       	ori	r24, 0x10	; 16
    32f0:	8b 83       	std	Y+3, r24	; 0x03
    32f2:	89 2f       	mov	r24, r25
    32f4:	81 7e       	andi	r24, 0xE1	; 225
    32f6:	8a 83       	std	Y+2, r24	; 0x02
    32f8:	1c 82       	std	Y+4, r1	; 0x04
    32fa:	0d 83       	std	Y+5, r16	; 0x05
    32fc:	18 87       	std	Y+8, r17	; 0x08
    32fe:	88 e0       	ldi	r24, 0x08	; 8
    3300:	89 87       	std	Y+9, r24	; 0x09
    3302:	be 01       	movw	r22, r28
    3304:	6f 5f       	subi	r22, 0xFF	; 255
    3306:	7f 4f       	sbci	r23, 0xFF	; 255
    3308:	80 e0       	ldi	r24, 0x00	; 0
    330a:	92 e0       	ldi	r25, 0x02	; 2
    330c:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_write_configuration>
    3310:	ae 01       	movw	r20, r28
    3312:	48 5f       	subi	r20, 0xF8	; 248
    3314:	5f 4f       	sbci	r21, 0xFF	; 255
    3316:	62 e0       	ldi	r22, 0x02	; 2
    3318:	80 e0       	ldi	r24, 0x00	; 0
    331a:	92 e0       	ldi	r25, 0x02	; 2
    331c:	0e 94 b0 09 	call	0x1360	; 0x1360 <adcch_write_configuration>
    3320:	be 01       	movw	r22, r28
    3322:	6f 5f       	subi	r22, 0xFF	; 255
    3324:	7f 4f       	sbci	r23, 0xFF	; 255
    3326:	80 e0       	ldi	r24, 0x00	; 0
    3328:	92 e0       	ldi	r25, 0x02	; 2
    332a:	0e 94 8d 09 	call	0x131a	; 0x131a <adc_read_configuration>
    332e:	ae 01       	movw	r20, r28
    3330:	48 5f       	subi	r20, 0xF8	; 248
    3332:	5f 4f       	sbci	r21, 0xFF	; 255
    3334:	64 e0       	ldi	r22, 0x04	; 4
    3336:	80 e0       	ldi	r24, 0x00	; 0
    3338:	92 e0       	ldi	r25, 0x02	; 2
    333a:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <adcch_read_configuration>
    333e:	9a 81       	ldd	r25, Y+2	; 0x02
    3340:	8b 81       	ldd	r24, Y+3	; 0x03
    3342:	8f 78       	andi	r24, 0x8F	; 143
    3344:	80 61       	ori	r24, 0x10	; 16
    3346:	8b 83       	std	Y+3, r24	; 0x03
    3348:	89 2f       	mov	r24, r25
    334a:	81 7e       	andi	r24, 0xE1	; 225
    334c:	8a 83       	std	Y+2, r24	; 0x02
    334e:	1c 82       	std	Y+4, r1	; 0x04
    3350:	0d 83       	std	Y+5, r16	; 0x05
    3352:	18 87       	std	Y+8, r17	; 0x08
    3354:	80 e1       	ldi	r24, 0x10	; 16
    3356:	89 87       	std	Y+9, r24	; 0x09
    3358:	be 01       	movw	r22, r28
    335a:	6f 5f       	subi	r22, 0xFF	; 255
    335c:	7f 4f       	sbci	r23, 0xFF	; 255
    335e:	80 e0       	ldi	r24, 0x00	; 0
    3360:	92 e0       	ldi	r25, 0x02	; 2
    3362:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_write_configuration>
    3366:	ae 01       	movw	r20, r28
    3368:	48 5f       	subi	r20, 0xF8	; 248
    336a:	5f 4f       	sbci	r21, 0xFF	; 255
    336c:	64 e0       	ldi	r22, 0x04	; 4
    336e:	80 e0       	ldi	r24, 0x00	; 0
    3370:	92 e0       	ldi	r25, 0x02	; 2
    3372:	0e 94 b0 09 	call	0x1360	; 0x1360 <adcch_write_configuration>
    3376:	0e 94 48 05 	call	0xa90	; 0xa90 <gfx_mono_st7565r_init>
    337a:	05 eb       	ldi	r16, 0xB5	; 181
    337c:	17 e1       	ldi	r17, 0x17	; 23
    337e:	20 e0       	ldi	r18, 0x00	; 0
    3380:	30 e0       	ldi	r19, 0x00	; 0
    3382:	41 e0       	ldi	r20, 0x01	; 1
    3384:	61 e0       	ldi	r22, 0x01	; 1
    3386:	70 e0       	ldi	r23, 0x00	; 0
    3388:	8f e4       	ldi	r24, 0x4F	; 79
    338a:	90 e2       	ldi	r25, 0x20	; 32
    338c:	69 db       	rcall	.-2350   	; 0x2a60 <xTimerCreate>
    338e:	4c 01       	movw	r8, r24
    3390:	a1 2c       	mov	r10, r1
    3392:	b1 2c       	mov	r11, r1
    3394:	c1 2c       	mov	r12, r1
    3396:	d1 2c       	mov	r13, r1
    3398:	e1 2c       	mov	r14, r1
    339a:	f1 2c       	mov	r15, r1
    339c:	01 e0       	ldi	r16, 0x01	; 1
    339e:	20 e0       	ldi	r18, 0x00	; 0
    33a0:	30 e0       	ldi	r19, 0x00	; 0
    33a2:	44 ef       	ldi	r20, 0xF4	; 244
    33a4:	51 e0       	ldi	r21, 0x01	; 1
    33a6:	61 e1       	ldi	r22, 0x11	; 17
    33a8:	70 e2       	ldi	r23, 0x20	; 32
    33aa:	89 ec       	ldi	r24, 0xC9	; 201
    33ac:	97 e1       	ldi	r25, 0x17	; 23
    33ae:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    33b2:	20 e0       	ldi	r18, 0x00	; 0
    33b4:	30 e0       	ldi	r19, 0x00	; 0
    33b6:	44 ef       	ldi	r20, 0xF4	; 244
    33b8:	51 e0       	ldi	r21, 0x01	; 1
    33ba:	61 e1       	ldi	r22, 0x11	; 17
    33bc:	70 e2       	ldi	r23, 0x20	; 32
    33be:	87 e7       	ldi	r24, 0x77	; 119
    33c0:	98 e1       	ldi	r25, 0x18	; 24
    33c2:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    33c6:	20 e0       	ldi	r18, 0x00	; 0
    33c8:	30 e0       	ldi	r19, 0x00	; 0
    33ca:	44 ef       	ldi	r20, 0xF4	; 244
    33cc:	51 e0       	ldi	r21, 0x01	; 1
    33ce:	61 e1       	ldi	r22, 0x11	; 17
    33d0:	70 e2       	ldi	r23, 0x20	; 32
    33d2:	89 e2       	ldi	r24, 0x29	; 41
    33d4:	98 e1       	ldi	r25, 0x18	; 24
    33d6:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    33da:	20 e0       	ldi	r18, 0x00	; 0
    33dc:	30 e0       	ldi	r19, 0x00	; 0
    33de:	44 ef       	ldi	r20, 0xF4	; 244
    33e0:	51 e0       	ldi	r21, 0x01	; 1
    33e2:	61 e1       	ldi	r22, 0x11	; 17
    33e4:	70 e2       	ldi	r23, 0x20	; 32
    33e6:	88 e0       	ldi	r24, 0x08	; 8
    33e8:	98 e1       	ldi	r25, 0x18	; 24
    33ea:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    33ee:	20 e0       	ldi	r18, 0x00	; 0
    33f0:	30 e0       	ldi	r19, 0x00	; 0
    33f2:	44 ef       	ldi	r20, 0xF4	; 244
    33f4:	51 e0       	ldi	r21, 0x01	; 1
    33f6:	61 e1       	ldi	r22, 0x11	; 17
    33f8:	70 e2       	ldi	r23, 0x20	; 32
    33fa:	88 ee       	ldi	r24, 0xE8	; 232
    33fc:	98 e1       	ldi	r25, 0x18	; 24
    33fe:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    3402:	20 e0       	ldi	r18, 0x00	; 0
    3404:	30 e0       	ldi	r19, 0x00	; 0
    3406:	44 ef       	ldi	r20, 0xF4	; 244
    3408:	51 e0       	ldi	r21, 0x01	; 1
    340a:	61 e1       	ldi	r22, 0x11	; 17
    340c:	70 e2       	ldi	r23, 0x20	; 32
    340e:	86 ed       	ldi	r24, 0xD6	; 214
    3410:	97 e1       	ldi	r25, 0x17	; 23
    3412:	0e 94 cd 10 	call	0x219a	; 0x219a <xTaskGenericCreate>
    3416:	0e 94 07 12 	call	0x240e	; 0x240e <xTaskGetTickCount>
    341a:	00 e0       	ldi	r16, 0x00	; 0
    341c:	10 e0       	ldi	r17, 0x00	; 0
    341e:	20 e0       	ldi	r18, 0x00	; 0
    3420:	30 e0       	ldi	r19, 0x00	; 0
    3422:	ac 01       	movw	r20, r24
    3424:	61 e0       	ldi	r22, 0x01	; 1
    3426:	c4 01       	movw	r24, r8
    3428:	51 db       	rcall	.-2398   	; 0x2acc <xTimerGenericCommand>
    342a:	0e 94 ce 11 	call	0x239c	; 0x239c <vTaskStartScheduler>
    342e:	80 e0       	ldi	r24, 0x00	; 0
    3430:	90 e0       	ldi	r25, 0x00	; 0
    3432:	2b 96       	adiw	r28, 0x0b	; 11
    3434:	cd bf       	out	0x3d, r28	; 61
    3436:	de bf       	out	0x3e, r29	; 62
    3438:	df 91       	pop	r29
    343a:	cf 91       	pop	r28
    343c:	1f 91       	pop	r17
    343e:	0f 91       	pop	r16
    3440:	ff 90       	pop	r15
    3442:	ef 90       	pop	r14
    3444:	df 90       	pop	r13
    3446:	cf 90       	pop	r12
    3448:	bf 90       	pop	r11
    344a:	af 90       	pop	r10
    344c:	9f 90       	pop	r9
    344e:	8f 90       	pop	r8
    3450:	08 95       	ret

00003452 <__subsf3>:
    3452:	50 58       	subi	r21, 0x80	; 128

00003454 <__addsf3>:
    3454:	bb 27       	eor	r27, r27
    3456:	aa 27       	eor	r26, r26
    3458:	0e d0       	rcall	.+28     	; 0x3476 <__addsf3x>
    345a:	4d c1       	rjmp	.+666    	; 0x36f6 <__fp_round>
    345c:	3e d1       	rcall	.+636    	; 0x36da <__fp_pscA>
    345e:	30 f0       	brcs	.+12     	; 0x346c <__addsf3+0x18>
    3460:	43 d1       	rcall	.+646    	; 0x36e8 <__fp_pscB>
    3462:	20 f0       	brcs	.+8      	; 0x346c <__addsf3+0x18>
    3464:	31 f4       	brne	.+12     	; 0x3472 <__addsf3+0x1e>
    3466:	9f 3f       	cpi	r25, 0xFF	; 255
    3468:	11 f4       	brne	.+4      	; 0x346e <__addsf3+0x1a>
    346a:	1e f4       	brtc	.+6      	; 0x3472 <__addsf3+0x1e>
    346c:	33 c1       	rjmp	.+614    	; 0x36d4 <__fp_nan>
    346e:	0e f4       	brtc	.+2      	; 0x3472 <__addsf3+0x1e>
    3470:	e0 95       	com	r30
    3472:	e7 fb       	bst	r30, 7
    3474:	29 c1       	rjmp	.+594    	; 0x36c8 <__fp_inf>

00003476 <__addsf3x>:
    3476:	e9 2f       	mov	r30, r25
    3478:	4f d1       	rcall	.+670    	; 0x3718 <__fp_split3>
    347a:	80 f3       	brcs	.-32     	; 0x345c <__addsf3+0x8>
    347c:	ba 17       	cp	r27, r26
    347e:	62 07       	cpc	r22, r18
    3480:	73 07       	cpc	r23, r19
    3482:	84 07       	cpc	r24, r20
    3484:	95 07       	cpc	r25, r21
    3486:	18 f0       	brcs	.+6      	; 0x348e <__addsf3x+0x18>
    3488:	71 f4       	brne	.+28     	; 0x34a6 <__addsf3x+0x30>
    348a:	9e f5       	brtc	.+102    	; 0x34f2 <__addsf3x+0x7c>
    348c:	67 c1       	rjmp	.+718    	; 0x375c <__fp_zero>
    348e:	0e f4       	brtc	.+2      	; 0x3492 <__addsf3x+0x1c>
    3490:	e0 95       	com	r30
    3492:	0b 2e       	mov	r0, r27
    3494:	ba 2f       	mov	r27, r26
    3496:	a0 2d       	mov	r26, r0
    3498:	0b 01       	movw	r0, r22
    349a:	b9 01       	movw	r22, r18
    349c:	90 01       	movw	r18, r0
    349e:	0c 01       	movw	r0, r24
    34a0:	ca 01       	movw	r24, r20
    34a2:	a0 01       	movw	r20, r0
    34a4:	11 24       	eor	r1, r1
    34a6:	ff 27       	eor	r31, r31
    34a8:	59 1b       	sub	r21, r25
    34aa:	99 f0       	breq	.+38     	; 0x34d2 <__addsf3x+0x5c>
    34ac:	59 3f       	cpi	r21, 0xF9	; 249
    34ae:	50 f4       	brcc	.+20     	; 0x34c4 <__addsf3x+0x4e>
    34b0:	50 3e       	cpi	r21, 0xE0	; 224
    34b2:	68 f1       	brcs	.+90     	; 0x350e <__addsf3x+0x98>
    34b4:	1a 16       	cp	r1, r26
    34b6:	f0 40       	sbci	r31, 0x00	; 0
    34b8:	a2 2f       	mov	r26, r18
    34ba:	23 2f       	mov	r18, r19
    34bc:	34 2f       	mov	r19, r20
    34be:	44 27       	eor	r20, r20
    34c0:	58 5f       	subi	r21, 0xF8	; 248
    34c2:	f3 cf       	rjmp	.-26     	; 0x34aa <__addsf3x+0x34>
    34c4:	46 95       	lsr	r20
    34c6:	37 95       	ror	r19
    34c8:	27 95       	ror	r18
    34ca:	a7 95       	ror	r26
    34cc:	f0 40       	sbci	r31, 0x00	; 0
    34ce:	53 95       	inc	r21
    34d0:	c9 f7       	brne	.-14     	; 0x34c4 <__addsf3x+0x4e>
    34d2:	7e f4       	brtc	.+30     	; 0x34f2 <__addsf3x+0x7c>
    34d4:	1f 16       	cp	r1, r31
    34d6:	ba 0b       	sbc	r27, r26
    34d8:	62 0b       	sbc	r22, r18
    34da:	73 0b       	sbc	r23, r19
    34dc:	84 0b       	sbc	r24, r20
    34de:	ba f0       	brmi	.+46     	; 0x350e <__addsf3x+0x98>
    34e0:	91 50       	subi	r25, 0x01	; 1
    34e2:	a1 f0       	breq	.+40     	; 0x350c <__addsf3x+0x96>
    34e4:	ff 0f       	add	r31, r31
    34e6:	bb 1f       	adc	r27, r27
    34e8:	66 1f       	adc	r22, r22
    34ea:	77 1f       	adc	r23, r23
    34ec:	88 1f       	adc	r24, r24
    34ee:	c2 f7       	brpl	.-16     	; 0x34e0 <__addsf3x+0x6a>
    34f0:	0e c0       	rjmp	.+28     	; 0x350e <__addsf3x+0x98>
    34f2:	ba 0f       	add	r27, r26
    34f4:	62 1f       	adc	r22, r18
    34f6:	73 1f       	adc	r23, r19
    34f8:	84 1f       	adc	r24, r20
    34fa:	48 f4       	brcc	.+18     	; 0x350e <__addsf3x+0x98>
    34fc:	87 95       	ror	r24
    34fe:	77 95       	ror	r23
    3500:	67 95       	ror	r22
    3502:	b7 95       	ror	r27
    3504:	f7 95       	ror	r31
    3506:	9e 3f       	cpi	r25, 0xFE	; 254
    3508:	08 f0       	brcs	.+2      	; 0x350c <__addsf3x+0x96>
    350a:	b3 cf       	rjmp	.-154    	; 0x3472 <__addsf3+0x1e>
    350c:	93 95       	inc	r25
    350e:	88 0f       	add	r24, r24
    3510:	08 f0       	brcs	.+2      	; 0x3514 <__addsf3x+0x9e>
    3512:	99 27       	eor	r25, r25
    3514:	ee 0f       	add	r30, r30
    3516:	97 95       	ror	r25
    3518:	87 95       	ror	r24
    351a:	08 95       	ret

0000351c <__divsf3>:
    351c:	0c d0       	rcall	.+24     	; 0x3536 <__divsf3x>
    351e:	eb c0       	rjmp	.+470    	; 0x36f6 <__fp_round>
    3520:	e3 d0       	rcall	.+454    	; 0x36e8 <__fp_pscB>
    3522:	40 f0       	brcs	.+16     	; 0x3534 <__divsf3+0x18>
    3524:	da d0       	rcall	.+436    	; 0x36da <__fp_pscA>
    3526:	30 f0       	brcs	.+12     	; 0x3534 <__divsf3+0x18>
    3528:	21 f4       	brne	.+8      	; 0x3532 <__divsf3+0x16>
    352a:	5f 3f       	cpi	r21, 0xFF	; 255
    352c:	19 f0       	breq	.+6      	; 0x3534 <__divsf3+0x18>
    352e:	cc c0       	rjmp	.+408    	; 0x36c8 <__fp_inf>
    3530:	51 11       	cpse	r21, r1
    3532:	15 c1       	rjmp	.+554    	; 0x375e <__fp_szero>
    3534:	cf c0       	rjmp	.+414    	; 0x36d4 <__fp_nan>

00003536 <__divsf3x>:
    3536:	f0 d0       	rcall	.+480    	; 0x3718 <__fp_split3>
    3538:	98 f3       	brcs	.-26     	; 0x3520 <__divsf3+0x4>

0000353a <__divsf3_pse>:
    353a:	99 23       	and	r25, r25
    353c:	c9 f3       	breq	.-14     	; 0x3530 <__divsf3+0x14>
    353e:	55 23       	and	r21, r21
    3540:	b1 f3       	breq	.-20     	; 0x352e <__divsf3+0x12>
    3542:	95 1b       	sub	r25, r21
    3544:	55 0b       	sbc	r21, r21
    3546:	bb 27       	eor	r27, r27
    3548:	aa 27       	eor	r26, r26
    354a:	62 17       	cp	r22, r18
    354c:	73 07       	cpc	r23, r19
    354e:	84 07       	cpc	r24, r20
    3550:	38 f0       	brcs	.+14     	; 0x3560 <__divsf3_pse+0x26>
    3552:	9f 5f       	subi	r25, 0xFF	; 255
    3554:	5f 4f       	sbci	r21, 0xFF	; 255
    3556:	22 0f       	add	r18, r18
    3558:	33 1f       	adc	r19, r19
    355a:	44 1f       	adc	r20, r20
    355c:	aa 1f       	adc	r26, r26
    355e:	a9 f3       	breq	.-22     	; 0x354a <__divsf3_pse+0x10>
    3560:	33 d0       	rcall	.+102    	; 0x35c8 <__divsf3_pse+0x8e>
    3562:	0e 2e       	mov	r0, r30
    3564:	3a f0       	brmi	.+14     	; 0x3574 <__divsf3_pse+0x3a>
    3566:	e0 e8       	ldi	r30, 0x80	; 128
    3568:	30 d0       	rcall	.+96     	; 0x35ca <__divsf3_pse+0x90>
    356a:	91 50       	subi	r25, 0x01	; 1
    356c:	50 40       	sbci	r21, 0x00	; 0
    356e:	e6 95       	lsr	r30
    3570:	00 1c       	adc	r0, r0
    3572:	ca f7       	brpl	.-14     	; 0x3566 <__divsf3_pse+0x2c>
    3574:	29 d0       	rcall	.+82     	; 0x35c8 <__divsf3_pse+0x8e>
    3576:	fe 2f       	mov	r31, r30
    3578:	27 d0       	rcall	.+78     	; 0x35c8 <__divsf3_pse+0x8e>
    357a:	66 0f       	add	r22, r22
    357c:	77 1f       	adc	r23, r23
    357e:	88 1f       	adc	r24, r24
    3580:	bb 1f       	adc	r27, r27
    3582:	26 17       	cp	r18, r22
    3584:	37 07       	cpc	r19, r23
    3586:	48 07       	cpc	r20, r24
    3588:	ab 07       	cpc	r26, r27
    358a:	b0 e8       	ldi	r27, 0x80	; 128
    358c:	09 f0       	breq	.+2      	; 0x3590 <__divsf3_pse+0x56>
    358e:	bb 0b       	sbc	r27, r27
    3590:	80 2d       	mov	r24, r0
    3592:	bf 01       	movw	r22, r30
    3594:	ff 27       	eor	r31, r31
    3596:	93 58       	subi	r25, 0x83	; 131
    3598:	5f 4f       	sbci	r21, 0xFF	; 255
    359a:	2a f0       	brmi	.+10     	; 0x35a6 <__divsf3_pse+0x6c>
    359c:	9e 3f       	cpi	r25, 0xFE	; 254
    359e:	51 05       	cpc	r21, r1
    35a0:	68 f0       	brcs	.+26     	; 0x35bc <__divsf3_pse+0x82>
    35a2:	92 c0       	rjmp	.+292    	; 0x36c8 <__fp_inf>
    35a4:	dc c0       	rjmp	.+440    	; 0x375e <__fp_szero>
    35a6:	5f 3f       	cpi	r21, 0xFF	; 255
    35a8:	ec f3       	brlt	.-6      	; 0x35a4 <__divsf3_pse+0x6a>
    35aa:	98 3e       	cpi	r25, 0xE8	; 232
    35ac:	dc f3       	brlt	.-10     	; 0x35a4 <__divsf3_pse+0x6a>
    35ae:	86 95       	lsr	r24
    35b0:	77 95       	ror	r23
    35b2:	67 95       	ror	r22
    35b4:	b7 95       	ror	r27
    35b6:	f7 95       	ror	r31
    35b8:	9f 5f       	subi	r25, 0xFF	; 255
    35ba:	c9 f7       	brne	.-14     	; 0x35ae <__divsf3_pse+0x74>
    35bc:	88 0f       	add	r24, r24
    35be:	91 1d       	adc	r25, r1
    35c0:	96 95       	lsr	r25
    35c2:	87 95       	ror	r24
    35c4:	97 f9       	bld	r25, 7
    35c6:	08 95       	ret
    35c8:	e1 e0       	ldi	r30, 0x01	; 1
    35ca:	66 0f       	add	r22, r22
    35cc:	77 1f       	adc	r23, r23
    35ce:	88 1f       	adc	r24, r24
    35d0:	bb 1f       	adc	r27, r27
    35d2:	62 17       	cp	r22, r18
    35d4:	73 07       	cpc	r23, r19
    35d6:	84 07       	cpc	r24, r20
    35d8:	ba 07       	cpc	r27, r26
    35da:	20 f0       	brcs	.+8      	; 0x35e4 <__divsf3_pse+0xaa>
    35dc:	62 1b       	sub	r22, r18
    35de:	73 0b       	sbc	r23, r19
    35e0:	84 0b       	sbc	r24, r20
    35e2:	ba 0b       	sbc	r27, r26
    35e4:	ee 1f       	adc	r30, r30
    35e6:	88 f7       	brcc	.-30     	; 0x35ca <__divsf3_pse+0x90>
    35e8:	e0 95       	com	r30
    35ea:	08 95       	ret

000035ec <__fixsfsi>:
    35ec:	04 d0       	rcall	.+8      	; 0x35f6 <__fixunssfsi>
    35ee:	68 94       	set
    35f0:	b1 11       	cpse	r27, r1
    35f2:	b5 c0       	rjmp	.+362    	; 0x375e <__fp_szero>
    35f4:	08 95       	ret

000035f6 <__fixunssfsi>:
    35f6:	98 d0       	rcall	.+304    	; 0x3728 <__fp_splitA>
    35f8:	88 f0       	brcs	.+34     	; 0x361c <__fixunssfsi+0x26>
    35fa:	9f 57       	subi	r25, 0x7F	; 127
    35fc:	90 f0       	brcs	.+36     	; 0x3622 <__fixunssfsi+0x2c>
    35fe:	b9 2f       	mov	r27, r25
    3600:	99 27       	eor	r25, r25
    3602:	b7 51       	subi	r27, 0x17	; 23
    3604:	a0 f0       	brcs	.+40     	; 0x362e <__fixunssfsi+0x38>
    3606:	d1 f0       	breq	.+52     	; 0x363c <__fixunssfsi+0x46>
    3608:	66 0f       	add	r22, r22
    360a:	77 1f       	adc	r23, r23
    360c:	88 1f       	adc	r24, r24
    360e:	99 1f       	adc	r25, r25
    3610:	1a f0       	brmi	.+6      	; 0x3618 <__fixunssfsi+0x22>
    3612:	ba 95       	dec	r27
    3614:	c9 f7       	brne	.-14     	; 0x3608 <__fixunssfsi+0x12>
    3616:	12 c0       	rjmp	.+36     	; 0x363c <__fixunssfsi+0x46>
    3618:	b1 30       	cpi	r27, 0x01	; 1
    361a:	81 f0       	breq	.+32     	; 0x363c <__fixunssfsi+0x46>
    361c:	9f d0       	rcall	.+318    	; 0x375c <__fp_zero>
    361e:	b1 e0       	ldi	r27, 0x01	; 1
    3620:	08 95       	ret
    3622:	9c c0       	rjmp	.+312    	; 0x375c <__fp_zero>
    3624:	67 2f       	mov	r22, r23
    3626:	78 2f       	mov	r23, r24
    3628:	88 27       	eor	r24, r24
    362a:	b8 5f       	subi	r27, 0xF8	; 248
    362c:	39 f0       	breq	.+14     	; 0x363c <__fixunssfsi+0x46>
    362e:	b9 3f       	cpi	r27, 0xF9	; 249
    3630:	cc f3       	brlt	.-14     	; 0x3624 <__fixunssfsi+0x2e>
    3632:	86 95       	lsr	r24
    3634:	77 95       	ror	r23
    3636:	67 95       	ror	r22
    3638:	b3 95       	inc	r27
    363a:	d9 f7       	brne	.-10     	; 0x3632 <__fixunssfsi+0x3c>
    363c:	3e f4       	brtc	.+14     	; 0x364c <__fixunssfsi+0x56>
    363e:	90 95       	com	r25
    3640:	80 95       	com	r24
    3642:	70 95       	com	r23
    3644:	61 95       	neg	r22
    3646:	7f 4f       	sbci	r23, 0xFF	; 255
    3648:	8f 4f       	sbci	r24, 0xFF	; 255
    364a:	9f 4f       	sbci	r25, 0xFF	; 255
    364c:	08 95       	ret

0000364e <__floatunsisf>:
    364e:	e8 94       	clt
    3650:	09 c0       	rjmp	.+18     	; 0x3664 <__floatsisf+0x12>

00003652 <__floatsisf>:
    3652:	97 fb       	bst	r25, 7
    3654:	3e f4       	brtc	.+14     	; 0x3664 <__floatsisf+0x12>
    3656:	90 95       	com	r25
    3658:	80 95       	com	r24
    365a:	70 95       	com	r23
    365c:	61 95       	neg	r22
    365e:	7f 4f       	sbci	r23, 0xFF	; 255
    3660:	8f 4f       	sbci	r24, 0xFF	; 255
    3662:	9f 4f       	sbci	r25, 0xFF	; 255
    3664:	99 23       	and	r25, r25
    3666:	a9 f0       	breq	.+42     	; 0x3692 <__floatsisf+0x40>
    3668:	f9 2f       	mov	r31, r25
    366a:	96 e9       	ldi	r25, 0x96	; 150
    366c:	bb 27       	eor	r27, r27
    366e:	93 95       	inc	r25
    3670:	f6 95       	lsr	r31
    3672:	87 95       	ror	r24
    3674:	77 95       	ror	r23
    3676:	67 95       	ror	r22
    3678:	b7 95       	ror	r27
    367a:	f1 11       	cpse	r31, r1
    367c:	f8 cf       	rjmp	.-16     	; 0x366e <__floatsisf+0x1c>
    367e:	fa f4       	brpl	.+62     	; 0x36be <__floatsisf+0x6c>
    3680:	bb 0f       	add	r27, r27
    3682:	11 f4       	brne	.+4      	; 0x3688 <__floatsisf+0x36>
    3684:	60 ff       	sbrs	r22, 0
    3686:	1b c0       	rjmp	.+54     	; 0x36be <__floatsisf+0x6c>
    3688:	6f 5f       	subi	r22, 0xFF	; 255
    368a:	7f 4f       	sbci	r23, 0xFF	; 255
    368c:	8f 4f       	sbci	r24, 0xFF	; 255
    368e:	9f 4f       	sbci	r25, 0xFF	; 255
    3690:	16 c0       	rjmp	.+44     	; 0x36be <__floatsisf+0x6c>
    3692:	88 23       	and	r24, r24
    3694:	11 f0       	breq	.+4      	; 0x369a <__floatsisf+0x48>
    3696:	96 e9       	ldi	r25, 0x96	; 150
    3698:	11 c0       	rjmp	.+34     	; 0x36bc <__floatsisf+0x6a>
    369a:	77 23       	and	r23, r23
    369c:	21 f0       	breq	.+8      	; 0x36a6 <__floatsisf+0x54>
    369e:	9e e8       	ldi	r25, 0x8E	; 142
    36a0:	87 2f       	mov	r24, r23
    36a2:	76 2f       	mov	r23, r22
    36a4:	05 c0       	rjmp	.+10     	; 0x36b0 <__floatsisf+0x5e>
    36a6:	66 23       	and	r22, r22
    36a8:	71 f0       	breq	.+28     	; 0x36c6 <__floatsisf+0x74>
    36aa:	96 e8       	ldi	r25, 0x86	; 134
    36ac:	86 2f       	mov	r24, r22
    36ae:	70 e0       	ldi	r23, 0x00	; 0
    36b0:	60 e0       	ldi	r22, 0x00	; 0
    36b2:	2a f0       	brmi	.+10     	; 0x36be <__floatsisf+0x6c>
    36b4:	9a 95       	dec	r25
    36b6:	66 0f       	add	r22, r22
    36b8:	77 1f       	adc	r23, r23
    36ba:	88 1f       	adc	r24, r24
    36bc:	da f7       	brpl	.-10     	; 0x36b4 <__floatsisf+0x62>
    36be:	88 0f       	add	r24, r24
    36c0:	96 95       	lsr	r25
    36c2:	87 95       	ror	r24
    36c4:	97 f9       	bld	r25, 7
    36c6:	08 95       	ret

000036c8 <__fp_inf>:
    36c8:	97 f9       	bld	r25, 7
    36ca:	9f 67       	ori	r25, 0x7F	; 127
    36cc:	80 e8       	ldi	r24, 0x80	; 128
    36ce:	70 e0       	ldi	r23, 0x00	; 0
    36d0:	60 e0       	ldi	r22, 0x00	; 0
    36d2:	08 95       	ret

000036d4 <__fp_nan>:
    36d4:	9f ef       	ldi	r25, 0xFF	; 255
    36d6:	80 ec       	ldi	r24, 0xC0	; 192
    36d8:	08 95       	ret

000036da <__fp_pscA>:
    36da:	00 24       	eor	r0, r0
    36dc:	0a 94       	dec	r0
    36de:	16 16       	cp	r1, r22
    36e0:	17 06       	cpc	r1, r23
    36e2:	18 06       	cpc	r1, r24
    36e4:	09 06       	cpc	r0, r25
    36e6:	08 95       	ret

000036e8 <__fp_pscB>:
    36e8:	00 24       	eor	r0, r0
    36ea:	0a 94       	dec	r0
    36ec:	12 16       	cp	r1, r18
    36ee:	13 06       	cpc	r1, r19
    36f0:	14 06       	cpc	r1, r20
    36f2:	05 06       	cpc	r0, r21
    36f4:	08 95       	ret

000036f6 <__fp_round>:
    36f6:	09 2e       	mov	r0, r25
    36f8:	03 94       	inc	r0
    36fa:	00 0c       	add	r0, r0
    36fc:	11 f4       	brne	.+4      	; 0x3702 <__fp_round+0xc>
    36fe:	88 23       	and	r24, r24
    3700:	52 f0       	brmi	.+20     	; 0x3716 <__fp_round+0x20>
    3702:	bb 0f       	add	r27, r27
    3704:	40 f4       	brcc	.+16     	; 0x3716 <__fp_round+0x20>
    3706:	bf 2b       	or	r27, r31
    3708:	11 f4       	brne	.+4      	; 0x370e <__fp_round+0x18>
    370a:	60 ff       	sbrs	r22, 0
    370c:	04 c0       	rjmp	.+8      	; 0x3716 <__fp_round+0x20>
    370e:	6f 5f       	subi	r22, 0xFF	; 255
    3710:	7f 4f       	sbci	r23, 0xFF	; 255
    3712:	8f 4f       	sbci	r24, 0xFF	; 255
    3714:	9f 4f       	sbci	r25, 0xFF	; 255
    3716:	08 95       	ret

00003718 <__fp_split3>:
    3718:	57 fd       	sbrc	r21, 7
    371a:	90 58       	subi	r25, 0x80	; 128
    371c:	44 0f       	add	r20, r20
    371e:	55 1f       	adc	r21, r21
    3720:	59 f0       	breq	.+22     	; 0x3738 <__fp_splitA+0x10>
    3722:	5f 3f       	cpi	r21, 0xFF	; 255
    3724:	71 f0       	breq	.+28     	; 0x3742 <__fp_splitA+0x1a>
    3726:	47 95       	ror	r20

00003728 <__fp_splitA>:
    3728:	88 0f       	add	r24, r24
    372a:	97 fb       	bst	r25, 7
    372c:	99 1f       	adc	r25, r25
    372e:	61 f0       	breq	.+24     	; 0x3748 <__fp_splitA+0x20>
    3730:	9f 3f       	cpi	r25, 0xFF	; 255
    3732:	79 f0       	breq	.+30     	; 0x3752 <__fp_splitA+0x2a>
    3734:	87 95       	ror	r24
    3736:	08 95       	ret
    3738:	12 16       	cp	r1, r18
    373a:	13 06       	cpc	r1, r19
    373c:	14 06       	cpc	r1, r20
    373e:	55 1f       	adc	r21, r21
    3740:	f2 cf       	rjmp	.-28     	; 0x3726 <__fp_split3+0xe>
    3742:	46 95       	lsr	r20
    3744:	f1 df       	rcall	.-30     	; 0x3728 <__fp_splitA>
    3746:	08 c0       	rjmp	.+16     	; 0x3758 <__fp_splitA+0x30>
    3748:	16 16       	cp	r1, r22
    374a:	17 06       	cpc	r1, r23
    374c:	18 06       	cpc	r1, r24
    374e:	99 1f       	adc	r25, r25
    3750:	f1 cf       	rjmp	.-30     	; 0x3734 <__fp_splitA+0xc>
    3752:	86 95       	lsr	r24
    3754:	71 05       	cpc	r23, r1
    3756:	61 05       	cpc	r22, r1
    3758:	08 94       	sec
    375a:	08 95       	ret

0000375c <__fp_zero>:
    375c:	e8 94       	clt

0000375e <__fp_szero>:
    375e:	bb 27       	eor	r27, r27
    3760:	66 27       	eor	r22, r22
    3762:	77 27       	eor	r23, r23
    3764:	cb 01       	movw	r24, r22
    3766:	97 f9       	bld	r25, 7
    3768:	08 95       	ret

0000376a <__mulsf3>:
    376a:	0b d0       	rcall	.+22     	; 0x3782 <__mulsf3x>
    376c:	c4 cf       	rjmp	.-120    	; 0x36f6 <__fp_round>
    376e:	b5 df       	rcall	.-150    	; 0x36da <__fp_pscA>
    3770:	28 f0       	brcs	.+10     	; 0x377c <__mulsf3+0x12>
    3772:	ba df       	rcall	.-140    	; 0x36e8 <__fp_pscB>
    3774:	18 f0       	brcs	.+6      	; 0x377c <__mulsf3+0x12>
    3776:	95 23       	and	r25, r21
    3778:	09 f0       	breq	.+2      	; 0x377c <__mulsf3+0x12>
    377a:	a6 cf       	rjmp	.-180    	; 0x36c8 <__fp_inf>
    377c:	ab cf       	rjmp	.-170    	; 0x36d4 <__fp_nan>
    377e:	11 24       	eor	r1, r1
    3780:	ee cf       	rjmp	.-36     	; 0x375e <__fp_szero>

00003782 <__mulsf3x>:
    3782:	ca df       	rcall	.-108    	; 0x3718 <__fp_split3>
    3784:	a0 f3       	brcs	.-24     	; 0x376e <__mulsf3+0x4>

00003786 <__mulsf3_pse>:
    3786:	95 9f       	mul	r25, r21
    3788:	d1 f3       	breq	.-12     	; 0x377e <__mulsf3+0x14>
    378a:	95 0f       	add	r25, r21
    378c:	50 e0       	ldi	r21, 0x00	; 0
    378e:	55 1f       	adc	r21, r21
    3790:	62 9f       	mul	r22, r18
    3792:	f0 01       	movw	r30, r0
    3794:	72 9f       	mul	r23, r18
    3796:	bb 27       	eor	r27, r27
    3798:	f0 0d       	add	r31, r0
    379a:	b1 1d       	adc	r27, r1
    379c:	63 9f       	mul	r22, r19
    379e:	aa 27       	eor	r26, r26
    37a0:	f0 0d       	add	r31, r0
    37a2:	b1 1d       	adc	r27, r1
    37a4:	aa 1f       	adc	r26, r26
    37a6:	64 9f       	mul	r22, r20
    37a8:	66 27       	eor	r22, r22
    37aa:	b0 0d       	add	r27, r0
    37ac:	a1 1d       	adc	r26, r1
    37ae:	66 1f       	adc	r22, r22
    37b0:	82 9f       	mul	r24, r18
    37b2:	22 27       	eor	r18, r18
    37b4:	b0 0d       	add	r27, r0
    37b6:	a1 1d       	adc	r26, r1
    37b8:	62 1f       	adc	r22, r18
    37ba:	73 9f       	mul	r23, r19
    37bc:	b0 0d       	add	r27, r0
    37be:	a1 1d       	adc	r26, r1
    37c0:	62 1f       	adc	r22, r18
    37c2:	83 9f       	mul	r24, r19
    37c4:	a0 0d       	add	r26, r0
    37c6:	61 1d       	adc	r22, r1
    37c8:	22 1f       	adc	r18, r18
    37ca:	74 9f       	mul	r23, r20
    37cc:	33 27       	eor	r19, r19
    37ce:	a0 0d       	add	r26, r0
    37d0:	61 1d       	adc	r22, r1
    37d2:	23 1f       	adc	r18, r19
    37d4:	84 9f       	mul	r24, r20
    37d6:	60 0d       	add	r22, r0
    37d8:	21 1d       	adc	r18, r1
    37da:	82 2f       	mov	r24, r18
    37dc:	76 2f       	mov	r23, r22
    37de:	6a 2f       	mov	r22, r26
    37e0:	11 24       	eor	r1, r1
    37e2:	9f 57       	subi	r25, 0x7F	; 127
    37e4:	50 40       	sbci	r21, 0x00	; 0
    37e6:	8a f0       	brmi	.+34     	; 0x380a <__mulsf3_pse+0x84>
    37e8:	e1 f0       	breq	.+56     	; 0x3822 <__mulsf3_pse+0x9c>
    37ea:	88 23       	and	r24, r24
    37ec:	4a f0       	brmi	.+18     	; 0x3800 <__mulsf3_pse+0x7a>
    37ee:	ee 0f       	add	r30, r30
    37f0:	ff 1f       	adc	r31, r31
    37f2:	bb 1f       	adc	r27, r27
    37f4:	66 1f       	adc	r22, r22
    37f6:	77 1f       	adc	r23, r23
    37f8:	88 1f       	adc	r24, r24
    37fa:	91 50       	subi	r25, 0x01	; 1
    37fc:	50 40       	sbci	r21, 0x00	; 0
    37fe:	a9 f7       	brne	.-22     	; 0x37ea <__mulsf3_pse+0x64>
    3800:	9e 3f       	cpi	r25, 0xFE	; 254
    3802:	51 05       	cpc	r21, r1
    3804:	70 f0       	brcs	.+28     	; 0x3822 <__mulsf3_pse+0x9c>
    3806:	60 cf       	rjmp	.-320    	; 0x36c8 <__fp_inf>
    3808:	aa cf       	rjmp	.-172    	; 0x375e <__fp_szero>
    380a:	5f 3f       	cpi	r21, 0xFF	; 255
    380c:	ec f3       	brlt	.-6      	; 0x3808 <__mulsf3_pse+0x82>
    380e:	98 3e       	cpi	r25, 0xE8	; 232
    3810:	dc f3       	brlt	.-10     	; 0x3808 <__mulsf3_pse+0x82>
    3812:	86 95       	lsr	r24
    3814:	77 95       	ror	r23
    3816:	67 95       	ror	r22
    3818:	b7 95       	ror	r27
    381a:	f7 95       	ror	r31
    381c:	e7 95       	ror	r30
    381e:	9f 5f       	subi	r25, 0xFF	; 255
    3820:	c1 f7       	brne	.-16     	; 0x3812 <__mulsf3_pse+0x8c>
    3822:	fe 2b       	or	r31, r30
    3824:	88 0f       	add	r24, r24
    3826:	91 1d       	adc	r25, r1
    3828:	96 95       	lsr	r25
    382a:	87 95       	ror	r24
    382c:	97 f9       	bld	r25, 7
    382e:	08 95       	ret

00003830 <__udivmodsi4>:
    3830:	a1 e2       	ldi	r26, 0x21	; 33
    3832:	1a 2e       	mov	r1, r26
    3834:	aa 1b       	sub	r26, r26
    3836:	bb 1b       	sub	r27, r27
    3838:	fd 01       	movw	r30, r26
    383a:	0d c0       	rjmp	.+26     	; 0x3856 <__udivmodsi4_ep>

0000383c <__udivmodsi4_loop>:
    383c:	aa 1f       	adc	r26, r26
    383e:	bb 1f       	adc	r27, r27
    3840:	ee 1f       	adc	r30, r30
    3842:	ff 1f       	adc	r31, r31
    3844:	a2 17       	cp	r26, r18
    3846:	b3 07       	cpc	r27, r19
    3848:	e4 07       	cpc	r30, r20
    384a:	f5 07       	cpc	r31, r21
    384c:	20 f0       	brcs	.+8      	; 0x3856 <__udivmodsi4_ep>
    384e:	a2 1b       	sub	r26, r18
    3850:	b3 0b       	sbc	r27, r19
    3852:	e4 0b       	sbc	r30, r20
    3854:	f5 0b       	sbc	r31, r21

00003856 <__udivmodsi4_ep>:
    3856:	66 1f       	adc	r22, r22
    3858:	77 1f       	adc	r23, r23
    385a:	88 1f       	adc	r24, r24
    385c:	99 1f       	adc	r25, r25
    385e:	1a 94       	dec	r1
    3860:	69 f7       	brne	.-38     	; 0x383c <__udivmodsi4_loop>
    3862:	60 95       	com	r22
    3864:	70 95       	com	r23
    3866:	80 95       	com	r24
    3868:	90 95       	com	r25
    386a:	9b 01       	movw	r18, r22
    386c:	ac 01       	movw	r20, r24
    386e:	bd 01       	movw	r22, r26
    3870:	cf 01       	movw	r24, r30
    3872:	08 95       	ret

00003874 <__tablejump2__>:
    3874:	ee 0f       	add	r30, r30
    3876:	ff 1f       	adc	r31, r31
    3878:	88 1f       	adc	r24, r24
    387a:	8b bf       	out	0x3b, r24	; 59
    387c:	07 90       	elpm	r0, Z+
    387e:	f6 91       	elpm	r31, Z
    3880:	e0 2d       	mov	r30, r0
    3882:	19 94       	eijmp

00003884 <malloc>:
    3884:	0f 93       	push	r16
    3886:	1f 93       	push	r17
    3888:	cf 93       	push	r28
    388a:	df 93       	push	r29
    388c:	82 30       	cpi	r24, 0x02	; 2
    388e:	91 05       	cpc	r25, r1
    3890:	10 f4       	brcc	.+4      	; 0x3896 <malloc+0x12>
    3892:	82 e0       	ldi	r24, 0x02	; 2
    3894:	90 e0       	ldi	r25, 0x00	; 0
    3896:	e0 91 b8 23 	lds	r30, 0x23B8	; 0x8023b8 <__flp>
    389a:	f0 91 b9 23 	lds	r31, 0x23B9	; 0x8023b9 <__flp+0x1>
    389e:	20 e0       	ldi	r18, 0x00	; 0
    38a0:	30 e0       	ldi	r19, 0x00	; 0
    38a2:	a0 e0       	ldi	r26, 0x00	; 0
    38a4:	b0 e0       	ldi	r27, 0x00	; 0
    38a6:	30 97       	sbiw	r30, 0x00	; 0
    38a8:	19 f1       	breq	.+70     	; 0x38f0 <malloc+0x6c>
    38aa:	40 81       	ld	r20, Z
    38ac:	51 81       	ldd	r21, Z+1	; 0x01
    38ae:	02 81       	ldd	r16, Z+2	; 0x02
    38b0:	13 81       	ldd	r17, Z+3	; 0x03
    38b2:	48 17       	cp	r20, r24
    38b4:	59 07       	cpc	r21, r25
    38b6:	c8 f0       	brcs	.+50     	; 0x38ea <malloc+0x66>
    38b8:	84 17       	cp	r24, r20
    38ba:	95 07       	cpc	r25, r21
    38bc:	69 f4       	brne	.+26     	; 0x38d8 <malloc+0x54>
    38be:	10 97       	sbiw	r26, 0x00	; 0
    38c0:	31 f0       	breq	.+12     	; 0x38ce <malloc+0x4a>
    38c2:	12 96       	adiw	r26, 0x02	; 2
    38c4:	0c 93       	st	X, r16
    38c6:	12 97       	sbiw	r26, 0x02	; 2
    38c8:	13 96       	adiw	r26, 0x03	; 3
    38ca:	1c 93       	st	X, r17
    38cc:	27 c0       	rjmp	.+78     	; 0x391c <malloc+0x98>
    38ce:	00 93 b8 23 	sts	0x23B8, r16	; 0x8023b8 <__flp>
    38d2:	10 93 b9 23 	sts	0x23B9, r17	; 0x8023b9 <__flp+0x1>
    38d6:	22 c0       	rjmp	.+68     	; 0x391c <malloc+0x98>
    38d8:	21 15       	cp	r18, r1
    38da:	31 05       	cpc	r19, r1
    38dc:	19 f0       	breq	.+6      	; 0x38e4 <malloc+0x60>
    38de:	42 17       	cp	r20, r18
    38e0:	53 07       	cpc	r21, r19
    38e2:	18 f4       	brcc	.+6      	; 0x38ea <malloc+0x66>
    38e4:	9a 01       	movw	r18, r20
    38e6:	bd 01       	movw	r22, r26
    38e8:	ef 01       	movw	r28, r30
    38ea:	df 01       	movw	r26, r30
    38ec:	f8 01       	movw	r30, r16
    38ee:	db cf       	rjmp	.-74     	; 0x38a6 <malloc+0x22>
    38f0:	21 15       	cp	r18, r1
    38f2:	31 05       	cpc	r19, r1
    38f4:	f9 f0       	breq	.+62     	; 0x3934 <malloc+0xb0>
    38f6:	28 1b       	sub	r18, r24
    38f8:	39 0b       	sbc	r19, r25
    38fa:	24 30       	cpi	r18, 0x04	; 4
    38fc:	31 05       	cpc	r19, r1
    38fe:	80 f4       	brcc	.+32     	; 0x3920 <malloc+0x9c>
    3900:	8a 81       	ldd	r24, Y+2	; 0x02
    3902:	9b 81       	ldd	r25, Y+3	; 0x03
    3904:	61 15       	cp	r22, r1
    3906:	71 05       	cpc	r23, r1
    3908:	21 f0       	breq	.+8      	; 0x3912 <malloc+0x8e>
    390a:	fb 01       	movw	r30, r22
    390c:	82 83       	std	Z+2, r24	; 0x02
    390e:	93 83       	std	Z+3, r25	; 0x03
    3910:	04 c0       	rjmp	.+8      	; 0x391a <malloc+0x96>
    3912:	80 93 b8 23 	sts	0x23B8, r24	; 0x8023b8 <__flp>
    3916:	90 93 b9 23 	sts	0x23B9, r25	; 0x8023b9 <__flp+0x1>
    391a:	fe 01       	movw	r30, r28
    391c:	32 96       	adiw	r30, 0x02	; 2
    391e:	44 c0       	rjmp	.+136    	; 0x39a8 <malloc+0x124>
    3920:	fe 01       	movw	r30, r28
    3922:	e2 0f       	add	r30, r18
    3924:	f3 1f       	adc	r31, r19
    3926:	81 93       	st	Z+, r24
    3928:	91 93       	st	Z+, r25
    392a:	22 50       	subi	r18, 0x02	; 2
    392c:	31 09       	sbc	r19, r1
    392e:	28 83       	st	Y, r18
    3930:	39 83       	std	Y+1, r19	; 0x01
    3932:	3a c0       	rjmp	.+116    	; 0x39a8 <malloc+0x124>
    3934:	20 91 b6 23 	lds	r18, 0x23B6	; 0x8023b6 <__brkval>
    3938:	30 91 b7 23 	lds	r19, 0x23B7	; 0x8023b7 <__brkval+0x1>
    393c:	23 2b       	or	r18, r19
    393e:	41 f4       	brne	.+16     	; 0x3950 <malloc+0xcc>
    3940:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3944:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3948:	20 93 b6 23 	sts	0x23B6, r18	; 0x8023b6 <__brkval>
    394c:	30 93 b7 23 	sts	0x23B7, r19	; 0x8023b7 <__brkval+0x1>
    3950:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    3954:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    3958:	21 15       	cp	r18, r1
    395a:	31 05       	cpc	r19, r1
    395c:	41 f4       	brne	.+16     	; 0x396e <malloc+0xea>
    395e:	2d b7       	in	r18, 0x3d	; 61
    3960:	3e b7       	in	r19, 0x3e	; 62
    3962:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3966:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    396a:	24 1b       	sub	r18, r20
    396c:	35 0b       	sbc	r19, r21
    396e:	e0 91 b6 23 	lds	r30, 0x23B6	; 0x8023b6 <__brkval>
    3972:	f0 91 b7 23 	lds	r31, 0x23B7	; 0x8023b7 <__brkval+0x1>
    3976:	e2 17       	cp	r30, r18
    3978:	f3 07       	cpc	r31, r19
    397a:	a0 f4       	brcc	.+40     	; 0x39a4 <malloc+0x120>
    397c:	2e 1b       	sub	r18, r30
    397e:	3f 0b       	sbc	r19, r31
    3980:	28 17       	cp	r18, r24
    3982:	39 07       	cpc	r19, r25
    3984:	78 f0       	brcs	.+30     	; 0x39a4 <malloc+0x120>
    3986:	ac 01       	movw	r20, r24
    3988:	4e 5f       	subi	r20, 0xFE	; 254
    398a:	5f 4f       	sbci	r21, 0xFF	; 255
    398c:	24 17       	cp	r18, r20
    398e:	35 07       	cpc	r19, r21
    3990:	48 f0       	brcs	.+18     	; 0x39a4 <malloc+0x120>
    3992:	4e 0f       	add	r20, r30
    3994:	5f 1f       	adc	r21, r31
    3996:	40 93 b6 23 	sts	0x23B6, r20	; 0x8023b6 <__brkval>
    399a:	50 93 b7 23 	sts	0x23B7, r21	; 0x8023b7 <__brkval+0x1>
    399e:	81 93       	st	Z+, r24
    39a0:	91 93       	st	Z+, r25
    39a2:	02 c0       	rjmp	.+4      	; 0x39a8 <malloc+0x124>
    39a4:	e0 e0       	ldi	r30, 0x00	; 0
    39a6:	f0 e0       	ldi	r31, 0x00	; 0
    39a8:	cf 01       	movw	r24, r30
    39aa:	df 91       	pop	r29
    39ac:	cf 91       	pop	r28
    39ae:	1f 91       	pop	r17
    39b0:	0f 91       	pop	r16
    39b2:	08 95       	ret

000039b4 <free>:
    39b4:	cf 93       	push	r28
    39b6:	df 93       	push	r29
    39b8:	00 97       	sbiw	r24, 0x00	; 0
    39ba:	09 f4       	brne	.+2      	; 0x39be <free+0xa>
    39bc:	81 c0       	rjmp	.+258    	; 0x3ac0 <free+0x10c>
    39be:	fc 01       	movw	r30, r24
    39c0:	32 97       	sbiw	r30, 0x02	; 2
    39c2:	12 82       	std	Z+2, r1	; 0x02
    39c4:	13 82       	std	Z+3, r1	; 0x03
    39c6:	a0 91 b8 23 	lds	r26, 0x23B8	; 0x8023b8 <__flp>
    39ca:	b0 91 b9 23 	lds	r27, 0x23B9	; 0x8023b9 <__flp+0x1>
    39ce:	10 97       	sbiw	r26, 0x00	; 0
    39d0:	81 f4       	brne	.+32     	; 0x39f2 <free+0x3e>
    39d2:	20 81       	ld	r18, Z
    39d4:	31 81       	ldd	r19, Z+1	; 0x01
    39d6:	82 0f       	add	r24, r18
    39d8:	93 1f       	adc	r25, r19
    39da:	20 91 b6 23 	lds	r18, 0x23B6	; 0x8023b6 <__brkval>
    39de:	30 91 b7 23 	lds	r19, 0x23B7	; 0x8023b7 <__brkval+0x1>
    39e2:	28 17       	cp	r18, r24
    39e4:	39 07       	cpc	r19, r25
    39e6:	51 f5       	brne	.+84     	; 0x3a3c <free+0x88>
    39e8:	e0 93 b6 23 	sts	0x23B6, r30	; 0x8023b6 <__brkval>
    39ec:	f0 93 b7 23 	sts	0x23B7, r31	; 0x8023b7 <__brkval+0x1>
    39f0:	67 c0       	rjmp	.+206    	; 0x3ac0 <free+0x10c>
    39f2:	ed 01       	movw	r28, r26
    39f4:	20 e0       	ldi	r18, 0x00	; 0
    39f6:	30 e0       	ldi	r19, 0x00	; 0
    39f8:	ce 17       	cp	r28, r30
    39fa:	df 07       	cpc	r29, r31
    39fc:	40 f4       	brcc	.+16     	; 0x3a0e <free+0x5a>
    39fe:	4a 81       	ldd	r20, Y+2	; 0x02
    3a00:	5b 81       	ldd	r21, Y+3	; 0x03
    3a02:	9e 01       	movw	r18, r28
    3a04:	41 15       	cp	r20, r1
    3a06:	51 05       	cpc	r21, r1
    3a08:	f1 f0       	breq	.+60     	; 0x3a46 <free+0x92>
    3a0a:	ea 01       	movw	r28, r20
    3a0c:	f5 cf       	rjmp	.-22     	; 0x39f8 <free+0x44>
    3a0e:	c2 83       	std	Z+2, r28	; 0x02
    3a10:	d3 83       	std	Z+3, r29	; 0x03
    3a12:	40 81       	ld	r20, Z
    3a14:	51 81       	ldd	r21, Z+1	; 0x01
    3a16:	84 0f       	add	r24, r20
    3a18:	95 1f       	adc	r25, r21
    3a1a:	c8 17       	cp	r28, r24
    3a1c:	d9 07       	cpc	r29, r25
    3a1e:	59 f4       	brne	.+22     	; 0x3a36 <free+0x82>
    3a20:	88 81       	ld	r24, Y
    3a22:	99 81       	ldd	r25, Y+1	; 0x01
    3a24:	84 0f       	add	r24, r20
    3a26:	95 1f       	adc	r25, r21
    3a28:	02 96       	adiw	r24, 0x02	; 2
    3a2a:	80 83       	st	Z, r24
    3a2c:	91 83       	std	Z+1, r25	; 0x01
    3a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a30:	9b 81       	ldd	r25, Y+3	; 0x03
    3a32:	82 83       	std	Z+2, r24	; 0x02
    3a34:	93 83       	std	Z+3, r25	; 0x03
    3a36:	21 15       	cp	r18, r1
    3a38:	31 05       	cpc	r19, r1
    3a3a:	29 f4       	brne	.+10     	; 0x3a46 <free+0x92>
    3a3c:	e0 93 b8 23 	sts	0x23B8, r30	; 0x8023b8 <__flp>
    3a40:	f0 93 b9 23 	sts	0x23B9, r31	; 0x8023b9 <__flp+0x1>
    3a44:	3d c0       	rjmp	.+122    	; 0x3ac0 <free+0x10c>
    3a46:	e9 01       	movw	r28, r18
    3a48:	ea 83       	std	Y+2, r30	; 0x02
    3a4a:	fb 83       	std	Y+3, r31	; 0x03
    3a4c:	49 91       	ld	r20, Y+
    3a4e:	59 91       	ld	r21, Y+
    3a50:	c4 0f       	add	r28, r20
    3a52:	d5 1f       	adc	r29, r21
    3a54:	ec 17       	cp	r30, r28
    3a56:	fd 07       	cpc	r31, r29
    3a58:	61 f4       	brne	.+24     	; 0x3a72 <free+0xbe>
    3a5a:	80 81       	ld	r24, Z
    3a5c:	91 81       	ldd	r25, Z+1	; 0x01
    3a5e:	84 0f       	add	r24, r20
    3a60:	95 1f       	adc	r25, r21
    3a62:	02 96       	adiw	r24, 0x02	; 2
    3a64:	e9 01       	movw	r28, r18
    3a66:	88 83       	st	Y, r24
    3a68:	99 83       	std	Y+1, r25	; 0x01
    3a6a:	82 81       	ldd	r24, Z+2	; 0x02
    3a6c:	93 81       	ldd	r25, Z+3	; 0x03
    3a6e:	8a 83       	std	Y+2, r24	; 0x02
    3a70:	9b 83       	std	Y+3, r25	; 0x03
    3a72:	e0 e0       	ldi	r30, 0x00	; 0
    3a74:	f0 e0       	ldi	r31, 0x00	; 0
    3a76:	12 96       	adiw	r26, 0x02	; 2
    3a78:	8d 91       	ld	r24, X+
    3a7a:	9c 91       	ld	r25, X
    3a7c:	13 97       	sbiw	r26, 0x03	; 3
    3a7e:	00 97       	sbiw	r24, 0x00	; 0
    3a80:	19 f0       	breq	.+6      	; 0x3a88 <free+0xd4>
    3a82:	fd 01       	movw	r30, r26
    3a84:	dc 01       	movw	r26, r24
    3a86:	f7 cf       	rjmp	.-18     	; 0x3a76 <free+0xc2>
    3a88:	8d 91       	ld	r24, X+
    3a8a:	9c 91       	ld	r25, X
    3a8c:	11 97       	sbiw	r26, 0x01	; 1
    3a8e:	9d 01       	movw	r18, r26
    3a90:	2e 5f       	subi	r18, 0xFE	; 254
    3a92:	3f 4f       	sbci	r19, 0xFF	; 255
    3a94:	82 0f       	add	r24, r18
    3a96:	93 1f       	adc	r25, r19
    3a98:	20 91 b6 23 	lds	r18, 0x23B6	; 0x8023b6 <__brkval>
    3a9c:	30 91 b7 23 	lds	r19, 0x23B7	; 0x8023b7 <__brkval+0x1>
    3aa0:	28 17       	cp	r18, r24
    3aa2:	39 07       	cpc	r19, r25
    3aa4:	69 f4       	brne	.+26     	; 0x3ac0 <free+0x10c>
    3aa6:	30 97       	sbiw	r30, 0x00	; 0
    3aa8:	29 f4       	brne	.+10     	; 0x3ab4 <free+0x100>
    3aaa:	10 92 b8 23 	sts	0x23B8, r1	; 0x8023b8 <__flp>
    3aae:	10 92 b9 23 	sts	0x23B9, r1	; 0x8023b9 <__flp+0x1>
    3ab2:	02 c0       	rjmp	.+4      	; 0x3ab8 <free+0x104>
    3ab4:	12 82       	std	Z+2, r1	; 0x02
    3ab6:	13 82       	std	Z+3, r1	; 0x03
    3ab8:	a0 93 b6 23 	sts	0x23B6, r26	; 0x8023b6 <__brkval>
    3abc:	b0 93 b7 23 	sts	0x23B7, r27	; 0x8023b7 <__brkval+0x1>
    3ac0:	df 91       	pop	r29
    3ac2:	cf 91       	pop	r28
    3ac4:	08 95       	ret

00003ac6 <memcpy>:
    3ac6:	fb 01       	movw	r30, r22
    3ac8:	dc 01       	movw	r26, r24
    3aca:	02 c0       	rjmp	.+4      	; 0x3ad0 <memcpy+0xa>
    3acc:	01 90       	ld	r0, Z+
    3ace:	0d 92       	st	X+, r0
    3ad0:	41 50       	subi	r20, 0x01	; 1
    3ad2:	50 40       	sbci	r21, 0x00	; 0
    3ad4:	d8 f7       	brcc	.-10     	; 0x3acc <memcpy+0x6>
    3ad6:	08 95       	ret

00003ad8 <snprintf>:
    3ad8:	0f 93       	push	r16
    3ada:	1f 93       	push	r17
    3adc:	cf 93       	push	r28
    3ade:	df 93       	push	r29
    3ae0:	cd b7       	in	r28, 0x3d	; 61
    3ae2:	de b7       	in	r29, 0x3e	; 62
    3ae4:	2e 97       	sbiw	r28, 0x0e	; 14
    3ae6:	cd bf       	out	0x3d, r28	; 61
    3ae8:	de bf       	out	0x3e, r29	; 62
    3aea:	0e 89       	ldd	r16, Y+22	; 0x16
    3aec:	1f 89       	ldd	r17, Y+23	; 0x17
    3aee:	88 8d       	ldd	r24, Y+24	; 0x18
    3af0:	99 8d       	ldd	r25, Y+25	; 0x19
    3af2:	26 e0       	ldi	r18, 0x06	; 6
    3af4:	2c 83       	std	Y+4, r18	; 0x04
    3af6:	09 83       	std	Y+1, r16	; 0x01
    3af8:	1a 83       	std	Y+2, r17	; 0x02
    3afa:	97 ff       	sbrs	r25, 7
    3afc:	02 c0       	rjmp	.+4      	; 0x3b02 <snprintf+0x2a>
    3afe:	80 e0       	ldi	r24, 0x00	; 0
    3b00:	90 e8       	ldi	r25, 0x80	; 128
    3b02:	01 97       	sbiw	r24, 0x01	; 1
    3b04:	8d 83       	std	Y+5, r24	; 0x05
    3b06:	9e 83       	std	Y+6, r25	; 0x06
    3b08:	ae 01       	movw	r20, r28
    3b0a:	44 5e       	subi	r20, 0xE4	; 228
    3b0c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b0e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3b10:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3b12:	ce 01       	movw	r24, r28
    3b14:	01 96       	adiw	r24, 0x01	; 1
    3b16:	16 d0       	rcall	.+44     	; 0x3b44 <vfprintf>
    3b18:	4d 81       	ldd	r20, Y+5	; 0x05
    3b1a:	5e 81       	ldd	r21, Y+6	; 0x06
    3b1c:	57 fd       	sbrc	r21, 7
    3b1e:	0a c0       	rjmp	.+20     	; 0x3b34 <snprintf+0x5c>
    3b20:	2f 81       	ldd	r18, Y+7	; 0x07
    3b22:	38 85       	ldd	r19, Y+8	; 0x08
    3b24:	42 17       	cp	r20, r18
    3b26:	53 07       	cpc	r21, r19
    3b28:	0c f4       	brge	.+2      	; 0x3b2c <snprintf+0x54>
    3b2a:	9a 01       	movw	r18, r20
    3b2c:	f8 01       	movw	r30, r16
    3b2e:	e2 0f       	add	r30, r18
    3b30:	f3 1f       	adc	r31, r19
    3b32:	10 82       	st	Z, r1
    3b34:	2e 96       	adiw	r28, 0x0e	; 14
    3b36:	cd bf       	out	0x3d, r28	; 61
    3b38:	de bf       	out	0x3e, r29	; 62
    3b3a:	df 91       	pop	r29
    3b3c:	cf 91       	pop	r28
    3b3e:	1f 91       	pop	r17
    3b40:	0f 91       	pop	r16
    3b42:	08 95       	ret

00003b44 <vfprintf>:
    3b44:	2f 92       	push	r2
    3b46:	3f 92       	push	r3
    3b48:	4f 92       	push	r4
    3b4a:	5f 92       	push	r5
    3b4c:	6f 92       	push	r6
    3b4e:	7f 92       	push	r7
    3b50:	8f 92       	push	r8
    3b52:	9f 92       	push	r9
    3b54:	af 92       	push	r10
    3b56:	bf 92       	push	r11
    3b58:	cf 92       	push	r12
    3b5a:	df 92       	push	r13
    3b5c:	ef 92       	push	r14
    3b5e:	ff 92       	push	r15
    3b60:	0f 93       	push	r16
    3b62:	1f 93       	push	r17
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	cd b7       	in	r28, 0x3d	; 61
    3b6a:	de b7       	in	r29, 0x3e	; 62
    3b6c:	2b 97       	sbiw	r28, 0x0b	; 11
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	de bf       	out	0x3e, r29	; 62
    3b72:	6c 01       	movw	r12, r24
    3b74:	7b 01       	movw	r14, r22
    3b76:	8a 01       	movw	r16, r20
    3b78:	fc 01       	movw	r30, r24
    3b7a:	16 82       	std	Z+6, r1	; 0x06
    3b7c:	17 82       	std	Z+7, r1	; 0x07
    3b7e:	83 81       	ldd	r24, Z+3	; 0x03
    3b80:	81 ff       	sbrs	r24, 1
    3b82:	bf c1       	rjmp	.+894    	; 0x3f02 <vfprintf+0x3be>
    3b84:	ce 01       	movw	r24, r28
    3b86:	01 96       	adiw	r24, 0x01	; 1
    3b88:	3c 01       	movw	r6, r24
    3b8a:	f6 01       	movw	r30, r12
    3b8c:	93 81       	ldd	r25, Z+3	; 0x03
    3b8e:	f7 01       	movw	r30, r14
    3b90:	93 fd       	sbrc	r25, 3
    3b92:	85 91       	lpm	r24, Z+
    3b94:	93 ff       	sbrs	r25, 3
    3b96:	81 91       	ld	r24, Z+
    3b98:	7f 01       	movw	r14, r30
    3b9a:	88 23       	and	r24, r24
    3b9c:	09 f4       	brne	.+2      	; 0x3ba0 <vfprintf+0x5c>
    3b9e:	ad c1       	rjmp	.+858    	; 0x3efa <vfprintf+0x3b6>
    3ba0:	85 32       	cpi	r24, 0x25	; 37
    3ba2:	39 f4       	brne	.+14     	; 0x3bb2 <vfprintf+0x6e>
    3ba4:	93 fd       	sbrc	r25, 3
    3ba6:	85 91       	lpm	r24, Z+
    3ba8:	93 ff       	sbrs	r25, 3
    3baa:	81 91       	ld	r24, Z+
    3bac:	7f 01       	movw	r14, r30
    3bae:	85 32       	cpi	r24, 0x25	; 37
    3bb0:	21 f4       	brne	.+8      	; 0x3bba <vfprintf+0x76>
    3bb2:	b6 01       	movw	r22, r12
    3bb4:	90 e0       	ldi	r25, 0x00	; 0
    3bb6:	d3 d1       	rcall	.+934    	; 0x3f5e <fputc>
    3bb8:	e8 cf       	rjmp	.-48     	; 0x3b8a <vfprintf+0x46>
    3bba:	91 2c       	mov	r9, r1
    3bbc:	21 2c       	mov	r2, r1
    3bbe:	31 2c       	mov	r3, r1
    3bc0:	ff e1       	ldi	r31, 0x1F	; 31
    3bc2:	f3 15       	cp	r31, r3
    3bc4:	d8 f0       	brcs	.+54     	; 0x3bfc <vfprintf+0xb8>
    3bc6:	8b 32       	cpi	r24, 0x2B	; 43
    3bc8:	79 f0       	breq	.+30     	; 0x3be8 <vfprintf+0xa4>
    3bca:	38 f4       	brcc	.+14     	; 0x3bda <vfprintf+0x96>
    3bcc:	80 32       	cpi	r24, 0x20	; 32
    3bce:	79 f0       	breq	.+30     	; 0x3bee <vfprintf+0xaa>
    3bd0:	83 32       	cpi	r24, 0x23	; 35
    3bd2:	a1 f4       	brne	.+40     	; 0x3bfc <vfprintf+0xb8>
    3bd4:	23 2d       	mov	r18, r3
    3bd6:	20 61       	ori	r18, 0x10	; 16
    3bd8:	1d c0       	rjmp	.+58     	; 0x3c14 <vfprintf+0xd0>
    3bda:	8d 32       	cpi	r24, 0x2D	; 45
    3bdc:	61 f0       	breq	.+24     	; 0x3bf6 <vfprintf+0xb2>
    3bde:	80 33       	cpi	r24, 0x30	; 48
    3be0:	69 f4       	brne	.+26     	; 0x3bfc <vfprintf+0xb8>
    3be2:	23 2d       	mov	r18, r3
    3be4:	21 60       	ori	r18, 0x01	; 1
    3be6:	16 c0       	rjmp	.+44     	; 0x3c14 <vfprintf+0xd0>
    3be8:	83 2d       	mov	r24, r3
    3bea:	82 60       	ori	r24, 0x02	; 2
    3bec:	38 2e       	mov	r3, r24
    3bee:	e3 2d       	mov	r30, r3
    3bf0:	e4 60       	ori	r30, 0x04	; 4
    3bf2:	3e 2e       	mov	r3, r30
    3bf4:	2a c0       	rjmp	.+84     	; 0x3c4a <vfprintf+0x106>
    3bf6:	f3 2d       	mov	r31, r3
    3bf8:	f8 60       	ori	r31, 0x08	; 8
    3bfa:	1d c0       	rjmp	.+58     	; 0x3c36 <vfprintf+0xf2>
    3bfc:	37 fc       	sbrc	r3, 7
    3bfe:	2d c0       	rjmp	.+90     	; 0x3c5a <vfprintf+0x116>
    3c00:	20 ed       	ldi	r18, 0xD0	; 208
    3c02:	28 0f       	add	r18, r24
    3c04:	2a 30       	cpi	r18, 0x0A	; 10
    3c06:	40 f0       	brcs	.+16     	; 0x3c18 <vfprintf+0xd4>
    3c08:	8e 32       	cpi	r24, 0x2E	; 46
    3c0a:	b9 f4       	brne	.+46     	; 0x3c3a <vfprintf+0xf6>
    3c0c:	36 fc       	sbrc	r3, 6
    3c0e:	75 c1       	rjmp	.+746    	; 0x3efa <vfprintf+0x3b6>
    3c10:	23 2d       	mov	r18, r3
    3c12:	20 64       	ori	r18, 0x40	; 64
    3c14:	32 2e       	mov	r3, r18
    3c16:	19 c0       	rjmp	.+50     	; 0x3c4a <vfprintf+0x106>
    3c18:	36 fe       	sbrs	r3, 6
    3c1a:	06 c0       	rjmp	.+12     	; 0x3c28 <vfprintf+0xe4>
    3c1c:	8a e0       	ldi	r24, 0x0A	; 10
    3c1e:	98 9e       	mul	r9, r24
    3c20:	20 0d       	add	r18, r0
    3c22:	11 24       	eor	r1, r1
    3c24:	92 2e       	mov	r9, r18
    3c26:	11 c0       	rjmp	.+34     	; 0x3c4a <vfprintf+0x106>
    3c28:	ea e0       	ldi	r30, 0x0A	; 10
    3c2a:	2e 9e       	mul	r2, r30
    3c2c:	20 0d       	add	r18, r0
    3c2e:	11 24       	eor	r1, r1
    3c30:	22 2e       	mov	r2, r18
    3c32:	f3 2d       	mov	r31, r3
    3c34:	f0 62       	ori	r31, 0x20	; 32
    3c36:	3f 2e       	mov	r3, r31
    3c38:	08 c0       	rjmp	.+16     	; 0x3c4a <vfprintf+0x106>
    3c3a:	8c 36       	cpi	r24, 0x6C	; 108
    3c3c:	21 f4       	brne	.+8      	; 0x3c46 <vfprintf+0x102>
    3c3e:	83 2d       	mov	r24, r3
    3c40:	80 68       	ori	r24, 0x80	; 128
    3c42:	38 2e       	mov	r3, r24
    3c44:	02 c0       	rjmp	.+4      	; 0x3c4a <vfprintf+0x106>
    3c46:	88 36       	cpi	r24, 0x68	; 104
    3c48:	41 f4       	brne	.+16     	; 0x3c5a <vfprintf+0x116>
    3c4a:	f7 01       	movw	r30, r14
    3c4c:	93 fd       	sbrc	r25, 3
    3c4e:	85 91       	lpm	r24, Z+
    3c50:	93 ff       	sbrs	r25, 3
    3c52:	81 91       	ld	r24, Z+
    3c54:	7f 01       	movw	r14, r30
    3c56:	81 11       	cpse	r24, r1
    3c58:	b3 cf       	rjmp	.-154    	; 0x3bc0 <vfprintf+0x7c>
    3c5a:	98 2f       	mov	r25, r24
    3c5c:	9f 7d       	andi	r25, 0xDF	; 223
    3c5e:	95 54       	subi	r25, 0x45	; 69
    3c60:	93 30       	cpi	r25, 0x03	; 3
    3c62:	28 f4       	brcc	.+10     	; 0x3c6e <vfprintf+0x12a>
    3c64:	0c 5f       	subi	r16, 0xFC	; 252
    3c66:	1f 4f       	sbci	r17, 0xFF	; 255
    3c68:	9f e3       	ldi	r25, 0x3F	; 63
    3c6a:	99 83       	std	Y+1, r25	; 0x01
    3c6c:	0d c0       	rjmp	.+26     	; 0x3c88 <vfprintf+0x144>
    3c6e:	83 36       	cpi	r24, 0x63	; 99
    3c70:	31 f0       	breq	.+12     	; 0x3c7e <vfprintf+0x13a>
    3c72:	83 37       	cpi	r24, 0x73	; 115
    3c74:	71 f0       	breq	.+28     	; 0x3c92 <vfprintf+0x14e>
    3c76:	83 35       	cpi	r24, 0x53	; 83
    3c78:	09 f0       	breq	.+2      	; 0x3c7c <vfprintf+0x138>
    3c7a:	55 c0       	rjmp	.+170    	; 0x3d26 <vfprintf+0x1e2>
    3c7c:	20 c0       	rjmp	.+64     	; 0x3cbe <vfprintf+0x17a>
    3c7e:	f8 01       	movw	r30, r16
    3c80:	80 81       	ld	r24, Z
    3c82:	89 83       	std	Y+1, r24	; 0x01
    3c84:	0e 5f       	subi	r16, 0xFE	; 254
    3c86:	1f 4f       	sbci	r17, 0xFF	; 255
    3c88:	88 24       	eor	r8, r8
    3c8a:	83 94       	inc	r8
    3c8c:	91 2c       	mov	r9, r1
    3c8e:	53 01       	movw	r10, r6
    3c90:	12 c0       	rjmp	.+36     	; 0x3cb6 <vfprintf+0x172>
    3c92:	28 01       	movw	r4, r16
    3c94:	f2 e0       	ldi	r31, 0x02	; 2
    3c96:	4f 0e       	add	r4, r31
    3c98:	51 1c       	adc	r5, r1
    3c9a:	f8 01       	movw	r30, r16
    3c9c:	a0 80       	ld	r10, Z
    3c9e:	b1 80       	ldd	r11, Z+1	; 0x01
    3ca0:	36 fe       	sbrs	r3, 6
    3ca2:	03 c0       	rjmp	.+6      	; 0x3caa <vfprintf+0x166>
    3ca4:	69 2d       	mov	r22, r9
    3ca6:	70 e0       	ldi	r23, 0x00	; 0
    3ca8:	02 c0       	rjmp	.+4      	; 0x3cae <vfprintf+0x16a>
    3caa:	6f ef       	ldi	r22, 0xFF	; 255
    3cac:	7f ef       	ldi	r23, 0xFF	; 255
    3cae:	c5 01       	movw	r24, r10
    3cb0:	4b d1       	rcall	.+662    	; 0x3f48 <strnlen>
    3cb2:	4c 01       	movw	r8, r24
    3cb4:	82 01       	movw	r16, r4
    3cb6:	f3 2d       	mov	r31, r3
    3cb8:	ff 77       	andi	r31, 0x7F	; 127
    3cba:	3f 2e       	mov	r3, r31
    3cbc:	15 c0       	rjmp	.+42     	; 0x3ce8 <vfprintf+0x1a4>
    3cbe:	28 01       	movw	r4, r16
    3cc0:	22 e0       	ldi	r18, 0x02	; 2
    3cc2:	42 0e       	add	r4, r18
    3cc4:	51 1c       	adc	r5, r1
    3cc6:	f8 01       	movw	r30, r16
    3cc8:	a0 80       	ld	r10, Z
    3cca:	b1 80       	ldd	r11, Z+1	; 0x01
    3ccc:	36 fe       	sbrs	r3, 6
    3cce:	03 c0       	rjmp	.+6      	; 0x3cd6 <vfprintf+0x192>
    3cd0:	69 2d       	mov	r22, r9
    3cd2:	70 e0       	ldi	r23, 0x00	; 0
    3cd4:	02 c0       	rjmp	.+4      	; 0x3cda <vfprintf+0x196>
    3cd6:	6f ef       	ldi	r22, 0xFF	; 255
    3cd8:	7f ef       	ldi	r23, 0xFF	; 255
    3cda:	c5 01       	movw	r24, r10
    3cdc:	2a d1       	rcall	.+596    	; 0x3f32 <strnlen_P>
    3cde:	4c 01       	movw	r8, r24
    3ce0:	f3 2d       	mov	r31, r3
    3ce2:	f0 68       	ori	r31, 0x80	; 128
    3ce4:	3f 2e       	mov	r3, r31
    3ce6:	82 01       	movw	r16, r4
    3ce8:	33 fc       	sbrc	r3, 3
    3cea:	19 c0       	rjmp	.+50     	; 0x3d1e <vfprintf+0x1da>
    3cec:	82 2d       	mov	r24, r2
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	88 16       	cp	r8, r24
    3cf2:	99 06       	cpc	r9, r25
    3cf4:	a0 f4       	brcc	.+40     	; 0x3d1e <vfprintf+0x1da>
    3cf6:	b6 01       	movw	r22, r12
    3cf8:	80 e2       	ldi	r24, 0x20	; 32
    3cfa:	90 e0       	ldi	r25, 0x00	; 0
    3cfc:	30 d1       	rcall	.+608    	; 0x3f5e <fputc>
    3cfe:	2a 94       	dec	r2
    3d00:	f5 cf       	rjmp	.-22     	; 0x3cec <vfprintf+0x1a8>
    3d02:	f5 01       	movw	r30, r10
    3d04:	37 fc       	sbrc	r3, 7
    3d06:	85 91       	lpm	r24, Z+
    3d08:	37 fe       	sbrs	r3, 7
    3d0a:	81 91       	ld	r24, Z+
    3d0c:	5f 01       	movw	r10, r30
    3d0e:	b6 01       	movw	r22, r12
    3d10:	90 e0       	ldi	r25, 0x00	; 0
    3d12:	25 d1       	rcall	.+586    	; 0x3f5e <fputc>
    3d14:	21 10       	cpse	r2, r1
    3d16:	2a 94       	dec	r2
    3d18:	21 e0       	ldi	r18, 0x01	; 1
    3d1a:	82 1a       	sub	r8, r18
    3d1c:	91 08       	sbc	r9, r1
    3d1e:	81 14       	cp	r8, r1
    3d20:	91 04       	cpc	r9, r1
    3d22:	79 f7       	brne	.-34     	; 0x3d02 <vfprintf+0x1be>
    3d24:	e1 c0       	rjmp	.+450    	; 0x3ee8 <vfprintf+0x3a4>
    3d26:	84 36       	cpi	r24, 0x64	; 100
    3d28:	11 f0       	breq	.+4      	; 0x3d2e <vfprintf+0x1ea>
    3d2a:	89 36       	cpi	r24, 0x69	; 105
    3d2c:	39 f5       	brne	.+78     	; 0x3d7c <vfprintf+0x238>
    3d2e:	f8 01       	movw	r30, r16
    3d30:	37 fe       	sbrs	r3, 7
    3d32:	07 c0       	rjmp	.+14     	; 0x3d42 <vfprintf+0x1fe>
    3d34:	60 81       	ld	r22, Z
    3d36:	71 81       	ldd	r23, Z+1	; 0x01
    3d38:	82 81       	ldd	r24, Z+2	; 0x02
    3d3a:	93 81       	ldd	r25, Z+3	; 0x03
    3d3c:	0c 5f       	subi	r16, 0xFC	; 252
    3d3e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d40:	08 c0       	rjmp	.+16     	; 0x3d52 <vfprintf+0x20e>
    3d42:	60 81       	ld	r22, Z
    3d44:	71 81       	ldd	r23, Z+1	; 0x01
    3d46:	07 2e       	mov	r0, r23
    3d48:	00 0c       	add	r0, r0
    3d4a:	88 0b       	sbc	r24, r24
    3d4c:	99 0b       	sbc	r25, r25
    3d4e:	0e 5f       	subi	r16, 0xFE	; 254
    3d50:	1f 4f       	sbci	r17, 0xFF	; 255
    3d52:	f3 2d       	mov	r31, r3
    3d54:	ff 76       	andi	r31, 0x6F	; 111
    3d56:	3f 2e       	mov	r3, r31
    3d58:	97 ff       	sbrs	r25, 7
    3d5a:	09 c0       	rjmp	.+18     	; 0x3d6e <vfprintf+0x22a>
    3d5c:	90 95       	com	r25
    3d5e:	80 95       	com	r24
    3d60:	70 95       	com	r23
    3d62:	61 95       	neg	r22
    3d64:	7f 4f       	sbci	r23, 0xFF	; 255
    3d66:	8f 4f       	sbci	r24, 0xFF	; 255
    3d68:	9f 4f       	sbci	r25, 0xFF	; 255
    3d6a:	f0 68       	ori	r31, 0x80	; 128
    3d6c:	3f 2e       	mov	r3, r31
    3d6e:	2a e0       	ldi	r18, 0x0A	; 10
    3d70:	30 e0       	ldi	r19, 0x00	; 0
    3d72:	a3 01       	movw	r20, r6
    3d74:	30 d1       	rcall	.+608    	; 0x3fd6 <__ultoa_invert>
    3d76:	88 2e       	mov	r8, r24
    3d78:	86 18       	sub	r8, r6
    3d7a:	44 c0       	rjmp	.+136    	; 0x3e04 <vfprintf+0x2c0>
    3d7c:	85 37       	cpi	r24, 0x75	; 117
    3d7e:	31 f4       	brne	.+12     	; 0x3d8c <vfprintf+0x248>
    3d80:	23 2d       	mov	r18, r3
    3d82:	2f 7e       	andi	r18, 0xEF	; 239
    3d84:	b2 2e       	mov	r11, r18
    3d86:	2a e0       	ldi	r18, 0x0A	; 10
    3d88:	30 e0       	ldi	r19, 0x00	; 0
    3d8a:	25 c0       	rjmp	.+74     	; 0x3dd6 <vfprintf+0x292>
    3d8c:	93 2d       	mov	r25, r3
    3d8e:	99 7f       	andi	r25, 0xF9	; 249
    3d90:	b9 2e       	mov	r11, r25
    3d92:	8f 36       	cpi	r24, 0x6F	; 111
    3d94:	c1 f0       	breq	.+48     	; 0x3dc6 <vfprintf+0x282>
    3d96:	18 f4       	brcc	.+6      	; 0x3d9e <vfprintf+0x25a>
    3d98:	88 35       	cpi	r24, 0x58	; 88
    3d9a:	79 f0       	breq	.+30     	; 0x3dba <vfprintf+0x276>
    3d9c:	ae c0       	rjmp	.+348    	; 0x3efa <vfprintf+0x3b6>
    3d9e:	80 37       	cpi	r24, 0x70	; 112
    3da0:	19 f0       	breq	.+6      	; 0x3da8 <vfprintf+0x264>
    3da2:	88 37       	cpi	r24, 0x78	; 120
    3da4:	21 f0       	breq	.+8      	; 0x3dae <vfprintf+0x26a>
    3da6:	a9 c0       	rjmp	.+338    	; 0x3efa <vfprintf+0x3b6>
    3da8:	e9 2f       	mov	r30, r25
    3daa:	e0 61       	ori	r30, 0x10	; 16
    3dac:	be 2e       	mov	r11, r30
    3dae:	b4 fe       	sbrs	r11, 4
    3db0:	0d c0       	rjmp	.+26     	; 0x3dcc <vfprintf+0x288>
    3db2:	fb 2d       	mov	r31, r11
    3db4:	f4 60       	ori	r31, 0x04	; 4
    3db6:	bf 2e       	mov	r11, r31
    3db8:	09 c0       	rjmp	.+18     	; 0x3dcc <vfprintf+0x288>
    3dba:	34 fe       	sbrs	r3, 4
    3dbc:	0a c0       	rjmp	.+20     	; 0x3dd2 <vfprintf+0x28e>
    3dbe:	29 2f       	mov	r18, r25
    3dc0:	26 60       	ori	r18, 0x06	; 6
    3dc2:	b2 2e       	mov	r11, r18
    3dc4:	06 c0       	rjmp	.+12     	; 0x3dd2 <vfprintf+0x28e>
    3dc6:	28 e0       	ldi	r18, 0x08	; 8
    3dc8:	30 e0       	ldi	r19, 0x00	; 0
    3dca:	05 c0       	rjmp	.+10     	; 0x3dd6 <vfprintf+0x292>
    3dcc:	20 e1       	ldi	r18, 0x10	; 16
    3dce:	30 e0       	ldi	r19, 0x00	; 0
    3dd0:	02 c0       	rjmp	.+4      	; 0x3dd6 <vfprintf+0x292>
    3dd2:	20 e1       	ldi	r18, 0x10	; 16
    3dd4:	32 e0       	ldi	r19, 0x02	; 2
    3dd6:	f8 01       	movw	r30, r16
    3dd8:	b7 fe       	sbrs	r11, 7
    3dda:	07 c0       	rjmp	.+14     	; 0x3dea <vfprintf+0x2a6>
    3ddc:	60 81       	ld	r22, Z
    3dde:	71 81       	ldd	r23, Z+1	; 0x01
    3de0:	82 81       	ldd	r24, Z+2	; 0x02
    3de2:	93 81       	ldd	r25, Z+3	; 0x03
    3de4:	0c 5f       	subi	r16, 0xFC	; 252
    3de6:	1f 4f       	sbci	r17, 0xFF	; 255
    3de8:	06 c0       	rjmp	.+12     	; 0x3df6 <vfprintf+0x2b2>
    3dea:	60 81       	ld	r22, Z
    3dec:	71 81       	ldd	r23, Z+1	; 0x01
    3dee:	80 e0       	ldi	r24, 0x00	; 0
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	0e 5f       	subi	r16, 0xFE	; 254
    3df4:	1f 4f       	sbci	r17, 0xFF	; 255
    3df6:	a3 01       	movw	r20, r6
    3df8:	ee d0       	rcall	.+476    	; 0x3fd6 <__ultoa_invert>
    3dfa:	88 2e       	mov	r8, r24
    3dfc:	86 18       	sub	r8, r6
    3dfe:	fb 2d       	mov	r31, r11
    3e00:	ff 77       	andi	r31, 0x7F	; 127
    3e02:	3f 2e       	mov	r3, r31
    3e04:	36 fe       	sbrs	r3, 6
    3e06:	0d c0       	rjmp	.+26     	; 0x3e22 <vfprintf+0x2de>
    3e08:	23 2d       	mov	r18, r3
    3e0a:	2e 7f       	andi	r18, 0xFE	; 254
    3e0c:	a2 2e       	mov	r10, r18
    3e0e:	89 14       	cp	r8, r9
    3e10:	58 f4       	brcc	.+22     	; 0x3e28 <vfprintf+0x2e4>
    3e12:	34 fe       	sbrs	r3, 4
    3e14:	0b c0       	rjmp	.+22     	; 0x3e2c <vfprintf+0x2e8>
    3e16:	32 fc       	sbrc	r3, 2
    3e18:	09 c0       	rjmp	.+18     	; 0x3e2c <vfprintf+0x2e8>
    3e1a:	83 2d       	mov	r24, r3
    3e1c:	8e 7e       	andi	r24, 0xEE	; 238
    3e1e:	a8 2e       	mov	r10, r24
    3e20:	05 c0       	rjmp	.+10     	; 0x3e2c <vfprintf+0x2e8>
    3e22:	b8 2c       	mov	r11, r8
    3e24:	a3 2c       	mov	r10, r3
    3e26:	03 c0       	rjmp	.+6      	; 0x3e2e <vfprintf+0x2ea>
    3e28:	b8 2c       	mov	r11, r8
    3e2a:	01 c0       	rjmp	.+2      	; 0x3e2e <vfprintf+0x2ea>
    3e2c:	b9 2c       	mov	r11, r9
    3e2e:	a4 fe       	sbrs	r10, 4
    3e30:	0f c0       	rjmp	.+30     	; 0x3e50 <vfprintf+0x30c>
    3e32:	fe 01       	movw	r30, r28
    3e34:	e8 0d       	add	r30, r8
    3e36:	f1 1d       	adc	r31, r1
    3e38:	80 81       	ld	r24, Z
    3e3a:	80 33       	cpi	r24, 0x30	; 48
    3e3c:	21 f4       	brne	.+8      	; 0x3e46 <vfprintf+0x302>
    3e3e:	9a 2d       	mov	r25, r10
    3e40:	99 7e       	andi	r25, 0xE9	; 233
    3e42:	a9 2e       	mov	r10, r25
    3e44:	09 c0       	rjmp	.+18     	; 0x3e58 <vfprintf+0x314>
    3e46:	a2 fe       	sbrs	r10, 2
    3e48:	06 c0       	rjmp	.+12     	; 0x3e56 <vfprintf+0x312>
    3e4a:	b3 94       	inc	r11
    3e4c:	b3 94       	inc	r11
    3e4e:	04 c0       	rjmp	.+8      	; 0x3e58 <vfprintf+0x314>
    3e50:	8a 2d       	mov	r24, r10
    3e52:	86 78       	andi	r24, 0x86	; 134
    3e54:	09 f0       	breq	.+2      	; 0x3e58 <vfprintf+0x314>
    3e56:	b3 94       	inc	r11
    3e58:	a3 fc       	sbrc	r10, 3
    3e5a:	10 c0       	rjmp	.+32     	; 0x3e7c <vfprintf+0x338>
    3e5c:	a0 fe       	sbrs	r10, 0
    3e5e:	06 c0       	rjmp	.+12     	; 0x3e6c <vfprintf+0x328>
    3e60:	b2 14       	cp	r11, r2
    3e62:	80 f4       	brcc	.+32     	; 0x3e84 <vfprintf+0x340>
    3e64:	28 0c       	add	r2, r8
    3e66:	92 2c       	mov	r9, r2
    3e68:	9b 18       	sub	r9, r11
    3e6a:	0d c0       	rjmp	.+26     	; 0x3e86 <vfprintf+0x342>
    3e6c:	b2 14       	cp	r11, r2
    3e6e:	58 f4       	brcc	.+22     	; 0x3e86 <vfprintf+0x342>
    3e70:	b6 01       	movw	r22, r12
    3e72:	80 e2       	ldi	r24, 0x20	; 32
    3e74:	90 e0       	ldi	r25, 0x00	; 0
    3e76:	73 d0       	rcall	.+230    	; 0x3f5e <fputc>
    3e78:	b3 94       	inc	r11
    3e7a:	f8 cf       	rjmp	.-16     	; 0x3e6c <vfprintf+0x328>
    3e7c:	b2 14       	cp	r11, r2
    3e7e:	18 f4       	brcc	.+6      	; 0x3e86 <vfprintf+0x342>
    3e80:	2b 18       	sub	r2, r11
    3e82:	02 c0       	rjmp	.+4      	; 0x3e88 <vfprintf+0x344>
    3e84:	98 2c       	mov	r9, r8
    3e86:	21 2c       	mov	r2, r1
    3e88:	a4 fe       	sbrs	r10, 4
    3e8a:	0f c0       	rjmp	.+30     	; 0x3eaa <vfprintf+0x366>
    3e8c:	b6 01       	movw	r22, r12
    3e8e:	80 e3       	ldi	r24, 0x30	; 48
    3e90:	90 e0       	ldi	r25, 0x00	; 0
    3e92:	65 d0       	rcall	.+202    	; 0x3f5e <fputc>
    3e94:	a2 fe       	sbrs	r10, 2
    3e96:	16 c0       	rjmp	.+44     	; 0x3ec4 <vfprintf+0x380>
    3e98:	a1 fc       	sbrc	r10, 1
    3e9a:	03 c0       	rjmp	.+6      	; 0x3ea2 <vfprintf+0x35e>
    3e9c:	88 e7       	ldi	r24, 0x78	; 120
    3e9e:	90 e0       	ldi	r25, 0x00	; 0
    3ea0:	02 c0       	rjmp	.+4      	; 0x3ea6 <vfprintf+0x362>
    3ea2:	88 e5       	ldi	r24, 0x58	; 88
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	b6 01       	movw	r22, r12
    3ea8:	0c c0       	rjmp	.+24     	; 0x3ec2 <vfprintf+0x37e>
    3eaa:	8a 2d       	mov	r24, r10
    3eac:	86 78       	andi	r24, 0x86	; 134
    3eae:	51 f0       	breq	.+20     	; 0x3ec4 <vfprintf+0x380>
    3eb0:	a1 fe       	sbrs	r10, 1
    3eb2:	02 c0       	rjmp	.+4      	; 0x3eb8 <vfprintf+0x374>
    3eb4:	8b e2       	ldi	r24, 0x2B	; 43
    3eb6:	01 c0       	rjmp	.+2      	; 0x3eba <vfprintf+0x376>
    3eb8:	80 e2       	ldi	r24, 0x20	; 32
    3eba:	a7 fc       	sbrc	r10, 7
    3ebc:	8d e2       	ldi	r24, 0x2D	; 45
    3ebe:	b6 01       	movw	r22, r12
    3ec0:	90 e0       	ldi	r25, 0x00	; 0
    3ec2:	4d d0       	rcall	.+154    	; 0x3f5e <fputc>
    3ec4:	89 14       	cp	r8, r9
    3ec6:	30 f4       	brcc	.+12     	; 0x3ed4 <vfprintf+0x390>
    3ec8:	b6 01       	movw	r22, r12
    3eca:	80 e3       	ldi	r24, 0x30	; 48
    3ecc:	90 e0       	ldi	r25, 0x00	; 0
    3ece:	47 d0       	rcall	.+142    	; 0x3f5e <fputc>
    3ed0:	9a 94       	dec	r9
    3ed2:	f8 cf       	rjmp	.-16     	; 0x3ec4 <vfprintf+0x380>
    3ed4:	8a 94       	dec	r8
    3ed6:	f3 01       	movw	r30, r6
    3ed8:	e8 0d       	add	r30, r8
    3eda:	f1 1d       	adc	r31, r1
    3edc:	80 81       	ld	r24, Z
    3ede:	b6 01       	movw	r22, r12
    3ee0:	90 e0       	ldi	r25, 0x00	; 0
    3ee2:	3d d0       	rcall	.+122    	; 0x3f5e <fputc>
    3ee4:	81 10       	cpse	r8, r1
    3ee6:	f6 cf       	rjmp	.-20     	; 0x3ed4 <vfprintf+0x390>
    3ee8:	22 20       	and	r2, r2
    3eea:	09 f4       	brne	.+2      	; 0x3eee <vfprintf+0x3aa>
    3eec:	4e ce       	rjmp	.-868    	; 0x3b8a <vfprintf+0x46>
    3eee:	b6 01       	movw	r22, r12
    3ef0:	80 e2       	ldi	r24, 0x20	; 32
    3ef2:	90 e0       	ldi	r25, 0x00	; 0
    3ef4:	34 d0       	rcall	.+104    	; 0x3f5e <fputc>
    3ef6:	2a 94       	dec	r2
    3ef8:	f7 cf       	rjmp	.-18     	; 0x3ee8 <vfprintf+0x3a4>
    3efa:	f6 01       	movw	r30, r12
    3efc:	86 81       	ldd	r24, Z+6	; 0x06
    3efe:	97 81       	ldd	r25, Z+7	; 0x07
    3f00:	02 c0       	rjmp	.+4      	; 0x3f06 <vfprintf+0x3c2>
    3f02:	8f ef       	ldi	r24, 0xFF	; 255
    3f04:	9f ef       	ldi	r25, 0xFF	; 255
    3f06:	2b 96       	adiw	r28, 0x0b	; 11
    3f08:	cd bf       	out	0x3d, r28	; 61
    3f0a:	de bf       	out	0x3e, r29	; 62
    3f0c:	df 91       	pop	r29
    3f0e:	cf 91       	pop	r28
    3f10:	1f 91       	pop	r17
    3f12:	0f 91       	pop	r16
    3f14:	ff 90       	pop	r15
    3f16:	ef 90       	pop	r14
    3f18:	df 90       	pop	r13
    3f1a:	cf 90       	pop	r12
    3f1c:	bf 90       	pop	r11
    3f1e:	af 90       	pop	r10
    3f20:	9f 90       	pop	r9
    3f22:	8f 90       	pop	r8
    3f24:	7f 90       	pop	r7
    3f26:	6f 90       	pop	r6
    3f28:	5f 90       	pop	r5
    3f2a:	4f 90       	pop	r4
    3f2c:	3f 90       	pop	r3
    3f2e:	2f 90       	pop	r2
    3f30:	08 95       	ret

00003f32 <strnlen_P>:
    3f32:	fc 01       	movw	r30, r24
    3f34:	05 90       	lpm	r0, Z+
    3f36:	61 50       	subi	r22, 0x01	; 1
    3f38:	70 40       	sbci	r23, 0x00	; 0
    3f3a:	01 10       	cpse	r0, r1
    3f3c:	d8 f7       	brcc	.-10     	; 0x3f34 <strnlen_P+0x2>
    3f3e:	80 95       	com	r24
    3f40:	90 95       	com	r25
    3f42:	8e 0f       	add	r24, r30
    3f44:	9f 1f       	adc	r25, r31
    3f46:	08 95       	ret

00003f48 <strnlen>:
    3f48:	fc 01       	movw	r30, r24
    3f4a:	61 50       	subi	r22, 0x01	; 1
    3f4c:	70 40       	sbci	r23, 0x00	; 0
    3f4e:	01 90       	ld	r0, Z+
    3f50:	01 10       	cpse	r0, r1
    3f52:	d8 f7       	brcc	.-10     	; 0x3f4a <strnlen+0x2>
    3f54:	80 95       	com	r24
    3f56:	90 95       	com	r25
    3f58:	8e 0f       	add	r24, r30
    3f5a:	9f 1f       	adc	r25, r31
    3f5c:	08 95       	ret

00003f5e <fputc>:
    3f5e:	0f 93       	push	r16
    3f60:	1f 93       	push	r17
    3f62:	cf 93       	push	r28
    3f64:	df 93       	push	r29
    3f66:	fb 01       	movw	r30, r22
    3f68:	23 81       	ldd	r18, Z+3	; 0x03
    3f6a:	21 fd       	sbrc	r18, 1
    3f6c:	03 c0       	rjmp	.+6      	; 0x3f74 <fputc+0x16>
    3f6e:	8f ef       	ldi	r24, 0xFF	; 255
    3f70:	9f ef       	ldi	r25, 0xFF	; 255
    3f72:	2c c0       	rjmp	.+88     	; 0x3fcc <fputc+0x6e>
    3f74:	22 ff       	sbrs	r18, 2
    3f76:	16 c0       	rjmp	.+44     	; 0x3fa4 <fputc+0x46>
    3f78:	46 81       	ldd	r20, Z+6	; 0x06
    3f7a:	57 81       	ldd	r21, Z+7	; 0x07
    3f7c:	24 81       	ldd	r18, Z+4	; 0x04
    3f7e:	35 81       	ldd	r19, Z+5	; 0x05
    3f80:	42 17       	cp	r20, r18
    3f82:	53 07       	cpc	r21, r19
    3f84:	44 f4       	brge	.+16     	; 0x3f96 <fputc+0x38>
    3f86:	a0 81       	ld	r26, Z
    3f88:	b1 81       	ldd	r27, Z+1	; 0x01
    3f8a:	9d 01       	movw	r18, r26
    3f8c:	2f 5f       	subi	r18, 0xFF	; 255
    3f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f90:	20 83       	st	Z, r18
    3f92:	31 83       	std	Z+1, r19	; 0x01
    3f94:	8c 93       	st	X, r24
    3f96:	26 81       	ldd	r18, Z+6	; 0x06
    3f98:	37 81       	ldd	r19, Z+7	; 0x07
    3f9a:	2f 5f       	subi	r18, 0xFF	; 255
    3f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f9e:	26 83       	std	Z+6, r18	; 0x06
    3fa0:	37 83       	std	Z+7, r19	; 0x07
    3fa2:	14 c0       	rjmp	.+40     	; 0x3fcc <fputc+0x6e>
    3fa4:	8b 01       	movw	r16, r22
    3fa6:	ec 01       	movw	r28, r24
    3fa8:	fb 01       	movw	r30, r22
    3faa:	00 84       	ldd	r0, Z+8	; 0x08
    3fac:	f1 85       	ldd	r31, Z+9	; 0x09
    3fae:	e0 2d       	mov	r30, r0
    3fb0:	19 95       	eicall
    3fb2:	89 2b       	or	r24, r25
    3fb4:	e1 f6       	brne	.-72     	; 0x3f6e <fputc+0x10>
    3fb6:	d8 01       	movw	r26, r16
    3fb8:	16 96       	adiw	r26, 0x06	; 6
    3fba:	8d 91       	ld	r24, X+
    3fbc:	9c 91       	ld	r25, X
    3fbe:	17 97       	sbiw	r26, 0x07	; 7
    3fc0:	01 96       	adiw	r24, 0x01	; 1
    3fc2:	16 96       	adiw	r26, 0x06	; 6
    3fc4:	8d 93       	st	X+, r24
    3fc6:	9c 93       	st	X, r25
    3fc8:	17 97       	sbiw	r26, 0x07	; 7
    3fca:	ce 01       	movw	r24, r28
    3fcc:	df 91       	pop	r29
    3fce:	cf 91       	pop	r28
    3fd0:	1f 91       	pop	r17
    3fd2:	0f 91       	pop	r16
    3fd4:	08 95       	ret

00003fd6 <__ultoa_invert>:
    3fd6:	fa 01       	movw	r30, r20
    3fd8:	aa 27       	eor	r26, r26
    3fda:	28 30       	cpi	r18, 0x08	; 8
    3fdc:	51 f1       	breq	.+84     	; 0x4032 <__ultoa_invert+0x5c>
    3fde:	20 31       	cpi	r18, 0x10	; 16
    3fe0:	81 f1       	breq	.+96     	; 0x4042 <__ultoa_invert+0x6c>
    3fe2:	e8 94       	clt
    3fe4:	6f 93       	push	r22
    3fe6:	6e 7f       	andi	r22, 0xFE	; 254
    3fe8:	6e 5f       	subi	r22, 0xFE	; 254
    3fea:	7f 4f       	sbci	r23, 0xFF	; 255
    3fec:	8f 4f       	sbci	r24, 0xFF	; 255
    3fee:	9f 4f       	sbci	r25, 0xFF	; 255
    3ff0:	af 4f       	sbci	r26, 0xFF	; 255
    3ff2:	b1 e0       	ldi	r27, 0x01	; 1
    3ff4:	3e d0       	rcall	.+124    	; 0x4072 <__ultoa_invert+0x9c>
    3ff6:	b4 e0       	ldi	r27, 0x04	; 4
    3ff8:	3c d0       	rcall	.+120    	; 0x4072 <__ultoa_invert+0x9c>
    3ffa:	67 0f       	add	r22, r23
    3ffc:	78 1f       	adc	r23, r24
    3ffe:	89 1f       	adc	r24, r25
    4000:	9a 1f       	adc	r25, r26
    4002:	a1 1d       	adc	r26, r1
    4004:	68 0f       	add	r22, r24
    4006:	79 1f       	adc	r23, r25
    4008:	8a 1f       	adc	r24, r26
    400a:	91 1d       	adc	r25, r1
    400c:	a1 1d       	adc	r26, r1
    400e:	6a 0f       	add	r22, r26
    4010:	71 1d       	adc	r23, r1
    4012:	81 1d       	adc	r24, r1
    4014:	91 1d       	adc	r25, r1
    4016:	a1 1d       	adc	r26, r1
    4018:	20 d0       	rcall	.+64     	; 0x405a <__ultoa_invert+0x84>
    401a:	09 f4       	brne	.+2      	; 0x401e <__ultoa_invert+0x48>
    401c:	68 94       	set
    401e:	3f 91       	pop	r19
    4020:	2a e0       	ldi	r18, 0x0A	; 10
    4022:	26 9f       	mul	r18, r22
    4024:	11 24       	eor	r1, r1
    4026:	30 19       	sub	r19, r0
    4028:	30 5d       	subi	r19, 0xD0	; 208
    402a:	31 93       	st	Z+, r19
    402c:	de f6       	brtc	.-74     	; 0x3fe4 <__ultoa_invert+0xe>
    402e:	cf 01       	movw	r24, r30
    4030:	08 95       	ret
    4032:	46 2f       	mov	r20, r22
    4034:	47 70       	andi	r20, 0x07	; 7
    4036:	40 5d       	subi	r20, 0xD0	; 208
    4038:	41 93       	st	Z+, r20
    403a:	b3 e0       	ldi	r27, 0x03	; 3
    403c:	0f d0       	rcall	.+30     	; 0x405c <__ultoa_invert+0x86>
    403e:	c9 f7       	brne	.-14     	; 0x4032 <__ultoa_invert+0x5c>
    4040:	f6 cf       	rjmp	.-20     	; 0x402e <__ultoa_invert+0x58>
    4042:	46 2f       	mov	r20, r22
    4044:	4f 70       	andi	r20, 0x0F	; 15
    4046:	40 5d       	subi	r20, 0xD0	; 208
    4048:	4a 33       	cpi	r20, 0x3A	; 58
    404a:	18 f0       	brcs	.+6      	; 0x4052 <__ultoa_invert+0x7c>
    404c:	49 5d       	subi	r20, 0xD9	; 217
    404e:	31 fd       	sbrc	r19, 1
    4050:	40 52       	subi	r20, 0x20	; 32
    4052:	41 93       	st	Z+, r20
    4054:	02 d0       	rcall	.+4      	; 0x405a <__ultoa_invert+0x84>
    4056:	a9 f7       	brne	.-22     	; 0x4042 <__ultoa_invert+0x6c>
    4058:	ea cf       	rjmp	.-44     	; 0x402e <__ultoa_invert+0x58>
    405a:	b4 e0       	ldi	r27, 0x04	; 4
    405c:	a6 95       	lsr	r26
    405e:	97 95       	ror	r25
    4060:	87 95       	ror	r24
    4062:	77 95       	ror	r23
    4064:	67 95       	ror	r22
    4066:	ba 95       	dec	r27
    4068:	c9 f7       	brne	.-14     	; 0x405c <__ultoa_invert+0x86>
    406a:	00 97       	sbiw	r24, 0x00	; 0
    406c:	61 05       	cpc	r22, r1
    406e:	71 05       	cpc	r23, r1
    4070:	08 95       	ret
    4072:	9b 01       	movw	r18, r22
    4074:	ac 01       	movw	r20, r24
    4076:	0a 2e       	mov	r0, r26
    4078:	06 94       	lsr	r0
    407a:	57 95       	ror	r21
    407c:	47 95       	ror	r20
    407e:	37 95       	ror	r19
    4080:	27 95       	ror	r18
    4082:	ba 95       	dec	r27
    4084:	c9 f7       	brne	.-14     	; 0x4078 <__ultoa_invert+0xa2>
    4086:	62 0f       	add	r22, r18
    4088:	73 1f       	adc	r23, r19
    408a:	84 1f       	adc	r24, r20
    408c:	95 1f       	adc	r25, r21
    408e:	a0 1d       	adc	r26, r0
    4090:	08 95       	ret

00004092 <_exit>:
    4092:	f8 94       	cli

00004094 <__stop_program>:
    4094:	ff cf       	rjmp	.-2      	; 0x4094 <__stop_program>
